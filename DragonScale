=begin
#===============================================================================
# ■ Schala Battle System (Powered by XAS)
#===============================================================================
# Ver 2.0
# Data 06 / 08 / 2013
#===============================================================================
# Sistema de batalha que ocorre no mapa, estilo Chrono Trigger.
# Este é um sistema complexo e é necessário conhecimento intermediário do
# Rpg Maker VX ACE.
# Em caso de dúvidas favor verificar o manual que vem junto com este script.
#===============================================================================
 
#===============================================================================
# ■ Credits 
#===============================================================================
                                                                       
 Xiderowng / 桜雅 在土  for XAS Engine.
 http://xrxs.at-ninja.jp/
 
 Moghunter for Schala & Hero Edition
 http://www.atelier-rgss.com/ 
 
#===============================================================================
# ■ Histórico (Version History)
#===============================================================================

 v2.0
   - Possibilidadde de usar as ferramentas fora da fase de batalha.
   - Adição da pose de vitória.
   - Adição da janela de resultado.
   - Adição de Eventos Itens.
   - Adição do efeito de flutuar.
   - O calculo de dano das habilidades de cooperação agora são divididas
     entre os usuários da habilidade.
   - Melhoria considerável na performance.
       - Antilag funcional. 
       - Melhoria na processo de calculos na fase de batalha.
       - Sistema de Pre Cache, menor tempo de leitura dos sprites básicos.
   - Integração com função "Features" do Database
       - (Double Currency, Double Item, Encounters Disabled)
   - ADD-ONS
       - (Grandia ATB) Adição da medidor circular de ação.
       - (Aura Effect) Adição do efeito Aura.
       - (Active Bonus Gauge) Adição do medidor de bônus.
       - (Tech Anime) Adição da animação especial antes da habilidade.
       - (Tool Hud) Adição da Hud de ferramentas.
   - Melhoria geral na codificação do sistema.
   - Bug Fixes.
      
=end

#===============================================================================
# ■ SCHALA SYSTEM
#===============================================================================
module SCHALA_SYSTEM
  #Influência na velocidade do medidor de AT (CT)  
  AT_SPEED = 1500
  #Definição do sensor para ativar a batalha.
  BATTLE_SENSOR_RANGE = 2
  #Definição da area do campo de batalha baseado no centro da tela.
  #Apenas os eventos inimigos que estiverem dentro do campo de batalha
  #serão ativados.
  BATTLE_FIELD_RANGE = [9,7] 
  
  #-----------------------------------------------------------------------------
  # RESPAWN_EFFECT
  #-----------------------------------------------------------------------------
  # Ativar o efeito Respawn nos inimigos.
  # O respawn só ocorre quando o personagem se tranfere para um mapa.
  # Por exemplo, quando o personagem voltar ao mapa após 25 segundos os
  # inimigos estarão novamente no mapa.  
  ENEMY_RESPAWN_EFFECT = true
  #Tempo para ativar o respawn.
  ENEMY_RESPAWN_TIME_FOR_TRANSFER = 25 #Seconds
  #-----------------------------------------------------------------------------
  
  #Definição do balão que será ativado ao chegar perto do evento inimigo.
  EVENT_SENSOR_BALLOON_ID = 1
  # Definição do tempo para fugir da batalha.
  ESCAPE_DURATION = 100
  # Definição do botão de fugir. (Apenas quando o personagem estiver ativo.)
  ESCAPE_BUTTON = :X
  #Definição do som ao alcançar o nível máximo de AT (CT)  
  PLAYER_ACTIVE_SE = "Ice1"   
  #Ativar música de batalha.
  BATTLE_BGM = true
  #Ativar a música de vitória.
  PLAY_BATTLE_END_ME = false    
  #Ativar dano nos inimigos fora da batalha.
  DAMAGE_ENEMIES_OUT_BATTLE = false
  #Duração do tempo da da paralizia do inimigo quando a  ferramenta acertar
  #o inimigo.
  BATTLER_PARALYZE_DURATION = 240
  #Reviver o  grupo antes e após a batalha.
  REVIVE_PARTY_BATTLE_PHASE = false
end

#==============================================================================
# ■ SCHALA_FIELD
#==============================================================================
module SCHALA_FIELD
  #Variável que  define a posição da posição do Player [X,Y]
  #PLAYER_X_VARIABLE_ID = [99]  
  #PLAYER_Y_VARIABLE_ID = [100]
end

#==============================================================================
# ■ XAS TOOL
#==============================================================================
module XAS_TOOL
  #Definição do botão que ativa a ferramenta. 
  TOOL_BUTTON = :C 
  #Definição do botão que troca o lider.
  SHIFT_LEADER_BUTTON = :X
  #Defnição dos botões para mudar de ferramenta.
  SHIFT_R_TOOL_BUTTON = :R
  SHIFT_L_TOOL_BUTTON = :L
end

#==============================================================================
# ■ SCHALA BASE SPRITES
#==============================================================================
module SCHALA_BASE_SPRITES
  #Posição geral da hud de escapar.
  ESCAPE_POSITION = [10,260]
  #Posição do medidor de escapar.
  ESCAPE_METER_POSITION = [0,26]
  #Posição do comando.
  COMMAND_POSITION = [0,0]
  COMMAND_ICON_POSITION = [15,2]
  #Posição da imagem de fases da luta.(Battle,Victory,Escape,Defeated)
  TURN_SPRITE_POSITION = [150,180]
  #Posição do cursor de alvos.
  TARGET_CURSOR_POSITION = [-7,0]
  #Posição do nome do alvo.
  TARGET_NAME_POSITION = [-6,0]
  #Ativar o medidor de HP no cursor.
  #É possível desativar o HP em determinados inimigos usando o código abaixo.
  #<Hide HP>
  TARGET_HP_METER_ACTIVE = true
  #Definição da posição do layout do medidor de HP do alvo.
  TARGET_HP_POSITION = [-8,2]  
  #Definição da posição do medidor de HP do alvo.
  TARGET_METER_POSITION = [1,1]
  #Posição da janela de informações de habilidades de cooperação.
  TECH_WINDOW_POSITION = [15,200]
  #Definição do nome do tipo de habilidade de cooperação.
  MULTI_TECH_NAME = [ "Dual Tech", "Triple Tech"]
  #Definições da font da janela de Tech.
  TECH_WINDOW_FONT_NAME = "Georgia"
  TECH_WINDOW_FONT_SIZE = 18
  TECH_WINDOW_FONT_BOLD = true
  #Definição da prioridade das imagens na tela.
  SPRITES_Z = 110
  # Definição da visibilidade da Hud no inicio do jogo.
  # Se desejar mudar a visibilidade no meio do jogo use o código abaixo. 
  #
  # disable_hud
  #
  HUD_INITIAL_VISIBLE = false
end

#==============================================================================
# ■ SCHALA RESULT SPRITES
#==============================================================================
module MOG_SCHALA_RESULT  
  #Definição da posição dos sprites.
  RESULT_POSITION = [5,5]
  RESULT_EXP_POSITION = [10,12]
  RESULT_INFO_POSITION = [5,362]
  RESULT_TEXT_POSITION = [20,10]
  #Definição do nome da fonte.
  RESULT_FONT_NAME = "Arial"
  #Definição do tamanho da fonte.
  RESULT_FONT_SIZE = 20
  #Ativar Fonte em Bold
  RESULT_FONT_BOLD = true
  #Definição das cores das fontes
  NORMAL_FONT_COLOR = Color.new(255,255,255)
  LEARNED_FONT_COLOR = Color.new(255,155,155)
  #Apresentar AP (Ability Points)
  #Para definir a quantidade de AP do inimigo, coloque na caixa de notas.
  #<AP = X>
  SHOW_AP = false
end

#===============================================================================
# ■ XAS SYSTEN SETTING
#===============================================================================
module XAS_SYSTEM
  # Ativar a exibição de dano (Sprite). 
  DAMAGE_POP = true
  # Definição do mapa que ficarão os eventos das ferramentas.
  ACTION_TEMPLATE_MAP_ID = 1
  # Definição da ID da variável que corresponde a ID da ferramenta,
  # Essa ID serve para criar eventos interativos com as ferramentas.
  HIT_ID = 10
end

#===============================================================================
# ■ WORD SETTING
#===============================================================================
# Definição das palavras usadas no XAS
#-------------------------------------------------------------------------------
module XAS_WORD
  # Palavra usada quando o battler usa o sistema de defesa.
  GUARD = "Guard"
  # Palavra usada quando não tem MP o suficiênte para usar a habilidade.
  NO_MP = "No MP"
  # Palavra usada quando não tem item para ativar a habilidade.
  NO_ITEM = "No Item"  
  # Palavra usada quando o personagem aumenta de nível.
  LEVEL_UP = "Level Up"
  # Palavra usada para definir experiência.
  EXP = "Exp"
  # Palavra usada quando o alvo se esquiva do ataque.
  EVADED = "Evaded!"
  # Palavra usada quando o battler erra o ataque.
  MISSED = "Missed!"
end

#===============================================================================
# ■ XAS DAMAGE POP
#===============================================================================
# Definição do sistema de sprites de dano.
#-------------------------------------------------------------------------------
module XAS_DAMAGE_POP
  # Defnição da fonte.
  DAMAGE_FONT_NAME = "Georgia"
  # Definição do tamanho da fonte.
  DAMAGE_FONT_SIZE = 22
  # Ativar a fonte em bold.
  DAMAGE_FONT_BOLD = true
  # Ativar a fonte em itálico.
  DAMAGE_FONT_ITALIC = true
  # Ativar o Zoom no dano quando é dano crítico.
  DAMAGE_CRITICAL_ZOOM = true
  # Apresentar a quantidade de experiência e dinheiro.
  DAMAGE_EXP_GOLD_POP = false  
  # Apresentar o nome da condição(States).
  DAMAGE_STATE_POP = true
  # Apresentar o nome do item ao pegar no campo de batalha.
  DAMAGE_ITEM_POP = true
  # Definição da cor padrão da fonte.
  DAMAGE_DEFAULT_FONT_COLOR = Color.new(255, 255, 255)
  # Definição da cor da experiência.
  DAMAGE_EXP_FONT_COLOR = Color.new(0, 255, 100)
  # Definição da cor do dinheiro (Gold).
  DAMAGE_GOLD_FONT_COLOR = Color.new(255, 255, 50)
  # Definição da cor do item.
  DAMAGE_ITEM_FONT_COLOR = Color.new(55, 55, 250)
end

#===============================================================================
# ■ SOUND SETTING
#===============================================================================
# Definição do sistema de sons do XAS.
#-------------------------------------------------------------------------------
module XAS_SOUND
  #Som executado ao pegar o item.  
  ITEM_DROP = "Key" 
  #Som executado quando não tem item ou mp o suficiente.
  ACTION_COST = "Cursor1"
  #Som ao aprender uma habilidade.
  LEARNED_SE = "Item1"
end

#===============================================================================
# ■ ANIMATION SETTING
#===============================================================================
# Definição do sistema de animações do XAS.
# Caso não quiser usar as animações, defina o valor como 0 (Zero).
#-------------------------------------------------------------------------------
module XAS_ANIMATION
  # Animação quando o sistema de defesa é ativado.
  GUARD_ANIMATION_ID = 127
  # Animação ao fazer Level UP
  LEVEL_UP_ANIMATION_ID = 128
end

#===============================================================================
# ■ GENERAL BATTLER SETTING
#===============================================================================
# Definição geral do sistema de batalha do XAS.
#-------------------------------------------------------------------------------
module XAS_BA
  # Ativar sprite tremendo quando o battler está em recuo.
  KNOCKBACKING_SHAKE = true
  # Definição do tempo para remover o tesouro do mapa.
  TREASURE_ERASE_TIME = 5
  # Fixar a posição do balão independente da altura real do sprite.
  FIX_BALLOON_POSITION = true
  # Altura que o balão será fixado.
  BALLOON_HEIGHT = 32
end  

#===============================================================================
# ■ ENEMY SETTING
#===============================================================================

module XAS_BA_ENEMY
  # Definição de quais habilidades o inimigo será invunerável.
  #
  # INVUNERABLE_ACTIONS = { A=>[B,B,B,B],  A=>[B,B,B,B], ...}
  # A - ID do inimigo.
  # B - ID da habilidade.
  INVUNERABLE_ACTIONS = {
  6=>[1,2,3,4,29,30,31,33,34,59,64,65]

  }
  
end
#===============================================================================
# ■ HOOKSHOT 
#===============================================================================
#===============================================================================
# Para ativar a função do Hookshot na habilidade coloque o comando abaixo na
# caixa de notas de habilidades.
#
# <Hookshot = X>
#
# X - Area de alcance do hookshot.
#
#===============================================================================
# Para definir o evento do hookshot, nomeie o evento com o seguinte nome.
#
# <Hookshot>
#
#===============================================================================
module MOG_XAS_HOOKSHOT
  #Posição da corrente em relação ao personagem.
  HOOKSHOT_SPRITE_POSITION = [0,0]
  #Altura　do Character. 
  # 32 pixel = padrão do Rpg Maker VX.
  # 42 pixel = padrão do Rpg Maker XP.
  CHARACTER_HEIGHT = 42
end  
#===============================================================================
# ■ COOPERATION SKILL
#===============================================================================
module SCHALA_COOPERATION_SKILL   
  
  COOPERATION_SKILL_ID = []
  # COOPERATION_SKILL_ID[SKILL_ID] = [ACTOR_ID1, ACTOR_ID2 , ACTOR_ID3]
  
  # Holy
  COOPERATION_SKILL_ID[23] = [2,3]  
  # Meteor
  COOPERATION_SKILL_ID[35] = [1,2,3]
  # Ice Sword
  COOPERATION_SKILL_ID[60] = [1,2]
  # Falcon Hit
  COOPERATION_SKILL_ID[61] = [1,3]
  # X Strike
  COOPERATION_SKILL_ID[62] = [1,2]
  # Delta Force
  COOPERATION_SKILL_ID[63] = [1,2,3]
  # Bone Crush
  COOPERATION_SKILL_ID[64] = [1,3]
  # Gaia Break
  COOPERATION_SKILL_ID[66] = [1,2,3]
  # Nyanko Sensei (にゃんこ先生)
  COOPERATION_SKILL_ID[67] = [2,3]  

end

#===============================================================================
# ■ Game_Temp
#===============================================================================
class Game_Temp
  
  attr_accessor :reset_battler_time
  attr_accessor :tool_event
  attr_accessor :animation_garbage
  attr_accessor :battle_phase
  attr_accessor :battle_command
  attr_accessor :battle_target
  attr_accessor :battle_target_index
  attr_accessor :target_enemies
  attr_accessor :target_actors
  attr_accessor :target_select
  attr_accessor :actor_index
  attr_accessor :in_turn
  attr_accessor :in_turn_index 
  attr_accessor :command_wait
  attr_accessor :command_selection
  attr_accessor :command_index
  attr_accessor :command_phase
  attr_accessor :action_selected
  attr_accessor :initial_direction 
  attr_accessor :at_wait_phase
  attr_accessor :help_text
  attr_accessor :action_phase
  attr_accessor :target_phase
  attr_accessor :target_turn
  attr_accessor :result_duration
  attr_accessor :jump_priority
  attr_accessor :turn_sprite_phase
  attr_accessor :game_over_phase_duration
  attr_accessor :skill_name
  attr_accessor :com_slide_type
  attr_accessor :pre_battle_phase
  attr_accessor :recreate_schala_hud
  attr_accessor :battle_slow_motion
  attr_accessor :force_refresh_skill_window
  attr_accessor :force_reset_jump_count
  attr_accessor :allies_position
  attr_accessor :phase_action
  attr_accessor :one_sec_lag
  attr_accessor :refresh_target_name
  attr_accessor :forced_battle
  attr_accessor :force_reset_all
  attr_accessor :force_reset_turn
  attr_accessor :action_lag_time
  attr_accessor :jump_count_slow
  attr_accessor :cooperation_skill_members
  attr_accessor :temp_tech_window
  attr_accessor :wait_active_command
  attr_accessor :turn_break_time
  attr_accessor :hud_position
  attr_accessor :event_wait_movement
  attr_accessor :action_duration
  attr_accessor :initial_lag
  attr_accessor :on_target_size
  attr_accessor :force_enemy_fade
  attr_accessor :parallax_visible
  attr_accessor :tilemap_visible
  attr_accessor :pre_parallax_name
  attr_accessor :pre_tone
  attr_accessor :turn_duration
  attr_accessor :result_phase
  attr_accessor :result_exp_gold_ap
  attr_accessor :result_window
  attr_accessor :result_actors
  attr_accessor :refresh_hud
  attr_accessor :tool_on_map
  attr_accessor :force_wait
  attr_accessor :hookshot 
  attr_accessor :hookshot_tool_id  
  attr_accessor :hookshot_phase
  attr_accessor :hookshot_position
  attr_accessor :pre_members_index
  attr_accessor :save_temp_security_code
  attr_accessor :tool_slide_side
  attr_accessor :global_sensor_active
  attr_accessor :global_at_active
  attr_accessor :global_active_system
  attr_accessor :global_actor_command
  attr_accessor :global_action_move
  attr_accessor :recheck_battle_end
  attr_accessor :exp_phase
  attr_accessor :pre_bgm
  attr_accessor :check_death_opacity
  attr_accessor :update_result
  attr_accessor :actor_level_index
  attr_accessor :actor_level_show
  attr_accessor :actor_learned_skills_index
  attr_accessor :actor_learned_skills
  attr_accessor :result_stage
  attr_accessor :sprite_battle_start
  attr_accessor :sprite_battle_end
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------   
  alias xas_initialize initialize 
  def initialize
      @reset_battler_time = 0
      @tool_event = nil
      @animation_garbage = []
      @battle_phase = [false,false,0]
      @battle_command = [false,nil,0]
      @battle_target = nil
      @target_enemies = []
      @target_select = []
      @target_actors = []
      @battle_target_index = 0
      @actor_index = 0
      @in_turn_index = nil
      @in_turn = nil
      @command_wait = 0
      @command_selection = false
      @command_index = 0
      @command_phase = 0
      @action_selected = [0,0]
      @initial_direction = 0
      @at_wait_phase = false
      @help_text = [false,""]
      @action_phase = [false,0,0,0,true]
      @target_phase = nil
      @target_turn = nil
      @result_duration = 0      
      @jump_priority = [false,0]
      @turn_sprite_phase = -1
      @game_over_phase_duration = 0
      @skill_name = [false,"",0]
      @com_slide_type = [0,false]
      @pre_battle_phase = 0
      @recreate_schala_hud = false
      @battle_slow_motion = [0,0]
      @force_refresh_skill_window = 0
      @force_reset_jump_count = 0
      @allies_position = [[],[],[],[]]    
      @phase_action = false
      @one_sec_lag = 0
      @refresh_target_name = false
      @forced_battle = false
      @force_reset_all = [false,0]
      @force_reset_turn = [false,0]
      @action_lag_time = 0
      @jump_count_slow = 0
      @cooperation_skill_members = []
      @temp_tech_window = [false,[]]
      @wait_active_command = 0
      @turn_break_time = 0
      @hud_position = [false,1]
      @event_wait_movement = 0
      @action_duration = 0
      @initial_lag = 0
      @on_target_size = 0
      @force_enemy_fade = false
      @parallax_visible = true
      @tilemap_visible = true
      @pre_parallax_name = ["",0,0,0,0,false]
      @pre_tone = nil
      @turn_duration = [0,1]
      @result_phase = [false, 0]
      @result_exp_gold_ap = [0,0,0]
      @result_window = [false,false]
      @result_actors = [[],0,false,[],-1]
      @refresh_hud = false
      @tool_on_map = []
      @force_wait = 0
      @hookshot = false
      @hookshot_tool_id = 0      
      @hookshot_phase = 0
      @hookshot_position = [0,0]
      @pre_members_index = []
      @save_temp_security_code = 0
      @tool_slide_side = 0
      @global_sensor_active = [false,false]
      @global_at_active = [false,false]
      @global_active_system = [false,false]
      @global_actor_command = [false,false]
      @global_action_move = [false,false]
      @recheck_battle_end = false
      @update_test = nil
      @exp_phase = [true,0]
      @pre_bgm = ["", 100, 100, 0,true]
      @check_death_opacity = false
      @update_result = false
      @actor_level_index = 0
      @actor_level_show = [false,false]
      @actor_learned_skills_index = 0
      @actor_learned_skills = []
      @result_stage = ""
      @sprite_battle_start = false
      @sprite_battle_end = false
      xas_initialize
  end
  
  #--------------------------------------------------------------------------
  # ● Check Update
  #--------------------------------------------------------------------------        
  def updating?(value = "Updated", refresh_speed = 10)
      refresh_speed = 2 if refresh_speed < 2
      @update_test = 0 if @update_test == nil
      @update_test += 1 
      if @update_test >= refresh_speed
         @update_test = 0
         msgbox(value.to_s)
      end  
  end  
  
  #--------------------------------------------------------------------------
  # ● Replay Pre Bgm
  #--------------------------------------------------------------------------          
  def replay_pre_bgm
      Audio.bgm_play(@pre_bgm[0],@pre_bgm[1],@pre_bgm[2],@pre_bgm[3]) rescue nil
  end
  
end

#===============================================================================
# ■ Game_System
#===============================================================================
class Game_System
  
  attr_accessor :old_interpreter_running
  attr_accessor :hud_visible
  attr_accessor :enable_hud
  attr_accessor :command_enable
  attr_accessor :pre_leader_id
  attr_accessor :pre_set_events
  attr_accessor :escape_phase
  attr_accessor :abs_mode
  attr_accessor :abs_tool_command
  attr_accessor :abs_damage_enemies
  attr_accessor :time_recover
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------   
  alias x_initialize initialize
  def initialize
      @old_interpreter_running = false
      @enable_hud = false
      @hud_visible = SCHALA_BASE_SPRITES::HUD_INITIAL_VISIBLE
      @command_enable  = true
      @pre_leader_id = 0
      @pre_set_events = []
      @escape_phase = [true,0,SCHALA_SYSTEM::ESCAPE_DURATION]
      @abs_mode = true
      @abs_damage_enemies = SCHALA_SYSTEM::DAMAGE_ENEMIES_OUT_BATTLE
      @abs_tool_command = true
      @time_recover = [false,false]
      x_initialize
  end  
    
  #--------------------------------------------------------------------------
  # ● Record Events
  #--------------------------------------------------------------------------     
  def record_events
      @pre_set_events[$game_map.map_id]  = []
      for event in $game_map.events.values
          @pre_set_events[$game_map.map_id].push(event)
      end
  end
    
  #--------------------------------------------------------------------------
  # ● Restore_events
  #--------------------------------------------------------------------------       
  def restore_events(transfer = false)
      return if $game_system.pre_set_events[$game_map.map_id] == nil
      index = 0
      for event in $game_map.events.values
          time = $game_system.pre_set_events[$game_map.map_id][index].defeated[1] rescue nil
          if time == nil
             for ev2 in $game_map.events.values
                 ev2.defeated[0] = false
                 ev2.defeated[1] = 0               
             end
             break
          end
          respawn = $game_system.playtime - time
           if respawn >= SCHALA_SYSTEM::ENEMY_RESPAWN_TIME_FOR_TRANSFER
             if transfer
                event.defeated[0] = false
                event.defeated[1] = 0
             end
           else  
             event.defeated[0] = $game_system.pre_set_events[$game_map.map_id][index].defeated[0]
             event.defeated[1] = $game_system.pre_set_events[$game_map.map_id][index].defeated[1]
             event.erase if event.defeated[0]
          end    
          index += 1
      end  
  end
  
end  

#===============================================================================
# ■ Game Player
#===============================================================================
class Game_Player < Game_Character
  
  attr_accessor :vehicle_getting_on 
  
  #--------------------------------------------------------------------------
  # ● Reserve Transfer
  #--------------------------------------------------------------------------       
  alias mog_schala_record_events_reserve_transfer reserve_transfer
  def reserve_transfer(map_id, x, y, d = 2)
      mog_schala_record_events_reserve_transfer(map_id, x, y, d)
      $game_system.record_events
  end
  
end

#===============================================================================
# ■ Spriteset Map
#===============================================================================
class Spriteset_Map
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------
  alias mog_schala_record_event_initialize initialize
  def initialize
      $game_system.restore_events(false)
      $game_party.refresh_leader
      mog_schala_record_event_initialize
  end
  
end
  
#===============================================================================
# ■ Game Map
#===============================================================================
class Game_Map  
  
  attr_accessor :parallax_name
  attr_accessor :parallax_loop_x
  attr_accessor :parallax_loop_y
  attr_accessor :parallax_sx
  attr_accessor :parallax_sy      
      
  #--------------------------------------------------------------------------
  # ● Reserve Transfer
  #--------------------------------------------------------------------------       
  alias mog_schala_record_event_setup setup
  def setup(map_id)
      $game_system.schala_reset
      $game_temp.tool_on_map.clear
      $game_system.time_recover[1] = true if $game_system.time_recover[0]
      mog_schala_record_event_setup(map_id)      
      $game_system.restore_events(true)
  end
  
  #--------------------------------------------------------------------------
  # ● Change Parallax
  #--------------------------------------------------------------------------         
  alias mog_schala_change_parallax change_parallax
  def change_parallax(name, loop_x, loop_y, sx, sy)
      record_parallax
      mog_schala_change_parallax(name, loop_x, loop_y, sx, sy)
  end
  
  #--------------------------------------------------------------------------
  # ● Record Parallax
  #--------------------------------------------------------------------------              
  def record_parallax
      return if $game_temp.pre_parallax_name[5]
      $game_temp.pre_parallax_name[0] = $game_map.parallax_name
      $game_temp.pre_parallax_name[1] = $game_map.parallax_loop_x
      $game_temp.pre_parallax_name[2] = $game_map.parallax_loop_y
      $game_temp.pre_parallax_name[3] = $game_map.parallax_sx
      $game_temp.pre_parallax_name[4] = $game_map.parallax_sy
      $game_temp.pre_parallax_name[5] = true
  end  
  
end

#===============================================================================
# ■ Game_Battler
#===============================================================================
class Game_Battler
  
  attr_accessor :damage_pop
  attr_accessor :damage
  attr_accessor :damage_type
  attr_accessor :critical
  attr_accessor :invunerable_duration
  attr_accessor :shield
  attr_accessor :invunerable_actions
  attr_accessor :guard
  attr_accessor :invunerable
  attr_accessor :defeated
  attr_accessor :death_zoom_effect
  attr_accessor :knockback_duration 
  attr_accessor :hp_damage
  attr_accessor :mp_damage
  attr_accessor :at
  attr_accessor :turn
  attr_accessor :guard_effect
  attr_accessor :cast_effect
  attr_accessor :ap 
  attr_accessor :paralyze
  attr_accessor :invunerable 
  attr_accessor :move_times
  
 #--------------------------------------------------------------------------
 # ● Initialize
 #--------------------------------------------------------------------------  
  alias x_initialize initialize 
  def initialize
      @damage = 0
      @damage_pop = false
      @damage_type = 0
      @critical = false
      @invunerable_duration = 0
      @shield = false
      @invunerable_actions = []
      @guard = true
      @defeated = false
      @death_zoom_effect = 0
      @knockback_duration = 60
      @at = 0
      @turn = false
      @guard_effect = false
      @cast_effect = [0,0]
      @ap = 0
      @paralyze = true
      @invunerable = false
      @move_times = 0
      x_initialize
  end
  
  #--------------------------------------------------------------------------
  # ● Avaliable for skill
  #--------------------------------------------------------------------------               
  def avaliable_for_skill?(skill)
      return false if self.dead?
      return false if self.restriction >= 4
      return false if self.at < $game_system.at_max
      return false if self.mp < skill.mp_cost
      return false if self.tp < skill.tp_cost      
      return true
  end    
  
  #--------------------------------------------------------------------------
  # ● Setup Features
  #--------------------------------------------------------------------------                 
  def setup_features(target)
      for feature in target.features
          @move_times += feature.value.truncate if feature.code == 61
      end
      @move_times += 1 if @move_times > 0
  end
  
end  

#===============================================================================
# ■ Game Actor
#===============================================================================
class Game_Actor < Game_Battler
  
  attr_accessor :old_level
  attr_accessor :face_shake
  attr_accessor :face_phase
  attr_accessor :tool_id
  attr_accessor :opacity
  attr_reader :actor_id

 #--------------------------------------------------------------------------
 # ● Setup
 #--------------------------------------------------------------------------    
 alias x_setup setup
 def setup(actor_id)
     @old_level = @level
     @face_shake = 0
     @face_phase = [0,0,0]
     @tool_id = [[],0]
     @opacity = 0
     x_setup(actor_id)
 end 
 
 #--------------------------------------------------------------------------
 # ● Learn Tool
 #--------------------------------------------------------------------------     
 def learn_tool(action_id)
     if can_learn_tool?(action_id)
        @tool_id[0].push(action_id)
        @tool_id[1] = @tool_id[0].size - 1
     end   
     @tool_id[0].sort!
 end  
 
 #--------------------------------------------------------------------------
 # ● Forget Tool
 #--------------------------------------------------------------------------     
 def forget_tool(action_id)
     @tool_id[0].delete(action_id)
 end   
 
 #--------------------------------------------------------------------------
 # ● Can Learn Tool?
 #--------------------------------------------------------------------------      
 def can_learn_tool?(action_id)
     for i in 0...@tool_id[0].size
         if action_id == @tool_id[0][i]
            return false
            break
         end
     end  
     return true
 end
 
 #--------------------------------------------------------------------------
 # ● Display Level Up
 #--------------------------------------------------------------------------     
  alias x_display_level_up display_level_up
  def display_level_up(new_skills)
      return unless SceneManager.scene_is?(Scene_Battle)
      x_display_level_up(new_skills)
  end 
 
  #--------------------------------------------------------------------------
  # ● Return Normal Face
  #--------------------------------------------------------------------------              
  def return_normal_face
      if self.hp >= self.mhp * 25 / 100
         self.face_phase[0] = 0
      else
         self.face_phase[0] = 2
      end  
  end  
  
  #--------------------------------------------------------------------------
  # ● Gain AP
  #--------------------------------------------------------------------------  
  def gain_ap(value = 0)
      @ap += value
      check_ap_limit
  end
  
  #--------------------------------------------------------------------------
  # ● Lose AP
  #--------------------------------------------------------------------------  
  def lose_ap(value = 0)
      @ap -= value
      check_ap_limit
  end    
  
  #--------------------------------------------------------------------------
  # ● Check AP Limit
  #--------------------------------------------------------------------------    
  def check_ap_limit
      @ap = 0 if @ap < 0
      @ap = 9999999 if @ap > 9999999  
  end
    
end

#==============================================================================
# ■ Game Enemy
#==============================================================================
class Game_Enemy < Game_Battler
   
  attr_accessor :hide_hp
  attr_accessor :disable_respawn_time
  attr_accessor :abs_mode
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------
  alias schala_enemy_parameters_initialize initialize
  def initialize(index, enemy_id)
      schala_enemy_parameters_initialize(index, enemy_id)
      @hide_hp = enemy.note =~ /<Hide HP>/ ? true : false 
      @disable_respawn_time = enemy.note =~ /<Disable Respawn>/ ? true : false 
      if enemy.note =~ /<AP = (\d+)>/i
         @ap = $1.to_i  
     end     
     @paralyze = false if enemy.note =~ /<Disable Paralyze>/
     @abs_mode = enemy.note =~ /<Abs Mode>/ ? true : false 
     @invunerable = enemy.note =~ /<Invunerable>/ ? true : false
     setup_features(enemy) rescue nil
  end
    
end

#===============================================================================
# ■ Character 
#===============================================================================
class Game_Character < Game_CharacterBase
  
  attr_accessor :tool_id
  attr_accessor :tool_effect  
  attr_accessor :target
  attr_accessor :target2
  attr_accessor :old_x
  attr_accessor :old_y
  attr_accessor :pre_x
  attr_accessor :pre_y
  attr_accessor :angle
  attr_accessor :force_action_times
  attr_accessor :force_action
  attr_accessor :move_frequency
  attr_accessor :move_speed
  attr_accessor :direction_fix
  attr_accessor :walk_anime
  attr_accessor :step_anime
  attr_accessor :x
  attr_accessor :y
  attr_accessor :pattern
  attr_accessor :pattern_count  
  attr_accessor :jump_count
  attr_accessor :jump_peak
  attr_accessor :direction
  attr_accessor :through 
  attr_accessor :bush_depth  
  attr_accessor :blend_type 
  attr_accessor :priority_type  
  attr_accessor :jump_count 
  attr_accessor :zoom_x
  attr_accessor :zoom_y
  attr_accessor :stop
  attr_accessor :force_update
  attr_accessor :treasure_time 
  attr_accessor :treasure_float
  attr_accessor :can_update
  attr_accessor :knock_back_duration
  attr_accessor :orig_pos_x
  attr_accessor :orig_pos_y
  attr_accessor :shoot_time
  attr_accessor :face_direction
  attr_accessor :turn_index
  attr_accessor :active
  attr_accessor :target_2
  attr_accessor :action_movement
  attr_accessor :disabled
  attr_accessor :heal  
  attr_accessor :battler_movement
  attr_accessor :direction
  attr_accessor :pre_priority_type
  attr_accessor :can_collapse
  attr_accessor :pre_direction
  attr_accessor :pre_direction2
  attr_accessor :temp_position
  attr_accessor :force_direction
  attr_accessor :sprite_size
  attr_accessor :fade
  attr_accessor :round_knockback  
  attr_accessor :pre_move_speed
  attr_accessor :dash
  attr_accessor :defeated
  attr_accessor :timed_animation
  attr_accessor :hookshot
  attr_accessor :temp_id
  attr_accessor :jump_speed
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------    
  alias x_initialize initialize
  def initialize
      x_initialize
      @tool_id = 0
      @tool_effect = ""
      @target = false
      @target2 = nil
      @old_x = @x
      @old_y = @y
      @pre_x = @x
      @pre_y = @y   
      @orig_pos_x = @x
      @orig_pos_y = @y
      @angle = 0
      @force_action_times = 0
      @force_action = ""
      @zoom_x = 1.00
      @zoom_y = 1.00
      @stop = false
      @force_update = false
      @treasure_time = 0
      @treasure_float = [0,0,0,0]
      @can_update = true
      @shoot_time = [0,0]
      @face_direction = [0,0]
      @turn_index = 0
      @active = false
      @target_2 = nil
      @action_movement = [0,0,0,0,nil,0,1]
      @disabled = false
      @heal = false      
      @battler_movement = [0,0]
      @pre_priority_type = @priority_type
      @can_collapse = false
      @pre_direction = @direction
      @pre_direction2 = @direction
      @temp_position = [@x,@y,@direction,@priority_type]
      @force_direction = 0
      @sprite_size = [0,0,0,0,0,0,0,0]
      @fade = false
      @round_knockback = [false,0]
      @pre_move_speed = @move_speed
      @dash = false
      @defeated = [false,0]
      @timed_animation = [0,0]
      @hookshot = false
      @temp_id = 0
      @jump_speed = [false,0,2]
  end
  
  #--------------------------------------------------------------------------
  # ● Fast Breath
  #--------------------------------------------------------------------------        
  def fast_breath(enable = true)
     return if @battler == nil or @battler.dead?
     @battler.fast_breath_effect = enable
  end
   
  #--------------------------------------------------------------------------
  # ● Execute Item Popup
  #--------------------------------------------------------------------------           
  def erase_final
      return if !self.is_a?(Game_Event)
      @defeated[0] = true
      @defeated[1] = 9999999999 rescue nil
      self.erase
  end    
  
end

#===============================================================================
# ■ Game_Event 
#===============================================================================
class Game_Event < Game_Character
  attr_accessor :target
  attr_reader   :name  
  attr_accessor :first_target
  
 #--------------------------------------------------------------------------
 # ● Object
 #--------------------------------------------------------------------------      
 alias x_event_initialize initialize
 def initialize(map_id, event)
     x_event_initialize(map_id, event)  
     @first_target = false
     if @event.name =~ /<O(\d+)>/i
        @opacity = $1.to_i  
     end   
     if @event.name =~ /<B(\d+)>/i   
        @blend_type = $1.to_i 
     end  
     if event.name =~ /<Treasure (\d+) - (\d+)>/i
        @treasure = [$1.to_i,$2.to_i]
     end
end  
   
 #--------------------------------------------------------------------------
 # ● Event Name
 #--------------------------------------------------------------------------
  def name
      return @event.name  
  end   
  
end

#===============================================================================
# ■ Game Followers 
#===============================================================================
class Game_Followers
  
  attr_accessor :data
  
 #--------------------------------------------------------------------------
 # ● Initialize
 #--------------------------------------------------------------------------  
  alias x_party_initialize initialize
  def initialize(leader)
      x_party_initialize(leader)
      @visible = true
  end  
end  

#===============================================================================
# ■ Game Screen
#===============================================================================
class Game_Screen 

  #--------------------------------------------------------------------------
  # ● Start Tone Change
  #--------------------------------------------------------------------------         
  alias mog_schala_start_tone_change start_tone_change
  def start_tone_change(tone, duration)
      if $game_temp.pre_tone == nil
         $game_temp.pre_tone = [@tone.red,@tone.green,@tone.blue,@tone.gray]
      end
      mog_schala_start_tone_change(tone, duration)
  end
  
end

#===============================================================================
# ■ Scene_Refresh
#===============================================================================
class Scene_Refresh
  
  #--------------------------------------------------------------------------
  # ● main
  #--------------------------------------------------------------------------        
  def main
      $game_party.refresh_leader
      SceneManager.goto(Scene_Map)
  end
  
end

#===============================================================================
# ■ Cache
#===============================================================================
module Cache
  
  #--------------------------------------------------------------------------
  # ● Schala
  #--------------------------------------------------------------------------
  def self.schala(filename)
      load_bitmap("Graphics/schala/", filename)
  end
  
end

#===============================================================================
# ■ Audio
#===============================================================================
class << Audio
   
 #--------------------------------------------------------------------------
 # ● Bgm Play
 #--------------------------------------------------------------------------  
# alias pre_bgm_play bgm_play
# def bgm_play(filename, volume, pitch, pos)
#     record_schala_bgm(filename, volume, pitch, pos)
#     pre_bgm_play(filename, volume, pitch, pos)
# end
  
 #--------------------------------------------------------------------------
 # ● Record Bgm Play
 #--------------------------------------------------------------------------   
 def record_schala_bgm(filename, volume, pitch, pos)   
     return if $game_temp.battle_phase[0]
     return if !$game_temp.pre_bgm[4]
     $game_temp.pre_bgm = [filename, volume, pitch, pos,true]
 end
       
end

#==============================================================================
# ■ DataManager
#==============================================================================
module DataManager
  FILE_NAME_TEMP  = "Sr.rvdata2"
  
  #--------------------------------------------------------------------------
  # ● Save File Temp Exist
  #--------------------------------------------------------------------------  
  def self.save_file_temp_exists?
    !Dir.glob(FILE_NAME_TEMP).empty?
  end  
  
  #--------------------------------------------------------------------------
  # ● Save Game Temp
  #--------------------------------------------------------------------------
  def self.save_game_temp
      return if !$game_system.time_recover[0]
      pre_code = $game_temp.save_temp_security_code
      loop do
        $game_temp.save_temp_security_code = rand(99999) + 1
        break if pre_code != $game_temp.save_temp_security_code
      end
      File.open(FILE_NAME_TEMP, "wb") do |file|
      Marshal.dump(make_save_temp, file)
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Load Game Temp
  #--------------------------------------------------------------------------
  def self.load_game_temp
      return if !$game_system.time_recover[0]
      return if !save_file_temp_exists?
      pre_tool_id = $game_player.actor.tool_id[1] if $game_party.members.size > 0
      set_pre_members_index
      pre_code = $game_temp.save_temp_security_code
      File.open(FILE_NAME_TEMP, "rb") do |file|
        extract_save_temp(Marshal.load(file))
      end
      if pre_code != $game_temp.save_temp_security_code#invalid_save?
         execute_invalid_save
         return
      end
      execute_pre_members_index
      if $game_party.members.size > 0 and pre_tool_id != nil
         $game_player.actor.tool_id[1] = pre_tool_id
      end   
      SceneManager.goto(Scene_Refresh) 
  end
 
  #--------------------------------------------------------------------------
  # ● Check Invalid Save
  #--------------------------------------------------------------------------  
  def self.execute_invalid_save
      msgbox("Invalid Save!!!!") 
      exit
  end
  
  #--------------------------------------------------------------------------
  # ● Set Pre Members Index
  #--------------------------------------------------------------------------  
  def self.set_pre_members_index
      return if $game_party.members.size <= 1
      $game_temp.pre_members_index = []
      for actor in $game_party.members
          $game_temp.pre_members_index.push(actor.id)
      end    
  end
  
  #--------------------------------------------------------------------------
  # ● Execute Pre Members Index
  #--------------------------------------------------------------------------    
  def self.execute_pre_members_index
      return if $game_party.members.size <= 1
      return if $game_temp.pre_members_index == nil
      return if $game_temp.pre_members_index == []
      index = 0
      index2 = 0
      loop do
          if $game_temp.pre_members_index[index] != $game_party.members[index].id
             $game_party.swap_order(index, index + 1)
          end 
          index += 1
          index2 += 1
          index = 0 if index > ($game_party.max_battle_members - 2)
          break if index2 > 60
      end    
  end
  
  #--------------------------------------------------------------------------
  # ● Make Save Temp
  #--------------------------------------------------------------------------
  def self.make_save_temp
      contents = {}
      contents[:system_temp]        = $game_system
      contents[:timer_temp]         = $game_timer
      contents[:message_temp]       = $game_message
      contents[:switches_temp]      = $game_switches
      contents[:variables_temp]     = $game_variables
      contents[:self_switches_temp] = $game_self_switches
      contents[:actors_temp]        = $game_actors
      contents[:party_temp]         = $game_party
      contents[:troop_temp]         = $game_troop
      contents[:map_temp]           = $game_map
      contents[:player_temp]        = $game_player
      contents[:security_code]      = $game_temp.save_temp_security_code
      contents
  end
  
  #--------------------------------------------------------------------------
  # ● Extract Save Temp
  #--------------------------------------------------------------------------
  def self.extract_save_temp(contents)
      $game_system        = contents[:system_temp]
      $game_timer         = contents[:timer_temp]
      $game_message       = contents[:message_temp]
      $game_switches      = contents[:switches_temp]
      $game_variables     = contents[:variables_temp]
      $game_self_switches = contents[:self_switches_temp]
      $game_actors        = contents[:actors_temp]
      $game_party         = contents[:party_temp]
      $game_troop         = contents[:troop_temp]
      $game_map           = contents[:map_temp]
      $game_player        = contents[:player_temp]
      $game_temp.save_temp_security_code = contents[:security_code]
 end

end

#===============================================================================
# ■ Game Unit
#===============================================================================
class Game_Unit
  attr_accessor :in_battle  
end  

#===============================================================================
# ■ Schala_Battle 
#===============================================================================
module Schala_Battle
  include SCHALA_SYSTEM
  include SCHALA_FIELD
  
  #--------------------------------------------------------------------------
  # ● Battler Exist?
  #--------------------------------------------------------------------------         
  def battler_exist?(i)
      return false if i.battler == nil
   #   return false if i.battler.abs_mode
      return false if i.battler.dead?
      return false if i.erased
      return true
  end
  
 #--------------------------------------------------------------------------
 # ● Event On Screen
 #--------------------------------------------------------------------------
 def event_on_screen(event)
     event.target = false
     return if event.disabled
     return if event.defeated[0]
     return if event.battler == nil
     return if event.battler.abs_mode
     distance_x = (event.x - $game_player.cx).abs
     distance_y = (event.y - $game_player.cy).abs  
     if distance_x < BATTLE_FIELD_RANGE[0] and
        distance_y < BATTLE_FIELD_RANGE[1]
        event.target = true
        event.refresh       
     end
  end      
 
  #--------------------------------------------------------------------------
  # ● Set Party Direction
  #--------------------------------------------------------------------------                 
  def set_party_direction
      return if $game_temp.target_actors == nil
      for actor in $game_temp.target_actors
          actor.pre_direction = actor.direction
      end
  end      
  
  #--------------------------------------------------------------------------
  # ● Members Turn Toward Player
  #--------------------------------------------------------------------------       
  def members_turn_toward_player
      for ally in $game_player.allies
          ally.turn_toward_player
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Jump Around Player
  #--------------------------------------------------------------------------             
  def jump_around_player
      return if $game_temp.target_enemies == nil
      return if $game_temp.target_enemies.empty?
      for i in $game_temp.target_enemies
          range_x = (i.x - $game_player.x).abs
          range_y = (i.y - $game_player.y).abs
          if range_x > BATTLE_SENSOR_RANGE or range_y > BATTLE_SENSOR_RANGE
             i.jump_near_player
          else
             i.jump(0,0)   
          end    
     end   
  end  
 
  #--------------------------------------------------------------------------
  # ● Record Original Character Name
  #--------------------------------------------------------------------------           
  def restore_original_character_name
      $game_player.restore_name
      for i in $game_player.allies
          i.restore_name
      end    
  end     
  
  #--------------------------------------------------------------------------
  # ● Record Party Temp Position
  #--------------------------------------------------------------------------  
  def record_party_temp_position
      $game_player.record_position
      for follower in $game_player.followers
          follower.record_position
      end    
  end  
  
  #--------------------------------------------------------------------------
  # ● Self Event
  #--------------------------------------------------------------------------              
  def self_event
      if $game_map.interpreter.running? and @event_id != nil
         if $game_map.events[@event_id] != nil
            return $game_map.events[@event_id]
         else   
            return $game_player
         end  
      else       
         return $game_player
      end    
  end     
       
  #--------------------------------------------------------------------------
  # ● Remove Battler knockback
  #--------------------------------------------------------------------------               
  def remove_battler_knockback
      for i in $game_temp.target_enemies
          i.jump_count = 0
          i.heal = false      
          i.fade = false
          i.force_action_times = 0
          i.force_action = ""          
          if !i.battler.dead?
             i.battler.invunerable_duration = 0
             i.knock_back_duration = nil  
          end  
          i.set_base_pose 
      end
      for i in $game_temp.target_actors
          i.jump_count = 0 
          i.jump_peak = 0
          i.priority_type = 1
          i.heal = false
          i.through = false
          i.fade = false
          i.force_action_times = 0
          i.force_action = ""          
          if !i.battler.dead?
             i.battler.invunerable_duration = 0
             i.knock_back_duration = nil  
          end  
          i.set_base_pose 
      end          
  end
    
  #--------------------------------------------------------------------------
  # ● Restore Battler Position
  #--------------------------------------------------------------------------              
  def restore_battler_position
      wait = false
      for i in $game_temp.target_actors
          i.make_pose("",0) unless i.battler.dead? or i.battler.cast_effect[0] > 0
          i.update_battler_pose
          i.angle = 0
          i.fade = false
          i.rolling_effect(false)
          i.move_speed = 4
          if i.can_jump_org?
             i.restore_position
             wait = true
          end   
      end
      for i in $game_temp.target_enemies
          i.fade = false
          i.angle = 0
          i.priority_type = i.temp_position[3]
          i.rolling_effect(false)
          if i.can_jump_org? and !i.battler.dead?
             i.restore_position
             wait = true
          end          
      end      
      if wait and $game_temp.target_phase != nil
         $game_temp.target_phase.action_movement[3] = 60
      end
  end     
  
  #--------------------------------------------------------------------------
  # ● Jump_position
  #--------------------------------------------------------------------------        
  def jump_org(high = 10)
      self.char_pose("",0)
      self.jump_count = 0
      self.jump_peak = 0    
      nx = self.temp_position[0] - self.x
      ny = self.temp_position[1] - self.y
      nx = (real_cx - self.x) if self.x + nx < real_cx
      nx = (real_cx_max - self.x) if self.x + nx > real_cx_max
      ny = (real_cy - self.y) if self.y + ny < real_cy
      ny = (real_cy_max - self.y) if self.y + ny > real_cy_max      
      jump_high(nx,ny,high) if can_jump_org?
      self.set_direction(self.temp_position[2])
      self.priority_type = self.temp_position[3] if self.is_a?(Game_Event)
  end  
    
  #--------------------------------------------------------------------------
  # ● Can Jump Org
  #--------------------------------------------------------------------------          
  def can_jump_org?
      return false if self.x == self.temp_position[0] and self.y == self.temp_position[1]
      return true
  end  
  
  #--------------------------------------------------------------------------
  # ● Clear Force Direction
  #--------------------------------------------------------------------------            
  def clear_force_direction
      return if $game_temp.target_actors == nil
      return if $game_temp.target_actors == []
      for i in $game_temp.target_actors
          i.force_direction = 0
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Force Party Direction
  #--------------------------------------------------------------------------              
  def force_party_direction
      for i in $game_temp.target_actors
          i.set_direction(i.force_direction) if i.force_direction != 0
      end 
  end
  
  #--------------------------------------------------------------------------
  # ● Refresh Battler
  #--------------------------------------------------------------------------                
  def refresh_battlers
      $game_temp.target_enemies.clear
      for i in $game_map.events.values
          event_on_screen(i)
          if i.target and battler_exist?(i)
             i.orig_pos_x = i.x
             i.orig_pos_y = i.y
             i.set_original_name
             i.step_anime = true
             i.diagonal = true
             $game_temp.target_select[0] = i if $game_temp.target_select.empty?
             $game_temp.target_enemies.push(i)
          end
      end       
      $game_map.need_refresh = true
  end
  
  #--------------------------------------------------------------------------
  # ● Clear Slow Motion
  #--------------------------------------------------------------------------                
  def clear_slow_motion
      $game_temp.battle_slow_motion = [0,0]
      Graphics.frame_rate = 60
  end  
  
  #--------------------------------------------------------------------------
  # ● Clear Party Parameter
  #--------------------------------------------------------------------------             
  def clear_party_parameter
      return if $game_temp.target_actors == nil or $game_temp.target_actors == []
      clear_force_direction rescue nil      
      for i in $game_temp.target_actors    
          i.restore_name
          i.force_action_times = 0
          i.force_action = ""
          i.reset_battler_parameters rescue nil
      end
  end    
  
  #--------------------------------------------------------------------------
  # ● Active Hookshot
  #--------------------------------------------------------------------------                       
  def active_hookshot
      return if $game_temp.hookshot_phase > 0
      $game_temp.hookshot_phase = 1
  end    
  
  #--------------------------------------------------------------------------
  # ● Clear Jump Speed
  #--------------------------------------------------------------------------          
  def clear_jump_speed
      return if $game_temp.target_actors == nil
      return if $game_temp.target_actors == []
      for actor in $game_temp.target_actors
          actor.straighten
          actor.make_pose("",2)
          actor.jump_speed = [false,0,2]
      end  
  end  
  
  #--------------------------------------------------------------------------
  # ● Refresh Treasure On Map
  #--------------------------------------------------------------------------        
  def refresh_treasure_on_map
      for event in $game_map.events.values
          next if event.treasure == nil
          event.treasure_time -= 30
      end
  end  
  
end

#===============================================================================
# ■ Game_Interpreter
#===============================================================================
class Game_Interpreter
    include Schala_Battle 
end

#===============================================================================
# ■ Game_Character
#===============================================================================
class Game_Character < Game_CharacterBase
    include Schala_Battle 
end
  

#===============================================================================
# ■ Game_Player
#===============================================================================
class Game_Player < Game_Character
  
  #--------------------------------------------------------------------------
  # ● Perform Transfer
  #--------------------------------------------------------------------------         
  alias shala_battle_perform_transfer perform_transfer   
  def perform_transfer     
      battle_end_transfer
      shala_battle_perform_transfer
  end
end


#===============================================================================
# ■ Scene Map
#===============================================================================
class Scene_Map < Scene_Base
  
  #--------------------------------------------------------------------------
  # ● Update Encounter
  #--------------------------------------------------------------------------           
  alias schala_update_encounter update_encounter
  def update_encounter
      return if $game_temp.battle_phase[0]
      return if $game_temp.one_sec_lag > 0
      schala_update_encounter
  end
  
  #--------------------------------------------------------------------------
  # ● Update Scene
  #--------------------------------------------------------------------------           
   alias schala_update_call_menu update_call_menu
   def update_call_menu
       return if $game_temp.battle_phase[0]
       return if $game_temp.one_sec_lag > 0
       schala_update_call_menu
   end

  #--------------------------------------------------------------------------
  # ● Update Call Debug
  #--------------------------------------------------------------------------              
   alias schala_update_call_debug update_call_debug
   def update_call_debug
       return if $game_temp.battle_phase[0]
       return if $game_temp.one_sec_lag > 0     
       schala_update_call_debug
   end 
   
end 

#===============================================================================
# ■ Game Troop
#===============================================================================
class Game_Troop < Game_Unit
  
  attr_accessor :turn_count
  
  #--------------------------------------------------------------------------
  # ● Add Turn
  #--------------------------------------------------------------------------  
  def add_turn(value = 1)
      @turn_count += value
  end  
  
  #--------------------------------------------------------------------------
  # ● Reset Turn
  #--------------------------------------------------------------------------    
  def reset_turn
      @turn_count = 0
  end
  
end

#===============================================================================
# ■ Schala_Battle 
#===============================================================================
module Schala_Battle  
  
  #--------------------------------------------------------------------------
  # ● Update Sensor Global
  #--------------------------------------------------------------------------          
  def update_sensor_global
      return if $game_temp.global_sensor_active[1]
      $game_temp.global_sensor_active[1] = true
      $game_temp.global_sensor_active[0] = can_active_sensor_global?
  end      
  
  #--------------------------------------------------------------------------
  # ● Can Active Sensor Global
  #--------------------------------------------------------------------------          
  def can_active_sensor_global?
      return false if $game_map.interpreter.running?
      return false if $game_temp.battle_phase[0]
      return false if $game_player.transparent
      return false if $game_player.through
      return false if $game_player.vehicle_getting_on 
      return false if $game_temp.game_over_phase_duration > 0
      return false if $game_temp.hookshot_phase != 0
      return true   
  end     
  
  #--------------------------------------------------------------------------
  # ● Can Global AT Active
  #--------------------------------------------------------------------------      
  def can_global_at_active?
      return false if $game_temp.at_wait_phase
      return false if $game_temp.action_phase[0]
      return false if $game_temp.wait_active_command > 0
      return false if $game_temp.action_lag_time > 0 
      return false if $game_temp.turn_sprite_phase != 0  
      return true
  end  
  
  #--------------------------------------------------------------------------
  # ● Update Global Active
  #--------------------------------------------------------------------------          
  def update_global_active
      return if $game_temp.global_at_active[1]
      $game_temp.global_at_active[1] = true
      $game_temp.global_at_active[0] = can_global_at_active?
  end       

  #--------------------------------------------------------------------------
  # ● Can Update Active System?
  #--------------------------------------------------------------------------        
  def can_active_system_global?
      return false if $game_temp.pre_battle_phase > 0
      return false if $game_temp.battle_phase[1]      
      return false if $game_temp.battle_phase[2] > 0      
      return false if $game_temp.turn_sprite_phase == 2
      return true
  end    
      
  #--------------------------------------------------------------------------
  # ● Update Active System Global
  #--------------------------------------------------------------------------          
  def update_active_system_global
      return if $game_temp.global_active_system[1]
      $game_temp.global_active_system[1] = true
      $game_temp.global_active_system[0] = can_active_system_global?
  end  
  
  #--------------------------------------------------------------------------
  # ● Can Global Actor Command
  #--------------------------------------------------------------------------            
  def can_global_actor_command?
      return false if $game_temp.in_turn != nil
      return false if $game_temp.command_wait > 0
      return false if $game_temp.wait_active_command > 0
      return true
  end    
      
  #--------------------------------------------------------------------------
  # ● Update Global Actor Commmand
  #--------------------------------------------------------------------------              
  def update_global_actor_commmand
      return if $game_temp.global_actor_command[1]
      $game_temp.global_actor_command[1] = true
      $game_temp.global_actor_command[0] = can_global_actor_command?
  end  
  
  #--------------------------------------------------------------------------
  # ● Can Global Action Move
  #--------------------------------------------------------------------------            
  def can_global_action_move?
      return false if $game_temp.action_lag_time > 0      
      return false if $game_temp.turn_sprite_phase != 0
      if $game_temp.at_wait_phase
         return false if $game_temp.target_phase == nil
      end  
      return true 
  end
    
  #--------------------------------------------------------------------------
  # ● Update Global Action Move
  #--------------------------------------------------------------------------            
  def update_global_action_move
      return if $game_temp.global_action_move[1]
      $game_temp.global_action_move[1] = true
      $game_temp.global_action_move[0] = can_global_action_move?
  end  
  
end

#===============================================================================
# ■  Spriteset_Map
#===============================================================================
class Spriteset_Map
  
  #--------------------------------------------------------------------------
  # ● Reset Global Parameters
  #--------------------------------------------------------------------------            
  def reset_global_parameters
      $game_temp.global_sensor_active[1] = false
      $game_temp.global_at_active[1] = false
      $game_temp.global_active_system[1] = false
      $game_temp.global_actor_command[1] = false
      $game_temp.global_action_move[1] = false
  end  
    
end

#===============================================================================
# ■ Schala_Battle 
#===============================================================================
module Schala_Battle
  
  #--------------------------------------------------------------------------
  # ● Battle Start
  #--------------------------------------------------------------------------     
  def battle_start
      return if $game_party.members.size == 0
      BattleManager.save_bgm_and_bgs
      reset_parameters(false)
      reset_temp_parameters
      set_target_actors
      set_org_position
      $game_temp.battle_phase[0] = can_start_battle?
      $game_temp.hud_position[0] = $game_temp.battle_phase[0]
      $game_temp.battle_phase[1] = false
      $game_temp.battle_phase[2] = 0
      $game_map.need_refresh = true if $game_temp.battle_phase[0] 
  end
    
  #--------------------------------------------------------------------------
  # ● Set Target Actors
  #--------------------------------------------------------------------------       
  def set_target_actors
      $game_temp.target_actors.clear
      $game_temp.target_actors.push($game_player) 
      for i in 0...$game_player.allies.size
          $game_temp.target_actors.push($game_player.allies[i]) if $game_player.allies[i].visible? 
      end      
  end     
    
  #--------------------------------------------------------------------------
  # ● set_org_position
  #-------------------------------------------------------------------------- 
  def set_org_position
      for actor in $game_temp.target_actors
          actor.orig_pos_x = actor.x
          actor.orig_pos_y = actor.y
          actor.old_x = actor.x
          actor.old_y = actor.y          
      end  
  end   
      
  #--------------------------------------------------------------------------
  # ● Set Actor Initial Parameter
  #-------------------------------------------------------------------------- 
  def set_actor_initial_parameter
      for actor in $game_temp.target_actors
          actor.turn_toward_character($game_temp.target_select[0])
          actor..set_initial_at
          actor.battler.guard_effect = false
          actor.active = false
          battler.guard_effect = false
          actor.battler.return_normal_face     
          actor.force_initial_position(0)
          actor.pre_move_speed = 4
          actor.battler.guard_effect = false
          actor.step_anime = true
          unless actor.is_a?(Game_Player)
              set_initial_position(actor)
              actor.orig_pos_x = actor.x
              actor.orig_pos_y = actor.y
          end    
      end
      $game_temp.jump_priority = [true,40]
  end
  
  #--------------------------------------------------------------------------
  # ● Force Initial Position
  #--------------------------------------------------------------------------    
  def force_initial_position(id)
      return if $game_temp.allies_position[id] == nil
      return if $game_temp.allies_position[id] == []
      pre_x = $game_temp.allies_position[id][0]
      pre_y = $game_temp.allies_position[id][1]
      jump_position(self.x,self.y,pre_x,pre_y)
      self.orig_pos_x = self.x
      self.orig_pos_y = self.y      
      $game_temp.allies_position[id].clear
  end  
  
  #--------------------------------------------------------------------------
  # ● Set Org Position Enemies
  #--------------------------------------------------------------------------  
  def enable_diagonal(value)
      return if $game_temp.target_actors == nil
      for i in $game_temp.target_actors
          i.diagonal = value
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Set Org Position Enemies
  #--------------------------------------------------------------------------
  def set_org_position_enemies
  
  end
  
  #--------------------------------------------------------------------------
  # ● Step Animation
  #--------------------------------------------------------------------------         
  def step_animation(value)
      $game_player.step_anime = value
      for i in 0...$game_player.allies.size
           $game_player.allies[i].step_anime = value
      end
  end
      
  #--------------------------------------------------------------------------
  # ● Can Start Battle
  #--------------------------------------------------------------------------       
  def can_start_battle?            
      battle = false
      for i in $game_map.events.values
          event_on_screen(i)
          if i.target and battler_exist?(i)
             battle = true
             i.force_action_times = 0
             i.force_action = ""
             i.battler.invunerable_duration = 0
             i.knock_back_duration = nil           
             i.set_base_pose
             i.update_battler_pose
             i.orig_pos_x = i.x
             i.orig_pos_y = i.y
             i.set_original_name
             i.step_anime = true
             i.diagonal = true
             i.pre_move_speed = i.move_speed
             $game_temp.target_select[0] = i if $game_temp.target_select.empty?
             $game_temp.target_enemies.push(i)
          end
      end   
      if battle
         prepare_for_battle
         return true
      end
      return false
  end

  #--------------------------------------------------------------------------
  # ● Set Initial AR
  #--------------------------------------------------------------------------                   
  def set_initial_at_battlers
      return if $game_temp.target_actors == nil
      return if $game_temp.target_enemies == nil
      for i in $game_temp.target_actors
          next if i.dead?
          i.set_initial_at
      end
      for i in $game_temp.target_enemies
          next if i.dead?
          i.set_initial_at
      end     
  end
    
  #--------------------------------------------------------------------------
  # ● Set Initial AT
  #--------------------------------------------------------------------------               
  def set_initial_at
      rand_max = $game_system.at_max * 30 / 100
      rand_at = rand(rand_max + self.battler.agi)
      rand_at = $game_system.at_max - self.battler.agi if self.battler.at >= $game_system.at_max
      rand_at = 1 if rand_at < 1
      self.battler.at = rand(rand_at.abs)
  end
  
  #--------------------------------------------------------------------------
  # ● Prepare for Battle
  #--------------------------------------------------------------------------             
  def prepare_for_battle
      $game_temp.pre_bgm[4] = false
      $game_temp.sprite_battle_start = true
      revive_allies 
      clear_party_parameter
      check_fisrt_target      
      $game_temp.pre_battle_phase = 60#SLOW_INITIAL_JUMP_POSITION ? 80 : 60
      RPG::ME.stop
      RPG::BGM.fade(2000) if BATTLE_BGM
      $game_temp.turn_sprite_phase = 0
      $game_party.in_battle = true 
      $game_temp.recheck_battle_end = true
      fade_events(false,false)
      fade_party(false)
      remove_battler_knockback
      set_actor_initial_parameter
      set_org_position_enemies
      set_initial_at_battlers
      set_turn_duration
  end       
  
  #--------------------------------------------------------------------------
  # ● Check First Target
  #--------------------------------------------------------------------------               
  def check_fisrt_target
      return if $game_temp.target_enemies == nil
      $game_temp.battle_target_index = 0
      for i in $game_temp.target_enemies
          if i.first_target
             $game_temp.target_select[0] = i 
             break
          end   
          $game_temp.battle_target_index += 1          
     end      
  end    
  
  #--------------------------------------------------------------------------
  # ● Set Turn Duration
  #--------------------------------------------------------------------------               
  def set_turn_duration
      $game_temp.turn_duration[1] = AT_SPEED
  end  
    
end

#===============================================================================
# ■ Schala_Battle
#===============================================================================
module Schala_Battle  

  
  #--------------------------------------------------------------------------
  # ● set initial Position
  #--------------------------------------------------------------------------       
  def set_initial_position(i)
      i.through = false unless $game_player.debug_through?      
      i.direction = $game_player.direction
      i.move_backward   
      i.direction = $game_player.direction
      if $game_temp.allies_position[i.member_index] != nil and
         !$game_temp.allies_position[i.member_index].empty? and
         $game_temp.allies_position[i.member_index][0] != nil and
         $game_temp.allies_position[i.member_index][1] != nil
         pre_x = $game_temp.allies_position[i.member_index][0]
         pre_y = $game_temp.allies_position[i.member_index][1]
         i.jump_position(i.x,i.y,pre_x,pre_y)
         $game_temp.allies_position[i.member_index].clear
      else
          can_jump = false
          120.times do 
             i.move_random
             if position_usable?(i)
                can_jump = true
                break 
             end
          end
          pre_x = i.x
          pre_y = i.y
          i.moveto(i.old_x,i.old_y)
          i.move_speed = 1
          i.direction = $game_player.direction
          if can_jump
             i.priority_type = 2
             i.jump_speed = [true,0,2]             
             i.make_pose("_jump",40)
             if i.battler.dead?
                i.moveto(pre_x,pre_y)
             else   
                i.jump_position(i.x,i.y,pre_x,pre_y)
             end
          else   
             i.move_backward
          end  
      end
      i.turn_toward_character($game_temp.target_select[0])
      $game_temp.initial_direction = 40
      i.through = true if $game_player.debug_through?
  end
  
  #--------------------------------------------------------------------------
  # ● set initial Position
  #--------------------------------------------------------------------------         
  def position_usable?(user)
      return false if user.x == $game_player.x and user.x == $game_player.y
      range_x = (user.x - $game_player.x).abs
      range_y = (user.y - $game_player.y).abs  
      if (range_x + range_y) > 3
          user.x = $game_player.x
          user.y = $game_player.y
      end   
      if $game_player.allies.size > 1      
         if user == $game_player.allies[0]
            return false if user.x == $game_player.allies[1].x and user.y == $game_player.allies[1].y
         elsif user == $game_player.allies[1]  
            return false if user.x == $game_player.allies[0].x 
            return false if user.y == $game_player.allies[0].y
            return false if user.x == $game_player.allies[0].x  and user.y == $game_player.allies[0].y
         elsif $game_player.allies.size > 2 and user == $game_player.allies[2]  
            return false if user.x == $game_player.allies[0].x  and user.y == $game_player.allies[0].y
            return false if user.x == $game_player.allies[1].x  and user.y == $game_player.allies[1].y           
         end  
      end
      range_x = (user.x - $game_player.x).abs
      range_y = (user.y - $game_player.y).abs
      return true if (range_x + range_y).between?(2,3)
      return false
  end    
    
end

#===============================================================================
# ■ Schala_Battle 
#===============================================================================
module Schala_Battle    

  #--------------------------------------------------------------------------
  # ● Battle End
  #--------------------------------------------------------------------------     
  def battle_end
      $game_temp.forced_battle = false
      $game_temp.sprite_battle_end = true
      $game_temp.one_sec_lag = 2
      $game_temp.battle_phase[0] = false
      $game_temp.battle_phase[1] = false
      $game_temp.battle_phase[2] = 0
      $game_party.in_battle = false
      step_animation(false)
      reset_temp_parameters
      reset_parameters(true)
      members_turn_toward_player
      $game_temp.result_window[1] = true
      $game_temp.result_actors.clear
      $game_party.refresh_leader 
      clear_result_parameters
      BattleManager.replay_bgm_and_bgs
      return_to_original_position
  end 
    
  #--------------------------------------------------------------------------
  # ● Battle End Transfer
  #--------------------------------------------------------------------------      
  def battle_end_transfer
      return if $game_party.members.size == 0
      return if !$game_temp.battle_phase[0]
      $game_temp.battle_phase[0] = false
      $game_temp.battle_phase[1] = false
      clear_all_action($game_player)
      $game_player.jump_count = 0
      $game_player.jump_peak = 0  
      $game_player.battler.at = 0
      $game_player.battler.turn = false 
      $game_player.active = false
      if BATTLE_BGM             
         BattleManager.replay_bgm_and_bgs rescue nil
      #   $game_temp.recheck_battle_end = false
      end        
      for i in 0...$game_player.allies.size
          target = $game_player.allies[i]
          target.battler.at = 0
          target.battler.turn = false
          target.active = false
          clear_all_action(target)
          target.through = true
      end           
  end
  
  #--------------------------------------------------------------------------
  # ● Update Battle End
  #--------------------------------------------------------------------------      
  def check_battle_end
      if all_allies_dead?
         execute_game_over
      elsif all_enemies_dead?
         $game_temp.command_selection = false
         execute_victory
      end  
  end    
 
  #--------------------------------------------------------------------------
  # ● Execute Victory
  #--------------------------------------------------------------------------        
  def execute_victory
      $game_temp.turn_sprite_phase = 1
      $game_system.battle_end_me.play if PLAY_BATTLE_END_ME
      $game_temp.result_phase[1] = 40
      check_alive_members
      set_exp_gold_ap
  end
  
  #--------------------------------------------------------------------------
  # ● Set Exp Gold AP
  #--------------------------------------------------------------------------          
  def set_exp_gold_ap
      $game_temp.result_exp_gold_ap = [0,0,0]
      for enemy in $game_temp.target_enemies
          next if !enemy.battler.dead?
          $game_temp.result_exp_gold_ap[0] += enemy.battler.exp
          $game_temp.result_exp_gold_ap[1] += enemy.battler.gold
          $game_temp.result_exp_gold_ap[2] += enemy.battler.ap
      end
      set_double_exp_gold_ap
  end    
     
  #--------------------------------------------------------------------------
  # ● Set Double Exp Gold AP
  #--------------------------------------------------------------------------            
  def set_double_exp_gold_ap
      $game_temp.result_exp_gold_ap[0] *= 2 if double_exp?
      $game_temp.result_exp_gold_ap[1] *= 2 if double_gold?
      $game_temp.result_exp_gold_ap[2] *= 2 if double_ap?
  end
     
  #--------------------------------------------------------------------------
  # ● Double Exp?
  #--------------------------------------------------------------------------  
  def double_exp?
      return false
  end
  
  #--------------------------------------------------------------------------
  # ● Double Gold?
  #--------------------------------------------------------------------------  
  def double_gold?
      return true if $game_party.gold_double?
      return false
  end  
  
  #--------------------------------------------------------------------------
  # ● Double AP?
  #--------------------------------------------------------------------------    
  def double_ap?
      return false 
  end  
  
  #--------------------------------------------------------------------------
  # ● Check Alive Members
  #--------------------------------------------------------------------------            
  def check_alive_members
      $game_temp.result_actors = [[],0,false,[],-1]
      for i in $game_temp.target_actors
          $game_temp.result_actors[0].push(i) if !i.dead?
      end   
  end
      
  #--------------------------------------------------------------------------
  # ● Exeute GameOver
  #--------------------------------------------------------------------------        
  def execute_game_over
      $game_temp.turn_sprite_phase = 2
      $game_temp.game_over_phase_duration = 150
      RPG::BGM.fade(3000) if BATTLE_BGM
  end
    
  #--------------------------------------------------------------------------
  # ● Turn End
  #--------------------------------------------------------------------------            
  def turn_end(inter = false)
      return if $game_temp.target_phase == nil
      $game_temp.target_phase.action_movement[3] = 0
      if ($game_map.interpreter.running? and @event_id != nil) or inter
         $game_map.events[@event_id].erase rescue nil
      else   
         self.erase if self.tool_id > 0 rescue nil
      end   
      $game_temp.on_target_size = 0
      restore_field_parameter
      restore_battler_position
  end  
  
  #--------------------------------------------------------------------------
  # ● Restore Field Parameter
  #--------------------------------------------------------------------------  
  def restore_field_parameter
      clear_slow_motion
      clear_fade  
      restore_parallax
      restore_field_tone
  end
  
  #--------------------------------------------------------------------------
  # ● return to original Position
  #--------------------------------------------------------------------------             
  def return_to_original_position
      clear_all_tools
      revive_allies
      set_respawn_time
      restore_original_character_name
      $game_temp.jump_priority = [true,40]
      for i in $game_temp.target_actors
          i.turn_toward_player
          i.knock_back_duration = nil
          i.jump_speed = [true,0,2]
          i.make_pose("",0)
          i.battler.opacity = 255
          clear_all_action(i)          
          unless (i.x == i.old_x and i.y == i.old_y)
             if i.battler.dead?
                i.battler.opacity = 0
                i.moveto(i.old_x,i.old_y)
             else   
                i.jump_position(i.x,i.y,i.old_x,i.old_y) 
             end
             i.priority_type = 2
          end   
          i.through = true
      end          
      $game_player.through = false
      $game_temp.check_death_opacity = true
  end  
  
end

#===============================================================================
# ■ Schala_Battle
#===============================================================================
module Schala_Battle
 
  #--------------------------------------------------------------------------
  # ● Execute Result
  #--------------------------------------------------------------------------           
  def execute_result
      clear_party_parameter
      clear_party_action_end
      clear_result_parameters
      clear_all_states
      $game_troop.reset_turn
      $game_temp.battle_phase[1] = true 
      $game_temp.battle_phase[2] = 60
      $game_temp.update_result = true
      $game_temp.result_duration = 30
      refresh_treasure_on_map
      execute_result_exp_gold_ap
  end

  #--------------------------------------------------------------------------
  # ● Execute Result
  #--------------------------------------------------------------------------   
  def clear_result_parameters
      $game_temp.update_result = false
      $game_temp.result_stage = ""
      $game_temp.exp_phase = [false,0]
      $game_temp.actor_learned_skills_index = 0
      $game_temp.actor_learned_skills = [] 
      $game_temp.actor_level_index = 0
      $game_temp.actor_level_show = [false,false]    
  end
      
  #--------------------------------------------------------------------------
  # ● Execute Result Exp Gold AP
  #--------------------------------------------------------------------------              
  def execute_result_exp_gold_ap
      return if $game_temp.turn_sprite_phase != 1
      execute_victory_pose   
      $game_temp.exp_phase = [true,0]
      $game_temp.result_stage = "Exp"
      $game_party.gain_gold($game_temp.result_exp_gold_ap[1])
  end

  #--------------------------------------------------------------------------
  # ● Result Exp
  #--------------------------------------------------------------------------               
  def result
      level_old = self.battler.level
      self.battler.gain_exp($game_temp.result_exp_gold_ap[0])
      self.battler.gain_ap($game_temp.result_exp_gold_ap[2])
      self.execute_level_effect if self.battler.level > level_old
  end
  
  #--------------------------------------------------------------------------
  # ● Execute Level Effect
  #--------------------------------------------------------------------------             
  def execute_level_effect
      self.battler.damage = XAS_WORD::LEVEL_UP
      self.battler.damage_pop = true
      self.animation_id = XAS_ANIMATION::LEVEL_UP_ANIMATION_ID
  end
  
  #--------------------------------------------------------------------------
  # ● Execute_Active Switch
  #--------------------------------------------------------------------------           
  def execute_active_switch(enemy)        
      enemy.note  =~ /<Active Switch = (\d+)>/      
      switch_id = $1.to_i  
      if switch_id != nil
         $game_switches[switch_id] = true
         $game_map.need_refresh = true     
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Execute Defeated Animation
  #--------------------------------------------------------------------------             
  def execute_defeated_animation(enemy)
      enemy.note  =~ /<Death Animation = (\d+)>/      
      anime_id = $1.to_i      
      if anime_id != nil
         self.animation_id = anime_id
      end  
  end    
  
  #--------------------------------------------------------------------------
  # ● Execute Victory Pose
  #--------------------------------------------------------------------------            
  def execute_victory_pose
      for actor in $game_temp.target_actors
          next if actor.battler.dead?
          next if actor.battler.restriction >= 4
          actor.make_pose("_Vic",99999)
      end    
  end  
  
end

#===============================================================================
# ■ Game Actor
#===============================================================================
class Game_Actor < Game_Battler 
  
  #--------------------------------------------------------------------------
  # ● Learn Skill
  #--------------------------------------------------------------------------
  alias mog_schala_result_learn_skill learn_skill
  def learn_skill(skill_id)
      unless skill_learn?($data_skills[skill_id])
        $game_temp.actor_learned_skills.push($data_skills[skill_id])
        #$game_temp.result_stage = "Learned_Skills"
      end
      mog_schala_result_learn_skill(skill_id)
  end
  
end

#===============================================================================
# ■  Spriteset_Map
#===============================================================================
class Spriteset_Map
  
  #--------------------------------------------------------------------------
  # ● Update Battle End
  #--------------------------------------------------------------------------        
  def update_battle_end
      if $game_temp.turn_sprite_phase == 1
         update_result_window
      else
         update_escape_phase
      end  
  end  

  #--------------------------------------------------------------------------
  # ● Update result Window
  #--------------------------------------------------------------------------          
  def update_result_window
     if Input.trigger?(:C)
        Sound.play_cursor
        if $game_temp.result_stage == "Exp"
           update_show_exp
        elsif $game_temp.result_stage == "Learned_Skills"
           update_learned_skills
        elsif $game_temp.result_stage == "Gold"
           update_result_gold
        elsif $game_temp.result_stage == "AP"
           update_result_ap
        elsif $game_temp.result_stage == "Final"
           $game_temp.result_stage = "" 
        else 
           update_result_end
        end  
      end   
      update_result_end if $game_temp.result_stage == ""
  end
  
  #--------------------------------------------------------------------------
  # ● Update Learned Skills
  #--------------------------------------------------------------------------            
  def update_learned_skills
      $game_temp.actor_level_show = [true,true]
  end
  
  #--------------------------------------------------------------------------
  # ● Update Result AP
  #--------------------------------------------------------------------------              
  def update_result_ap
      $game_temp.exp_phase = [true,2]
      $game_temp.result_stage = "Final"
  end
  
  #--------------------------------------------------------------------------
  # ● Update Result Gold
  #--------------------------------------------------------------------------              
  def update_result_gold
      $game_temp.exp_phase = [true,1]
      if MOG_SCHALA_RESULT::SHOW_AP
         $game_temp.result_stage = "AP"
      else
         $game_temp.result_stage = "Final"
      end   
  end

  #--------------------------------------------------------------------------
  # ● Update Show Exp
  #--------------------------------------------------------------------------
  def update_show_exp
      if $game_temp.actor_level_index == $game_temp.target_actors.size
         $game_temp.result_stage = "Gold"
         update_result_gold
         return 
      end   
      loop do
        $game_temp.actor_learned_skills_index = 0
        $game_temp.actor_learned_skills = [] 
        $game_temp.actor_level_show = [false,false]
        actor = $game_temp.target_actors[$game_temp.actor_level_index] rescue nil
        if actor == nil
           $game_temp.result_stage = "Gold"
           update_result_gold
           break
        end
        level_old = actor.battler.level
        actor.result
        $game_temp.actor_level_index += 1
        if actor.battler.level != level_old
           $game_temp.actor_level_show[0] = true
           break
        end   
      end 
  end
  
  #--------------------------------------------------------------------------
  # ● Update Result End
  #--------------------------------------------------------------------------        
  def update_result_end
      return_to_original_position
      $game_temp.battle_phase[2] = 0
      for i in $game_player.allies
          return if i.jumping? or i.moving?
      end
      battle_end
  end    
  
  #--------------------------------------------------------------------------
  # ● Update Escape Phase
  #--------------------------------------------------------------------------        
  def update_escape_phase
      return_to_original_position if $game_temp.battle_phase[2] == 60
      $game_temp.battle_phase[2] = 0
      for i in $game_player.allies
          return if i.jumping? or i.moving?
      end
      battle_end
  end  
  
end

#===============================================================================
# ■ Schala_Battle 
#===============================================================================
module Schala_Battle
    

  #--------------------------------------------------------------------------
  # ● All Allies Dead?
  #--------------------------------------------------------------------------        
  def all_allies_dead?
      return false if $game_temp.target_actors.empty?
      all_dead = true
      for actor in $game_temp.target_actors
          all_dead = false if !actor.battler.dead?
      end
      return true if all_dead
      return false     
  end    
  
  #--------------------------------------------------------------------------
  # ● All Enemies Dead?
  #--------------------------------------------------------------------------        
  def all_enemies_dead?
      return false if $game_temp.target_enemies.empty?
      all_dead = true
      for enemy in $game_temp.target_enemies
          all_dead = false if !enemy.battler.dead?
      end      
      return true if all_dead
      return false
  end  
  
  #--------------------------------------------------------------------------
  # ● Dead in Turn
  #--------------------------------------------------------------------------                  
  def dead_in_turn(target)
      return if !target.battler.is_a?(Game_Actor)   
      return if !target.battler.dead?
      return if target != $game_temp.target_turn
      target.reset_battler_parameters
      target.battler.guard_effect = false
      target.battler.cast_effect = [0,1]  
      $game_temp.target_turn = nil
      $game_temp.in_turn = nil
      clear_all_action(target)
      $game_temp.command_selection = false
      clear_command_paramenters
      $game_system.escape_phase[1] = 0
      $game_temp.wait_active_command = 5
      $game_temp.target_phase = nil if $game_temp.target_phase == target
      check_dead_cop_during_cast_phase
  end    
  
  #--------------------------------------------------------------------------
  # ● Reset Dead Parameters
  #--------------------------------------------------------------------------                    
  def reset_dead_parameters(target)
      clear_all_action(target)
      target.reset_battler_parameters
      target.battler.guard_effect = false
      target.battler.cast_effect = [0,1]
      target.move_speed = 6 if target.is_a?(Game_Event)
      $game_temp.target_phase = nil if $game_temp.target_phase == target
      $game_temp.target_turn = nil if target == $game_temp.target_turn
      check_dead_cop_during_cast_phase
  end  
  
  #--------------------------------------------------------------------------
  # ● Set Respawn Time
  #--------------------------------------------------------------------------                
  def set_respawn_time
      return if $game_temp.target_enemies == nil      
      for event in $game_temp.target_enemies
          next if event.battler == nil
          next if !event.battler.dead?
          next if event.battler.disable_respawn_time
          if ENEMY_RESPAWN_EFFECT
             next if event.battler.disable_respawn_time
             event.defeated[0] = true  
             event.defeated[1] = $game_system.playtime
             event.defeated[1] = 9999999999 if event.battler.disable_respawn_time
          end
      end      
    end
    
  #--------------------------------------------------------------------------
  # ● Revive Allies
  #--------------------------------------------------------------------------             
  def revive_allies
      index = 0
      for actor in $game_party.members
          actor.opacity = 255 
          if actor.dead? 
             if REVIVE_PARTY_BATTLE_PHASE
                actor.hp = 1
             else   
                actor.opacity = 0
             end  
         end
         index += 1 
         break if index > ($game_party.max_battle_members - 1)
      end
      $game_temp.check_death_opacity = true
  end    
    
end

#===============================================================================
# ■ Game_System
#===============================================================================
class Game_System  

  #--------------------------------------------------------------------------
  # ● Schala Reset
  #--------------------------------------------------------------------------         
  def schala_reset
      $game_temp.battle_phase = [false,false,0]
      $game_temp.in_turn_index = nil
      $game_temp.target_enemies = []
      $game_temp.target_select = []
      $game_temp.target_actors = []
      $game_temp.actor_index = 0
      $game_temp.battle_target_index = 0
      $game_temp.in_turn = nil
      $game_temp.command_selection = false
      $game_temp.command_wait = 0
      $game_temp.command_index = 0
      $game_temp.command_phase = 0
      $game_temp.initial_direction = 0
      $game_temp.target_phase = nil
      $game_temp.action_phase = [false,0,0,0,true]
      $game_temp.target_turn = nil
      $game_temp.result_duration = 0
      $game_system.escape_phase[1] = 0
      $game_temp.game_over_phase_duration = 0
      $game_temp.skill_name = [false,"",0]
      $game_temp.phase_action = false            
      $game_temp.action_lag_time = 0
      $game_temp.force_reset_jump_count = 0
      $game_temp.cooperation_skill_members = []
      $game_temp.wait_active_command = 0
      $game_temp.temp_tech_window = [false,[],nil,false]
      $game_temp.event_wait_movement = 0
      $game_temp.action_duration = 0
      $game_temp.initial_lag = 0
      $game_temp.on_target_size = 0
      $game_temp.tilemap_visible = true
      $game_temp.parallax_visible = true
      $game_temp.pre_parallax_name[5] = false
      $game_temp.pre_tone = nil
      $game_temp.battle_slow_motion = [0,0]
      $game_temp.result_phase = [false, 0]
      $game_temp.result_exp_gold_ap = [0,0,0]
      $game_temp.result_window = [false,false]
      $game_temp.result_actors = [[],0,false,[],-1]
      $game_temp.refresh_hud = false
      $game_temp.tool_on_map.clear
      $game_temp.force_wait = 0
      $game_temp.hookshot_phase = 0
      $game_temp.hookshot_position = [0,0]
      $game_temp.hookshot = false
      $game_temp.hookshot_tool_id = 0
      $game_temp.pre_bgm[4] = true
      $game_temp.update_result = false
      $game_temp.update_result = false
      $game_temp.result_stage = ""
      $game_temp.exp_phase = [false,0]
      $game_temp.actor_learned_skills_index = 0
      $game_temp.actor_learned_skills = [] 
      $game_temp.actor_level_index = 0
      $game_temp.actor_level_show = [false,false]
      $game_temp.sprite_battle_end = false
      $game_temp.sprite_battle_start = false
      $game_temp.recheck_battle_end = false
      $game_player.force_reset_all
    end 
    
  end
  
#===============================================================================
# ■ Schala_Battle 
#===============================================================================
module Schala_Battle
  
  #--------------------------------------------------------------------------
  # ● Reset Temp Parameters
  #--------------------------------------------------------------------------       
  def reset_temp_parameters
      $game_player.refresh_allies
      $game_temp.in_turn_index = nil
      $game_temp.target_enemies = []
      $game_temp.target_select = []
      $game_temp.target_actors = []
      $game_temp.actor_index = 0
      $game_temp.battle_target_index = 0
      $game_temp.in_turn = nil
      $game_temp.command_selection = false
      $game_temp.command_wait = 0
      $game_temp.command_index = 0
      $game_temp.command_phase = 0
      $game_temp.initial_direction = 0
      $game_temp.target_phase = nil
      $game_temp.action_phase = [false,0,0,0,true]
      $game_temp.target_turn = nil
      $game_temp.result_duration = 0
      $game_system.escape_phase[1] = 0
      $game_temp.game_over_phase_duration = 0
      $game_temp.skill_name = [false,"",0]
      $game_temp.phase_action = false
      $game_temp.cooperation_skill_members = []
      $game_temp.temp_tech_window = [false,[],nil,false]
      $game_temp.wait_active_command = 0
      $game_temp.event_wait_movement = 0
      $game_temp.action_duration = 0
      $game_temp.initial_lag = 0
      $game_temp.on_target_size = 0
      $game_temp.tilemap_visible = true
      $game_temp.parallax_visible = true   
      $game_temp.pre_parallax_name[5] = false
      $game_temp.pre_tone = nil
      $game_temp.result_phase = [false, 0]
      $game_temp.result_exp_gold_ap = [0,0,0]
      $game_temp.result_window = [false,false]
      $game_temp.tool_on_map.clear
      $game_temp.force_wait = 0
      $game_temp.hookshot_phase = 0
      $game_temp.hookshot_position = [0,0]
      $game_temp.hookshot = false
      $game_temp.hookshot_tool_id = 0
      $game_temp.update_result = false
      clear_slow_motion
      record_party_temp_position
      clear_actor_heal_effect
      clear_all_tools
      clear_all_states
      $game_map.need_refresh = true
  end
  
  #--------------------------------------------------------------------------
  # ● Clear Command Parameters
  #--------------------------------------------------------------------------               
  def clear_command_paramenters
      $game_temp.command_phase = 0
      $game_temp.command_wait = 5
      $game_temp.command_selection = false      
      $game_temp.help_text = [true, ""]
      $game_temp.target_turn = nil
      $game_temp.in_turn = nil
  end  
  
  #--------------------------------------------------------------------------
  # ● Clear All States
  #--------------------------------------------------------------------------        
  def clear_all_states
      for actor in $game_party.members
          actor.state_string = ""
          actor.state_string_time = 0        
          for st in actor.states  
              actor.remove_state(st.id) if st.remove_at_battle_end
          end  
      end
  end

  #--------------------------------------------------------------------------
  # ● Set Org Position
  #--------------------------------------------------------------------------         
  def clear_all_tools
      for tool in $game_map.events.values
          tool.erase if tool.tool_id > 0
      end
  end
    
  #--------------------------------------------------------------------------
  # ● Clear All Actions Battlers
  #--------------------------------------------------------------------------                   
  def clear_all_actions_battlers
      for i in $game_temp.target_enemies
          i.rolling_effect(false)
          i.action_clear
          i.move_speed = i.pre_move_speed
      end  
      for i in $game_temp.target_actors
          i.rolling_effect(false)
          i.action_clear
          i.move_speed = i.pre_move_speed
      end    
  end
    
  #--------------------------------------------------------------------------
  # ● clear base actions
  #--------------------------------------------------------------------------        
  def clear_all_action(user)
      user.action_clear      
      user.action_movement[0] = 0
      user.action_movement[1] = 0
      user.action_movement[2] = 0
      user.action_movement[3] = 0
      user.action_movement[5] = 0
      user.action_movement[6] = 0
      user.battler.cast_effect = [0,1]
  end
    
  #--------------------------------------------------------------------------
  # ● clear all action end
  #--------------------------------------------------------------------------          
  def clear_party_action_end
      for i in $game_temp.target_actors
          i.action_movement = [0,0,0,0,nil,0,1]
          i.battler.cast_effect = [0,1]
      end      
  end  
  
  #--------------------------------------------------------------------------
  # ● Set Original Position
  #--------------------------------------------------------------------------       
  def reset_parameters(position)
      clear_all_action($game_player)
      $game_player.jump_count = 0
      $game_player.jump_peak = 0  
      $game_player.battler.at = 0
      $game_player.battler.tp = 0
      $game_player.battler.turn = false
      $game_player.active = false
      $game_player.set_base_pose  
      $game_player.update_battler_pose     
#      $game_temp.recheck_battle_end = false if position
      if position and BATTLE_BGM
        # RPG::BGM.stop rescue nil
         BattleManager.replay_bgm_and_bgs rescue nil
      end
      for i in 0...$game_player.allies.size
          target = $game_player.allies[i]
          target.battler.at = 0
          target.battler.tp = 0
          target.jump_count = 0
          target.jump_peak = 0
          target.battler.turn = false
          target.active = false
          clear_all_action(target)
          target.through = true if position  
          target.set_base_pose  
          target.update_battler_pose          
      end        

  end  
  
  #--------------------------------------------------------------------------
  # ● Clear Actor Heal Effect
  #--------------------------------------------------------------------------              
  def clear_actor_heal_effect
      $game_player.heal = false
      for i in $game_player.allies
          i.heal = false
      end  
  end  
  
  #--------------------------------------------------------------------------
  # ● Force Reset All
  #--------------------------------------------------------------------------                  
  def force_reset_all
      return if $game_party.members.size == 0
      $game_temp.battle_target_index = 0
      $game_temp.command_wait = 0
      $game_temp.command_index = 0
      $game_temp.command_phase = 0
      $game_temp.target_phase = nil
      $game_temp.action_phase = [false,0,0,0,true]
      $game_temp.target_turn = nil
      $game_temp.result_duration = 0
      $game_system.escape_phase[1] = 0
      $game_temp.pre_battle_phase = 0  
      $game_temp.target_phase = nil
      $game_temp.phase_action = false
      $game_temp.command_selection = false
      $game_temp.help_text = [true, ""]
      $game_temp.target_turn = nil
      $game_temp.in_turn = nil
      $game_temp.cooperation_skill_members = []
      $game_temp.wait_active_command = 0
      $game_temp.tilemap_visible = true
      $game_temp.parallax_visible = true     
      $game_temp.pre_parallax_name[5] = false
      clear_all_action(self)      
      for enemy in $game_temp.target_enemies
          enemy.reset_battler_parameters
      end  
      for actor in $game_temp.target_actors
          actor.reset_battler_parameters
      end
  end  
  
end

#===============================================================================
# ■ Game_Character
#===============================================================================
class Game_Event < Game_Character  
  
  #--------------------------------------------------------------------------
  # ● Start
  #--------------------------------------------------------------------------           
  alias schala_event_start start
  def start
      return if can_stop_interpreter?
      schala_event_start
  end
   
  #--------------------------------------------------------------------------
  # ● Can Stop Interpreter
  #--------------------------------------------------------------------------             
  def can_stop_interpreter?
      return false if self.tool_id > 0
      return true if $game_temp.battle_phase[0]
      return false
  end
  
end

#===============================================================================
# ■ Game Interpreter
#===============================================================================
class Game_Interpreter
  
  #--------------------------------------------------------------------------
  # ● Update
  #--------------------------------------------------------------------------          
  alias schala_wait_jump_update update
  def update
      return if stop_interpreter?
      schala_wait_jump_update
  end
  
  #--------------------------------------------------------------------------
  # ● Stop Interpreter
  #--------------------------------------------------------------------------        
  def stop_interpreter?
      return true if $game_temp.event_wait_movement > 0 
      return true if $game_temp.hookshot_phase != 0
      return false
  end     
  
  #--------------------------------------------------------------------------
  # ● Create Fiber
  #--------------------------------------------------------------------------    
  alias schala_interpreter_create_fiber create_fiber
  def create_fiber
      schala_interpreter_create_fiber
      execute_turn_duration_interpreter if @list
  end
  
  #--------------------------------------------------------------------------
  # ● Execute Turn Duration Interpreter
  #--------------------------------------------------------------------------  
  def execute_turn_duration_interpreter
      return if !$game_temp.battle_phase[0]
      return if $game_temp.target_phase == nil    
      $game_temp.target_phase.action_movement[3] = 99999      
      if $game_map.events[@event_id] != nil
         $game_map.events[@event_id].action.duration = 99999 rescue nil
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Execute Final
  #--------------------------------------------------------------------------    
  def erase_final
      return if $game_map.events[@event_id] == nil
      $game_map.events[@event_id].erase_final
  end  
  
  #--------------------------------------------------------------------------
  # ● Run
  #--------------------------------------------------------------------------
  alias schala_interpreter_run run
  def run
      schala_interpreter_run
      execute_turn_end_interpreter
  end

  #--------------------------------------------------------------------------
  # ● Execute Turn End Interpreter
  #--------------------------------------------------------------------------  
  def execute_turn_end_interpreter
      return if @fiber != nil
      return if !$game_temp.battle_phase[0]
      return if $game_temp.target_phase == nil
      turn_end(true)
  end  
  
  #--------------------------------------------------------------------------
  # ● Screen 
  #--------------------------------------------------------------------------
  def screen
      ($game_party.in_battle and !$game_temp.battle_phase[0]) ? $game_troop.screen : $game_map.screen
  end    
  
  #--------------------------------------------------------------------------
  # ● Allow Escape
  #--------------------------------------------------------------------------            
  def allow_escape(value)
      $game_system.escape_phase[0] = value
  end

  #--------------------------------------------------------------------------
  # ● Force character Position
  #--------------------------------------------------------------------------              
  def force_character_direction(id,direction)
      if id == 0
         $game_player.force_direction = direction
         return
      end
      id2 = id - 1
      $game_player.followers[id2].force_direction = direction    
  end
  
  #--------------------------------------------------------------------------
  # ● Force Actor Position
  #--------------------------------------------------------------------------          
  def force_character_position(id,x,y)
      $game_temp.allies_position[id] = [] if $game_temp.allies_position[id] == nil
      $game_temp.allies_position[id] = [x,y] rescue nil
  end  

  #--------------------------------------------------------------------------
  # ● Clear Actor Position
  #--------------------------------------------------------------------------        
  def clear_actor_position
      for i in 0...$game_party.max_battle_members
         $game_temp.allies_position[i].clear rescue nil
         $game_temp.allies_position[i] = [] if $game_temp.allies_position[i] == nil
      end
  end  
  
  #--------------------------------------------------------------------------
  # ● Force Battle
  #--------------------------------------------------------------------------          
  def force_battle
      $game_temp.forced_battle = true
      $game_player.force_battle
  end  
  
  #--------------------------------------------------------------------------
  # ● Force Battle
  #--------------------------------------------------------------------------            
  def restore_tone(time = 60,wait = false)
      return if $game_temp.pre_tone == nil
      t = $game_temp.pre_tone
      tone = Tone.new(t[0],t[1],t[2],t[3])
      screen.start_tone_change(tone, time)
      wait(time) if wait
      $game_temp.pre_tone = nil
  end  

  #--------------------------------------------------------------------------
  # ● Slow Motion
  #--------------------------------------------------------------------------              
  def slow_motion(time = 0,frame = 30)
      $game_temp.battle_slow_motion = [time,frame]
  end  
  
  #--------------------------------------------------------------------------
  # ● Cleat Slow Motion
  #--------------------------------------------------------------------------                
  def clear_slow_motion
      $game_temp.battle_slow_motion = [0,0]
      Graphics.frame_rate = 60
  end
  
  #--------------------------------------------------------------------------
  # ● Actor Learn Tool
  #--------------------------------------------------------------------------                  
  def actor_learn_tool(actor_id ,tool_id)
      actor_id += 1
      for i in $game_party.members
          i.learn_tool(tool_id) if i.actor_id == actor_id
      end
  end  
  
  #--------------------------------------------------------------------------
  # ● Actor Forget Tool
  #--------------------------------------------------------------------------                  
  def actor_forget_tool(actor_id ,tool_id)
      actor_id += 1
      for i in $game_party.members
          i.forget_tool(tool_id) if i.actor_id == actor_id
      end
  end    
  
  #--------------------------------------------------------------------------
  # ● Actor Learn Tool
  #--------------------------------------------------------------------------                  
  def actor_tool_index(actor_id ,tool_index = 0)
      actor_id += 1   
      for i in $game_party.members
          i.tool_id[1] = tool_index if i.actor_id == actor_id
      end
  end  
  
  #--------------------------------------------------------------------------
  # ● Tool Command
  #--------------------------------------------------------------------------                    
  def tool_command(value = true)
      $game_system.abs_tool_command = value
  end
  
  #--------------------------------------------------------------------------
  # ● Commmand 311
  #--------------------------------------------------------------------------                      
  alias schala_refresh_leader_command_311 command_311
  def command_311
      schala_refresh_leader_command_311
      if !$game_temp.battle_phase[0]
          $game_party.refresh_leader 
          $game_party.check_gameover
      end  
  end  
  
  #--------------------------------------------------------------------------
  # ● Commmand 313
  #--------------------------------------------------------------------------                      
  alias schala_refresh_leader_command_313 command_313
  def command_313
      schala_refresh_leader_command_313
      if !$game_temp.battle_phase[0]
          $game_party.refresh_leader 
          $game_party.check_gameover
      end  
  end  
  
  #--------------------------------------------------------------------------
  # ● Commmand 314
  #--------------------------------------------------------------------------                      
  alias schala_refresh_leader_command_314 command_314
  def command_314
      schala_refresh_leader_command_314
      if !$game_temp.battle_phase[0]
          $game_party.refresh_leader 
          $game_party.check_gameover
      end    
  end
  
  #--------------------------------------------------------------------------
  # ● Enable Time Recover
  #--------------------------------------------------------------------------                       
  def enable_time_recover
      $game_system.time_recover[0] = true
      DataManager.save_game_temp
  end  

  #--------------------------------------------------------------------------
  # ● Disable Time Recover
  #--------------------------------------------------------------------------                       
  def disable_time_recover
      $game_system.time_recover[0] = false
  end    
  
  #--------------------------------------------------------------------------
  # ● Time Recover
  #--------------------------------------------------------------------------                       
  def time_recover
      return if !$game_system.time_recover[0]
      DataManager.load_game_temp
  end
  
  #--------------------------------------------------------------------------
  # ● Disable Tool Command
  #--------------------------------------------------------------------------                         
  def disable_tool_command
      $game_system.abs_tool_command = false
  end
  
  #--------------------------------------------------------------------------
  # ● Disable Hud
  #--------------------------------------------------------------------------                           
  def disable_hud
      $game_system.hud_visible = false
  end
 
  #--------------------------------------------------------------------------
  # ● Enable Tool Command
  #--------------------------------------------------------------------------                         
  def enable_tool_command
      $game_system.abs_tool_command = true
  end    
  
  #--------------------------------------------------------------------------
  # ● Enable Hud
  #--------------------------------------------------------------------------                             
  def enable_hud
      $game_system.hud_visible = true
  end  
  
end

#===============================================================================
# ■ Schala_Battle 
#===============================================================================
module Schala_Battle

  #--------------------------------------------------------------------------
  # ● Member Cooperation
  #--------------------------------------------------------------------------    
  def self_member_cooperation?
      return false if self.is_a?(Game_Event)
      for actor in $game_temp.cooperation_skill_members
          return true if actor == self.battler
      end
      return false
  end  

  #--------------------------------------------------------------------------
  # ● Check Dead Cop During Cast Phase
  #--------------------------------------------------------------------------  
  def check_dead_cop_during_cast_phase
      for actor in $game_temp.cooperation_skill_members
          if actor == self.battler and self.battler.dead? 
             reset_cooperation_parameters(true)
             break
          end   
      end
  end    

  #--------------------------------------------------------------------------
  # ● Reset Cooperation Parameters
  #--------------------------------------------------------------------------
  def reset_cooperation_parameters(force = false)
      return if !self_member_cooperation? and !force
      for member in $game_temp.cooperation_skill_members
          for actor in $game_temp.target_actors
              if actor.battler.id == member.id
                 actor.reset_battler_parameters
                 actor.set_base_pose
              end
          end
      end
      $game_temp.cooperation_skill_members = []
  end

  #--------------------------------------------------------------------------
  # ● Reset Cooperation Pre Pose
  #--------------------------------------------------------------------------  
  def reset_cooperation_pre_pose
      self.make_pose("",0)
      return if !self_member_cooperation?
      for member in $game_temp.cooperation_skill_members
          for actor in $game_temp.target_actors
              next if actor.battler.dead?
              next if actor.battler.restriction >= 4
              actor.make_pose("",0) if actor.battler.id == member.id
          end
      end
  end  
  
  #--------------------------------------------------------------------------
  # ● Enough MP TP For Cooperation Members
  #--------------------------------------------------------------------------  
  def mp_tp_cost_for_cooperation_members(skill)
      return if skill == nil
      for member in $game_temp.cooperation_skill_members
          for actor in $game_temp.target_actors
              if actor.battler.id == member.id
                 actor.battler.at = 0
                 actor.battler.mp -= skill.mp_cost
                 actor.battler.tp -= skill.tp_cost
              end
          end
      end    
  end    
  
  #--------------------------------------------------------------------------
  # ● Enough MP TP For Cooperation Members
  #--------------------------------------------------------------------------  
  def enough_mp_tp_for_cooperation_members?(skill)
      return false if skill == nil
      for member in $game_temp.cooperation_skill_members
          for actor in $game_temp.target_actors
              if actor.battler.id == member.id
                 if actor.battler.mp < skill.mp_cost
                     return false 
                 end   
                 if actor.battler.tp < skill.tp_cost
                    return false 
                 end  
              end
          end
      end    
      return true
  end  
  
  #--------------------------------------------------------------------------
  # ● Cooperation Cast Members
  #--------------------------------------------------------------------------
  def cooperation_cast_members(cast_duration)
      for member in $game_temp.cooperation_skill_members
          for actor in $game_temp.target_actors
              if actor.battler.id == member.id
                 actor.set_cast_effect(cast_duration.abs)
                 actor.reset_battler_basic
                 actor.set_base_pose
                 actor.action_movement[2] = self.action_movement[2]
              end
          end
      end
  end

  #--------------------------------------------------------------------------
  # ● Execute Party Animation
  #--------------------------------------------------------------------------  
  def execute_party_animation(animation_id)
      return if animation_id == nil
      for member in $game_temp.cooperation_skill_members
          for actor in $game_temp.target_actors
              actor.animation_id = animation_id if actor.battler.id == member.id
          end
      end      
  end
  
  #--------------------------------------------------------------------------
  # ● Make Members Pose
  #--------------------------------------------------------------------------    
  def make_members_pose(pose,duration)
      for member in $game_temp.cooperation_skill_members
          for actor in $game_temp.target_actors
              if actor.battler.id == member.id
                 actor.make_pose(pose,duration)
              end
          end
      end  
  end
  
  #--------------------------------------------------------------------------
  # ● Can execute Cooperation Skill
  #--------------------------------------------------------------------------                   
  def can_execute_cooperation_skill?
      return true if is_skill_cooperation? and members_cooperation_alive?
      return false
  end

  #--------------------------------------------------------------------------
  # ● is skill Cooperation?
  #--------------------------------------------------------------------------                 
  def is_skill_cooperation?
      return false if self.is_a?(Game_Event)
      skill = skill = $data_skills[self.action_movement[2]] rescue nil
      return false if skill == nil
      skill_c = SCHALA_COOPERATION_SKILL::COOPERATION_SKILL_ID[skill.id] rescue nil
      return true if skill_c != nil
      return false
  end

  #--------------------------------------------------------------------------
  # ● Cooperation Skill?
  #--------------------------------------------------------------------------                     
  def cooperation_skill?(skill)
      skill_c = SCHALA_COOPERATION_SKILL::COOPERATION_SKILL_ID[skill.id] rescue nil
      return true if skill_c != nil
      return false
  end
  
  #--------------------------------------------------------------------------
  # ● members Cooperation Alive
  #-------------------------------------------------------------------------- 
  def members_cooperation_alive?
      $game_temp.cooperation_skill_members = []
      skill = skill = $data_skills[self.action_movement[2]]
      skill_c = SCHALA_COOPERATION_SKILL::COOPERATION_SKILL_ID[skill.id]
      return false if skill_c == nil
      for actor in $game_party.members
          for coop_member_id in skill_c
             if actor.actor_id == coop_member_id
                if actor.dead?
                   $game_temp.cooperation_skill_members = []
                   return false
                end   
                $game_temp.cooperation_skill_members.push(actor)
             end
          end
      end
      if $game_temp.cooperation_skill_members.size != skill_c.size
         $game_temp.cooperation_skill_members = []
         return false 
      end
      return true
  end

  #--------------------------------------------------------------------------
  # ● Execute Cooperation Skill
  #--------------------------------------------------------------------------             
  def cooperation_skill_met?(skill)
      return false if @actor == nil
      skill_c = SCHALA_COOPERATION_SKILL::COOPERATION_SKILL_ID[skill.id] rescue nil
      return true if skill_c == nil
      return false if skill_c.size < 2
      self_include = false
      party_size = 0
      for actor in $game_party.members
          for coop_member_id in skill_c
             if actor.actor_id == coop_member_id
                party_size += 1
                self_include = true if @actor.battler.id == coop_member_id
                return false if !actor.avaliable_for_skill?(skill)
             end
          end
      end 
      return false if party_size != skill_c.size
      return false if !self_include
      return true 
  end

  #--------------------------------------------------------------------------
  # ● Execute Cooperation Party Skill
  #--------------------------------------------------------------------------             
  def cooperation_skill_party_met?(skill)
      return false if @actor == nil
      skill_c = SCHALA_COOPERATION_SKILL::COOPERATION_SKILL_ID[skill.id] rescue nil
      return true if skill_c == nil
      return false if skill_c.size < 2
      self_include = false
      party_size = 0
      for actor in $game_party.members
          for coop_member_id in skill_c
             if actor.actor_id == coop_member_id
                party_size += 1
                self_include = true if @actor.battler.id == coop_member_id                
             end
          end
      end 
      return false if party_size != skill_c.size
      return false if !self_include
      return true 
  end  
  
end

#===============================================================================
# ■ Game Player
#===============================================================================
class Game_Player < Game_Character
  attr_accessor :allies
  attr_accessor :x
  attr_accessor :y
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------    
  alias xas_game_player_allies_initialize initialize
  def initialize
      @cx = 0
      @cy = 0
      xas_game_player_allies_initialize
      @turn_index = 0
      @target = true     
      refresh_allies
   end
  
  #--------------------------------------------------------------------------
  # ● Refresh Allies
  #--------------------------------------------------------------------------  
  def refresh_allies
      @allies = []
      for a in 0...$game_party.max_battle_members - 1
          @allies.push(followers.data[a]) if followers.data[a].visible?
      end
  end 
  
  #--------------------------------------------------------------------------
  # ● Move By Input
  #--------------------------------------------------------------------------    
  alias mog_schala_stop_move_by_input move_by_input
  def move_by_input
      return if $game_temp.one_sec_lag > 0
      return if $game_temp.battle_phase[0]
      return if $game_temp.hookshot_phase != 0
      mog_schala_stop_move_by_input
  end
  
  #--------------------------------------------------------------------------
  # ● Foce Battle
  #--------------------------------------------------------------------------      
  def force_battle
      battle_start
  end
  
  #--------------------------------------------------------------------------
  # ● Update Anime Count
  #--------------------------------------------------------------------------
  alias mog_schala_hookshot_update_anime_count update_anime_count
  def update_anime_count
      return if $game_temp.hookshot_phase == 3
      mog_schala_hookshot_update_anime_count
  end  
  
end

#===============================================================================
# ■ Game Follower
#===============================================================================
class Game_Follower < Game_Character  
  attr_reader :member_index
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------      
  alias xas_schala_initialize initialize
  def initialize(member_index, preceding_character)
      xas_schala_initialize(member_index, preceding_character)
      @turn_index = member_index
      @target = true
  end

  #--------------------------------------------------------------------------
  # ● Update Anime Count
  #--------------------------------------------------------------------------
  alias mog_schala_hookshot_update_anime_count update_anime_count
  def update_anime_count
      return if $game_temp.hookshot_phase == 3
      mog_schala_hookshot_update_anime_count
  end    
  
end

#===============================================================================
# ■ Game Party
#===============================================================================
class Game_Party < Game_Unit

  #--------------------------------------------------------------------------
  # ● Reset Party Name
  #--------------------------------------------------------------------------  
  def reset_party_name
      $game_player.set_original_name
      for i in $game_player.followers
          i.set_original_name
      end    
  end   
  
  #--------------------------------------------------------------------------
  # ● Add Actor
  #--------------------------------------------------------------------------      
  alias schala_add_actor add_actor
  def add_actor(actor_id)
      schala_add_actor(actor_id)
      reset_party_name
      SceneManager.goto(Scene_Refresh)
  end
    
  #--------------------------------------------------------------------------
  # ● Remove Actor
  #--------------------------------------------------------------------------      
  alias schala_remove_actor remove_actor
  def remove_actor(actor_id)
      schala_remove_actor(actor_id)
      reset_party_name
      SceneManager.goto(Scene_Refresh)
  end

  #--------------------------------------------------------------------------
  # ● Change Leader
  #--------------------------------------------------------------------------
  def change_leader
      return if $game_party.members.size == 0
      time = 0
      loop do
         $game_party.swap_order(0,1) if $game_party.members.size > 1 
         if $game_party.members.size > 2
            $game_party.swap_order(1,2)
            $game_party.swap_order(2,1) if $game_party.members[1].dead? 
         end   
         time += 1 
         break if !$game_party.members[0].dead? or time > 6
      end
      $game_player.refresh
      $game_map.need_refresh = true
      $game_temp.refresh_hud = true
      reset_party_name
  end  
  
  #--------------------------------------------------------------------------
  # ● Refresh Leader
  #--------------------------------------------------------------------------
  def refresh_leader
      return if $game_party.members.size == 0
      time = 0
      loop do
         if $game_party.members.size > 1
            $game_party.swap_order(0,1) if $game_party.members[0].dead?
         end   
         if $game_party.members.size > 2
            $game_party.swap_order(1,2) if $game_party.members[1].dead?
         end
         time += 1 
         break if time > 3
      end
      $game_player.refresh
      $game_map.need_refresh = true
      $game_temp.refresh_hud = true
      reset_party_name
  end    
  
  #--------------------------------------------------------------------------
  # ● Swap Order
  #--------------------------------------------------------------------------  
  alias schala_leader_swap_order swap_order
  def swap_order(index1, index2)
      if !SceneManager.scene_is?(Scene_Map)
          if index1 == 0 and $game_party.members[index2].dead?
             Sound.play_cancel
             return
          elsif index2 == 0 and $game_party.members[index1].dead? 
             Sound.play_cancel 
             return
          end  
      end
      schala_leader_swap_order(index1, index2)
  end  
  
  #--------------------------------------------------------------------------
  # ● Check Game Over
  #--------------------------------------------------------------------------    
  def check_gameover
      return if $game_party.members.size == 0
      gameover = true
      index = 0
      for actor in $game_party.members
         gameover = false if !actor.dead?    
         index += 1
         break if index > ($game_party.max_battle_members - 1)
      end
      $game_temp.game_over_phase_duration = 30 if gameover 
  end
  
end

#===============================================================================
# ■ Game_Party
#===============================================================================
class Game_Party < Game_Unit 

  #--------------------------------------------------------------------------
  # ● Max Battle Members
  #--------------------------------------------------------------------------     
  def max_battle_members
      return 3
  end
  
end  

#===============================================================================
# ■ Character 
#===============================================================================
class Game_Character < Game_CharacterBase
  
   attr_accessor :original_character_name
   attr_accessor :pose_duration
   attr_accessor :pose_name 
   attr_accessor :character_name  
   
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------          
   alias schala_original_character_name_initialize initialize
   def initialize
       @original_character_name = ""
       @pose_duration = 0
       @pose_name = ""        
       schala_original_character_name_initialize
   end
   
  #--------------------------------------------------------------------------
  # ● Restore Name
  #--------------------------------------------------------------------------             
  def set_original_name
      self.original_character_name = ""    
      record_original_name
  end
   
  #--------------------------------------------------------------------------
  # ● Restore Original Name
  #--------------------------------------------------------------------------           
  def record_original_name
      return if self.original_character_name != ""
      self.original_character_name = self.character_name rescue nil
  end
   
  #--------------------------------------------------------------------------
  # ● Restore Name
  #--------------------------------------------------------------------------           
  def restore_name
      self.character_name = self.original_character_name rescue nil
      self.refresh
  end
  
end

#===============================================================================
# ■ Game_CharacterBase
#===============================================================================
class Game_CharacterBase

 #--------------------------------------------------------------------------
 # ● Set Graphic
 #--------------------------------------------------------------------------               
  alias schala_base_set_graphic set_graphic
  def set_graphic(character_name, character_index)
      schala_base_set_graphic(character_name, character_index)      
      reset_original_base_name if self.is_a?(Game_Player) or self.is_a?(Game_Follower) 
  end
  
 #--------------------------------------------------------------------------
 # ● Reset Orginal Base Name
 #--------------------------------------------------------------------------                
  def reset_original_base_name
      return if $game_temp.battle_phase[0]
      self.original_character_name = self.character_name
  end

end


#===============================================================================
# ■ Game Player
#===============================================================================
class Game_Player < Game_Character
  
  #--------------------------------------------------------------------------
  # ● Refresh
  #--------------------------------------------------------------------------    
  alias schala_original_character_name_refresh refresh
  def refresh
      schala_original_character_name_refresh
      record_original_name
  end  
  
end

#===============================================================================
# ■ Game Follower
#===============================================================================
class Game_Follower < Game_Character  
  
  #--------------------------------------------------------------------------
  # ● Refresh
  #--------------------------------------------------------------------------    
  alias schala_original_character_name_follower_refresh refresh
  def refresh
      schala_original_character_name_follower_refresh
      record_original_name
  end    
  
end

#==============================================================================
# ■ Game Interpreter
#==============================================================================
class Game_Interpreter
  
  #--------------------------------------------------------------------------
  # ● Command 322
  #--------------------------------------------------------------------------  
  alias schala_orginal_character_name_command_322 command_322
  def command_322
      schala_orginal_character_name_command_322
      interpreter_set_original_name(@params[0])
  end
  
  #--------------------------------------------------------------------------
  # ● Interpreter Set Original Name
  #--------------------------------------------------------------------------    
  def interpreter_set_original_name(value)
      actor = $game_actors[value]
      if value == 1
         $game_player.set_original_name rescue nil
      else  
         $game_player.followers[value - 2].set_original_name rescue nil
      end
      $game_player.refresh  
  end
    
end

#==============================================================================
# ■ Game Party
#==============================================================================
class Game_Party < Game_Unit

 #--------------------------------------------------------------------------
 # ● Swap Order
 #--------------------------------------------------------------------------      
 alias schala_name_swap_order swap_order
 def swap_order(index1, index2)
     schala_name_swap_order(index1, index2)
     $game_player.set_original_name
     for f in $game_player.followers
         f.set_original_name
     end
     $game_player.refresh
 end
 
end

#===============================================================================
# ■ Game_Character
#===============================================================================
class Game_Character < Game_CharacterBase
  
  #-----------------------------------------------------------------------------
  # ● Update
  #-----------------------------------------------------------------------------    
  def make_pose(sufix, pose_duration = 10)
      return if @original_character_name == nil
      @pose_name = sufix
      @pose_duration = pose_duration
  end     
  
  #-----------------------------------------------------------------------------
  # ● Update Pose
  #-----------------------------------------------------------------------------    
  def update_battler_pose
      update_restore_orginal_name
      update_pose_phase
  end
  
  #-----------------------------------------------------------------------------
  # ● Update Pose Phase
  #-----------------------------------------------------------------------------      
  def update_pose_phase
      return if @pose_duration == 0 
      @pose_duration -= 1 unless self.battler.dead? and $game_temp.battle_phase[0]
      @character_name = @original_character_name + @pose_name
      set_base_pose if @pose_duration == 0  
  end  
      
  #-----------------------------------------------------------------------------
  # ● Update Restore Original Name
  #-----------------------------------------------------------------------------      
  def update_restore_orginal_name
      return if @pose_duration > 0
      @character_name = @original_character_name
      if !$game_temp.battle_phase[0] and !self.is_a?(Game_Event)
         @step_anime = false
      end
  end

  #-----------------------------------------------------------------------------
  # ● Set Base Pose
  #-----------------------------------------------------------------------------        
  def set_base_pose
      return if self.battler == nil
      if self.battler.dead? and $game_temp.battle_phase[0]
         make_pose("_Hit", 2) 
      else   
         if self.battler.cast_effect[0] > 0
            make_pose("_Cast", self.battler.cast_effect[0]) 
         else
            make_pose(@original_character_name, 0) 
         end  
      end   
  end  
  
  #-----------------------------------------------------------------------------
  # ● Reset Pise
  #-----------------------------------------------------------------------------        
  def reset_pose
      @character_name = @original_character_name  
      @pose_duration = 0
      @pose_name = ""  
  end 
  
end

#===============================================================================
# ■ RPG_FileTest 
#===============================================================================
module RPG_FileTest
  
  #--------------------------------------------------------------------------
  # ● RPG_FileTest.character_exist?
  #--------------------------------------------------------------------------
  def RPG_FileTest.character_exist?(filename)
      return Cache.character(filename) rescue return false
  end
    
end

#===============================================================================
# ■ Sprite_Character
#===============================================================================
class Sprite_Character < Sprite_Base
  
  #--------------------------------------------------------------------------
  # ● X Pose Update
  #--------------------------------------------------------------------------  
  alias x_pose_update_bitmap update_bitmap
  def update_bitmap
      check_file_exist if can_check_file_exist?
      x_pose_update_bitmap
  end
 
  #--------------------------------------------------------------------------
  # ● Can Check File Exist
  #--------------------------------------------------------------------------    
  def can_check_file_exist?
      return false if @character_name == @character.character_name
      return false if @character.battler == nil
      return false if @character.tool_id > 0
      return true
  end
  
 #--------------------------------------------------------------------------
 # ● Check File Exist
 #--------------------------------------------------------------------------  
 def check_file_exist
     unless RPG_FileTest.character_exist?(@character.character_name)
            @character.reset_pose 
     end
 end  
  
end

#===============================================================================
# ■ Game Action Result
#===============================================================================
class Game_ActionResult
  
  #--------------------------------------------------------------------------
  # ● Hit Schala
  #--------------------------------------------------------------------------    
  def hit_schala?
     !@missed && !@evaded
  end
   
end

#===============================================================================
# ■ Game Battler
#===============================================================================
class Game_Battler < Game_BattlerBase
  include Schala_Battle
  
  #--------------------------------------------------------------------------
  # ● Item Test Schala
  #--------------------------------------------------------------------------  
  def item_test_schala(user, item)
      return false if item.for_dead_friend? != dead?
      return true if $game_party.in_battle
      return true if item.for_opponent?
      return true if item.damage.recover? && item.damage.to_hp?
      return true if item.damage.recover? && item.damage.to_mp?
      return true if item_has_any_valid_effects?(user, item)
      return false
  end  
  
  #--------------------------------------------------------------------------
  # ● Item Apply Schala
  #--------------------------------------------------------------------------
  def item_apply_schala(user, item)
      @result.clear
      @result.used = item_test_schala(user, item)
      @result.missed = (@result.used && rand >= item_hit(user, item))
      @result.evaded = (!@result.missed && rand < item_eva(user, item))
      if @result.hit_schala?
         unless item.damage.none?
           @result.critical = (rand < item_cri(user, item))
           if user.is_a?(Game_Actor) and cooperation_skill?(item)
              make_damage_cooperation(user,item) rescue nil
           else
              make_damage_value(user, item)
           end
           execute_damage(user)
         end
         item.effects.each {|effect| item_effect_apply(user, item, effect) }
         item_user_effect(user, item)
      end
  end  

  #--------------------------------------------------------------------------
  # ● Make Damage Cooperation
  #--------------------------------------------------------------------------  
  def make_damage_cooperation(user,item)
      if $game_temp.cooperation_skill_members == nil or
         $game_temp.cooperation_skill_members == [] or
         $game_temp.cooperation_skill_members.size <= 1
         make_damage_value(user, item)
         return
      end  
      hp_dmg = 0
      mp_dmg = 0
      for actor in $game_temp.cooperation_skill_members
          next if actor == nil
          make_damage_value(actor, item) rescue nil
          hp_dmg += @result.hp_damage
          mp_dmg += @result.mp_damage 
      end
      @result.hp_damage = hp_dmg / $game_temp.cooperation_skill_members.size
      @result.mp_damage = mp_dmg / $game_temp.cooperation_skill_members.size
  end  
      
  #--------------------------------------------------------------------------
  # ● Execute Move Damage
  #--------------------------------------------------------------------------            
  alias schala_execute_damage execute_damage
  def execute_damage(user)
      execute_schala_damage(user)
      schala_execute_damage(user)
  end

  #--------------------------------------------------------------------------
  # ● Execute Schala Damage Effect
  #--------------------------------------------------------------------------              
  def execute_schala_damage(user)
      return if SceneManager.scene_is?(Scene_Battle)
      execute_face_effect
      execute_damage_pop(user)
  end     
       
  #--------------------------------------------------------------------------
  # ● Execute Schala Damage Effect
  #--------------------------------------------------------------------------                
  def execute_face_effect
      return if !self.is_a?(Game_Actor)
      return if !$game_temp.battle_phase[0]
      if @result.hp_damage > 0
         self.face_shake = 40
         self.face_phase[0] = 2
      elsif @result.hp_damage < 0
        self.face_phase[0] = 1
      end        
  end

  #--------------------------------------------------------------------------
  # ● Execute Guard
  #--------------------------------------------------------------------------                
  def execute_guard 
      return if !self.guard_effect
      @result.hp_damage /= 2 if @result.hp_damage > 0
      @result.hp_drain /= 2 if @result.hp_drain > 0
  end  
  
 #--------------------------------------------------------------------------
 # ● Make Damage Value
 #--------------------------------------------------------------------------         
 alias mog_schala_make_damage_value make_damage_value
 def make_damage_value(user, item)
     @pre_item = item
     mog_schala_make_damage_value(user, item)   
     execute_guard
 end
  
 #--------------------------------------------------------------------------
 # ● Execute Damage Pop
 #--------------------------------------------------------------------------       
 def execute_damage_pop(user)
     return if !$game_temp.battle_phase[0] and $game_party.in_battle
     return if @pre_item == nil
     item = @pre_item
     if item.damage.to_mp?
        dam = @result.mp_damage
        self.damage_type = "Mp"        
     elsif item.damage.to_hp?
        dam = @result.hp_damage 
        self.damage_type = "Critical"  if @result.critical         
     end
     return if dam == nil
     if item.damage.drain?
        if user.is_a?(Game_Actor) and cooperation_skill?(@pre_item)          
           execute_damage_pop_drain_cooperation(user,dam) rescue nil
        else
           user.damage = -dam
           user.damage_type = self.damage_type
           user.damage_pop = true
        end   
     end  
     self.damage = dam
     self.damage_pop = true     
 end   
  
 #--------------------------------------------------------------------------
 # ● Execute Damage Pop drain Cooperation
 #--------------------------------------------------------------------------        
 def execute_damage_pop_drain_cooperation(user,dam)
      if $game_temp.cooperation_skill_members == nil or
         $game_temp.cooperation_skill_members == [] or
         $game_temp.cooperation_skill_members.size <= 1
         user.damage = -dam
         user.damage_type = self.damage_type
         user.damage_pop = true
         return
      end   
      for actor in $game_temp.cooperation_skill_members
          next if actor == nil
          actor.damage = -dam
          actor.damage_type = self.damage_type
          actor.damage_pop = true
          actor.hp += dam unless user == actor
      end   
 end
 
end

#==============================================================================
# ■ Game_System
#==============================================================================
class Game_System
  
  attr_accessor :at_max
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------         
  alias mog_at_system_initialize initialize
  def initialize
      @at_max = [[SCHALA_SYSTEM::AT_SPEED, 999999].min, 100].max
      mog_at_system_initialize
  end
  
end 

#==============================================================================
# ■ Game_Battler
#==============================================================================
class Game_Battler < Game_BattlerBase
  
   attr_accessor :at
   attr_accessor :at_max
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------       
   alias mog_at_system_initialize initialize
   def initialize
       mog_at_system_initialize
       @at = 0
       @at_max = $game_system.at_max
   end
     
  #--------------------------------------------------------------------------
  # ● At
  #--------------------------------------------------------------------------          
   def at
       n = at_active? ? @at_max : 0
       return [[@at, n].min, 0].max
   end  
   
  #--------------------------------------------------------------------------
  # ● At Active
  #--------------------------------------------------------------------------             
   def at_active?
       return false if restriction >= 4
       return false if self.hp == 0 
       return true
   end  
   
  #--------------------------------------------------------------------------
  # ● Added New State
  #--------------------------------------------------------------------------  
  alias mog_at_system_add_new_state add_new_state
  def add_new_state(state_id)
      mog_at_system_add_new_state(state_id)
      if restriction >= 4
         self.at = 0
         self.guard_effect = false
      end   
  end   
  
end

#==============================================================================
# ■ Game_CharacterBase
#==============================================================================
class Game_CharacterBase

  #--------------------------------------------------------------------------
  # ● Passable
  #-------------------------------------------------------------------------- 
  alias mog_schala_passable?  passable?
  def passable?(x, y, d)
      return false if !can_battler_passable?(x, y, d)
      mog_schala_passable?(x, y, d)
  end
  
  #--------------------------------------------------------------------------
  # ● Passable
  #--------------------------------------------------------------------------   
  def can_battler_passable?(x, y, d)
      return true if !$game_temp.battle_phase[0]
      return true if !self.target
      return true if self.tool_id > 0
      if $game_temp.target_phase != nil
         return true if self.battler.is_a?(Game_Actor)
      end
      case d
        when 2          
           return false if y >= real_cy_max
        when 4
           return false if x <= real_cx
        when 6
           return false if x >= real_cx_max 
        when 8
           return false if y <= real_cy 
      end
      return true
  end  
  
end

#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase

  #--------------------------------------------------------------------------
  # ● Update Stop
  #--------------------------------------------------------------------------        
  alias schala_update_stop update_stop
  def update_stop
      return unless can_update_stop?
      schala_update_stop
  end
  
  #--------------------------------------------------------------------------
  # ● Can Update Stop
  #--------------------------------------------------------------------------        
  def can_update_stop?
      return false if $game_temp.force_wait > 0
      return false if self.disabled
      return false if $game_temp.hookshot_phase != 0
      return true if !$game_temp.battle_phase[0]
      return true if self.battler == nil      
      return false if !self.target
      return false if $game_temp.pre_battle_phase > 0
      return false if $game_temp.target_phase != nil
      return false if $game_temp.command_phase != 0
      return false if $game_temp.action_phase[0] and !self.active
      return false if $game_temp.turn_sprite_phase == 2
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● Update Routine Move
  #--------------------------------------------------------------------------      
  alias chrono_game_character_update_routine_move update_routine_move
  def update_routine_move
      return if can_wait_jump?
      return if wait_next_command?
      chrono_game_character_update_routine_move
  end
 
  #--------------------------------------------------------------------------
  # ● Wait Next Command
  #--------------------------------------------------------------------------      
  def wait_next_command?
      return true if $game_temp.hookshot_phase != 0
      return false if !$game_temp.action_phase[0]
      return false if self.battler == nil
      return false if self.battler.dead?
      return true if !self.target
      return true if $game_temp.event_wait_movement
      return true if $game_temp.target_phase != nil
  end

  #--------------------------------------------------------------------------
  # ● Can Wait Jump
  #--------------------------------------------------------------------------        
  def can_wait_jump?
      return false if !$game_temp.battle_phase[0]
      return false if $game_temp.target_phase == nil
      return true if $game_temp.event_wait_movement > 0  
  end    
end

#==============================================================================
# ■ Game_Event
#==============================================================================
class Game_Event < Game_Character
  attr_accessor :move_type
  
  #--------------------------------------------------------------------------
  # ● Update Self Movement
  #--------------------------------------------------------------------------
  alias schala_update_self_movement update_self_movement
  def update_self_movement
      if can_update_battle_phase_movement?
         update_battle_phase_movement
      end
      schala_update_self_movement
  end
  
  #--------------------------------------------------------------------------
  # ● Can Update Battler Movement
  #--------------------------------------------------------------------------  
  def can_update_battle_phase_movement?
      return false if @move_type == 3
      return false if !$game_temp.battle_phase[0]
      return false if !self.target
      return false if self.battler == nil
      return false if $game_temp.pre_battle_phase > 0
      return false if self.moving? or self.jumping?
      return false if self.erased
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● Update Battle Movement
  #--------------------------------------------------------------------------    
  def update_battle_phase_movement
      return if @move_type == 0 
      return if @move_type == 3
      range_x = (self.x - $game_player.cx).abs
      range_y = (self.y - $game_player.cy).abs
      if can_jump_arround_player?
         turn_toward_player
         jump_near_player
         return
      elsif range_x > 4 or range_y > 4
         @move_type = 2
         return 
      end
      @move_type = 1
 end
  
 #--------------------------------------------------------------------------
 # ● Can Jump Arround Player
 #--------------------------------------------------------------------------     
 def can_jump_arround_player?
     return true if !self.x.between?(real_cx, real_cx_max)
     return true if !self.y.between?(real_cy, real_cy_max)
     return false
 end
 
end

#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase

  #--------------------------------------------------------------------------
  # ● Skill
  #--------------------------------------------------------------------------          
  def skill(skill_id = 0,user = true)
      return unless can_enemy_use_action?(skill_id,user)
      self.reset_battler_parameters
      self.action_movement[2] = skill_id 
      execute_enemy_action
      set_action_times      
  end    
    
  #--------------------------------------------------------------------------
  # ● Execute Enemy Action
  #--------------------------------------------------------------------------            
  def execute_enemy_action
      self.action_movement[6] -= 1
      self.action_movement[3] = 0
      enemy_target_selection
      self.battler.at = 0
      if self.action_movement[4] == nil   
         self.action_movement[6] = 1
         clear_all_action(self)
         return  
      end   
      self.action_movement[0] = 1
      self.active = true
      execute_cast_animation
      execute_move_type      
  end
  
  #--------------------------------------------------------------------------
  # ● Can Enemy Use Action
  #--------------------------------------------------------------------------              
  def can_enemy_use_action?(skill_id,user)
      if self.tool_id > 0
         if user
            self.action.user.shoot(skill_id) 
            self.action.user.battler.at = 0
            self.action.user.battler.cast_effect = [0,1]
         else
            self.shoot(skill_id)
         end   
         return false
      end     
      return false if self.battler == nil
      if self.battler.abs_mode
         self.shoot(skill_id)
         return false 
      end
      return false if !$game_temp.battle_phase[0]
      return false if $game_temp.turn_sprite_phase > 0
      return false if self.action_movement[0] > 0 and user.is_a?(Game_Enemy)
      return false if skill_id == nil or skill_id == 0          
      return false if self.battler.dead?
      return false if !self.target
      return false if self.disabled  
      return true
  end
      
  #--------------------------------------------------------------------------
  # ● Enemy Target Selection
  #--------------------------------------------------------------------------            
  def enemy_target_selection
      skill = $data_skills[self.action_movement[2]]
      return if skill == nil
      targets = []
      if skill.scope >= 7
         for i in $game_temp.target_enemies
              targets.push(i) if !i.battler.dead?
         end        
      else          
         for i in $game_temp.target_actors
              targets.push(i) if !i.battler.dead?
         end  
      end
      self.action_movement[4] = targets[rand(targets.size)]
  end    
      
end

#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase
  include SCHALA_FIELD
  
  #--------------------------------------------------------------------------
  # ● Update
  #--------------------------------------------------------------------------    
  alias schala_character_update update
  def update
      update_base_schala_system
      schala_character_update
  end
  
  #--------------------------------------------------------------------------
  # ● Update Base Schala System
  #--------------------------------------------------------------------------      
  def update_base_schala_system
      update_timed_animation
      update_battler if can_update_battler?
      update_battler_pose if can_update_battler_pose?
      update_force_action if can_force_action?
      update_schala_system if can_update_schala_system?    
  end  
  
  #--------------------------------------------------------------------------
  # ● Update Base Schala System
  #--------------------------------------------------------------------------      
  def update_timed_animation
      return if self.timed_animation[1] <= 0
      self.timed_animation[1] -= 1
      if self.timed_animation[1] == 0
         self.animation_id = self.timed_animation[0]
         self.timed_animation = [0,0]
      end   
  end  
 
 #--------------------------------------------------------------------------
  # ● Can Update Battler
  #--------------------------------------------------------------------------        
  def can_update_battler?
      return false if self.battler == nil
      return false if self.tool_id != 0
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● Can Update Battler Pose
  #--------------------------------------------------------------------------        
  def can_update_battler_pose?
      return false if self.battler == nil
      return false if self.erased
      if !$game_temp.battle_phase[0]
         return false if self.is_a?(Game_Player) and @dash and self.action == nil
      else
         return false if !self.target 
      end    
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● Can Update Schala System
  #--------------------------------------------------------------------------      
  def can_update_schala_system?
      return false if !$game_temp.battle_phase[0]
      return false if !self.target
      return false if self.erased
      return false if self.battler == nil      
      return true
  end

  #--------------------------------------------------------------------------
  # ● Update Schala System
  #--------------------------------------------------------------------------      
  def update_schala_system
      update_active_cast_time if can_update_cast_phase?
      update_active_system if can_update_active_system? 
      update_action_move if can_update_action_move?       
      update_turn_break
  end
  
  #--------------------------------------------------------------------------
  # ● Update Turn Break
  #--------------------------------------------------------------------------        
  def update_turn_break
      return if $game_temp.target_phase == nil
      return if $game_temp.target_phase != self  
      if self.action_movement[0] == 4
         $game_temp.turn_break_time += 1
      else
         $game_temp.turn_break_time = 0
      end
      execute_break_turn if can_break_turn?
  end

  #--------------------------------------------------------------------------
  # ● Can Break Turn
  #--------------------------------------------------------------------------          
  def can_break_turn?
      return true if self.action_movement[0] == 0
      return true if self.battler.at > 0
      return true if self.action_movement[2] == 0
      return true if self.battler.cast_effect[0] > 0
      return true if $game_temp.turn_break_time > 75
      return false
  end

  #--------------------------------------------------------------------------
  # ● Update Active Cast Time
  #--------------------------------------------------------------------------        
  def update_active_cast_time 
      self.battler.cast_effect[0] -= 1 
  end
  
  #--------------------------------------------------------------------------
  # ● Can Update Cast Phase
  #--------------------------------------------------------------------------          
  def can_update_cast_phase?
      return false if self.battler.cast_effect[0] == 0      
      return false if $game_temp.battle_phase[2] > 0
      if $game_temp.target_phase != nil
         return false unless $game_temp.target_phase == self
      end   
      return false if $game_temp.command_phase != 0
      return false if $game_temp.action_phase[0] and !self.active
      return true
  end
  
end

#===============================================================================
# ■ Sprite_Character
#===============================================================================
class Sprite_Character < Sprite_Base
  
  #--------------------------------------------------------------------------
  # ● Update
  #--------------------------------------------------------------------------            
  alias x_update update
  def update
      x_update
      update_fade
      update_treasure_effect
      update_sprites_effects if can_update_sprite_effects?
  end
   
end    

#===============================================================================
# ■ Spriteset Map
#===============================================================================
class Spriteset_Map
  
  #--------------------------------------------------------------------------
  # ● Update Tilemap
  #--------------------------------------------------------------------------  
  alias schala_update_tilemap update_tilemap
  def update_tilemap
      @tilemap.visible = $game_temp.tilemap_visible
      schala_update_tilemap
  end
  
end  

#===============================================================================
# ■ Game Event
#===============================================================================
class Game_Event < Game_Character
  
  #--------------------------------------------------------------------------
  # ● Update Base Schala System
  #--------------------------------------------------------------------------    
  def update_base_schala_system
      super
      update_sensor_global 
      update_sensor if can_update_sensor?
      update_treasure_duration
  end     
    
end 

#===============================================================================
# ■ Game Player
#===============================================================================
class Game_Player < Game_Character
  
  #--------------------------------------------------------------------------
  # ● Update
  #--------------------------------------------------------------------------                 
  alias schala_base_player_update update
  def update
      schala_base_player_update
      update_abs_player
  end      
  
  #--------------------------------------------------------------------------
  # ● Update ABS Player
  #--------------------------------------------------------------------------       
  def update_abs_player
     # update_variable_player
      update_abs_command if can_update_abs_command?  
  end
    
  #--------------------------------------------------------------------------
  # ● Update Variable Player
  #--------------------------------------------------------------------------        
  def update_variable_player
      #$game_variables[PLAYER_X_VARIABLE_ID] = $game_player.x
      #$game_variables[PLAYER_X_VARIABLE_ID] = $game_player.y
  end
  
  #--------------------------------------------------------------------------
  # ● Cx
  #--------------------------------------------------------------------------      
  def cx
      return ($game_map.display_x + center_x).truncate rescue 8
  end
  
  #--------------------------------------------------------------------------
  # ● Cx
  #--------------------------------------------------------------------------      
  def cy
      return ($game_map.display_y + center_y).truncate rescue 6   
  end
  
end
  
#==============================================================================
# ■ Sprite Picture
#==============================================================================
class Sprite_Picture < Sprite
  
 #--------------------------------------------------------------------------
 # ● Update
 #--------------------------------------------------------------------------     
  alias mog_fix_picture_erased_update update
  def update
      return if picture_erased?  
      mog_fix_picture_erased_update
  end  
  
 #--------------------------------------------------------------------------
 # ● Picture Erased?
 #--------------------------------------------------------------------------     
  def picture_erased?
      return false if @picture.name != ""
      if self.bitmap != nil
         self.bitmap.dispose
         self.bitmap = nil
      end  
      return true 
  end
  
end

#===============================================================================
# ■  Spriteset_Map
#===============================================================================
class Spriteset_Map
  
  include Schala_Battle
  
  #--------------------------------------------------------------------------
  # ● update
  #--------------------------------------------------------------------------  
  alias schala_main_update update
  def update
      schala_main_update
      update_schala_phase
  end

  #--------------------------------------------------------------------------
  # ● Update Schala Phase
  #--------------------------------------------------------------------------      
  def update_schala_phase
      if !$game_temp.battle_phase[0]
         update_schala_phase_out_battle
         update_recheck_battle_end
         refresh_time_recover
      else   
         update_schala_phase_in_battle
      end
  end     
       
  #--------------------------------------------------------------------------
  # ● Update Recheck Battle End
  #--------------------------------------------------------------------------         
  def update_recheck_battle_end
      return if !$game_temp.recheck_battle_end
      battle_end
      return_to_original_position
      $game_player.clear_jump_speed
     # $game_temp.replay_pre_bgm
      $game_temp.pre_bgm[4] = true  
      $game_temp.recheck_battle_end = false
  end  
 
  #--------------------------------------------------------------------------
  # ● Refresh Time Recover
  #--------------------------------------------------------------------------      
  def refresh_time_recover
      return if !$game_system.time_recover[1]
      $game_system.time_recover[1] = false
      DataManager.save_game_temp  
  end
 
  #--------------------------------------------------------------------------
  # ● Update Schala Phase out Battle
  #--------------------------------------------------------------------------              
  def update_schala_phase_out_battle
      $game_temp.one_sec_lag -= 1 if $game_temp.one_sec_lag > 0
      $game_temp.force_wait -= 1 if $game_temp.force_wait > 0
      $game_temp.action_lag_time -= 1 if $game_temp.action_lag_time > 0
      $game_temp.event_wait_movement = 0
      update_game_over
      update_hookshot_phase
      refresh_token if $game_map.need_refresh_token
  end    
      
  #--------------------------------------------------------------------------
  # ● Update Hookshot Phase
  #--------------------------------------------------------------------------                
  def update_hookshot_phase
      return if $game_temp.hookshot_phase == 0
      case $game_temp.hookshot_phase
         when 1
            $game_player.followers.gather
            $game_temp.hookshot_phase = 2
         when 2  
            if !$game_player.followers.gathering?
                set_hookshot_position
                $game_temp.hookshot_phase = 3 
            end    
         when 3
           if !$game_player.moving?
               $game_player.move_speed = 4
               $game_temp.hookshot_position = [0,0]
               $game_temp.hookshot_phase = 0
           end    
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Set Hookshot Position
  #--------------------------------------------------------------------------                 
  def set_hookshot_position
      $game_player.x = $game_temp.hookshot_position[0]
      $game_player.y = $game_temp.hookshot_position[1]
      $game_player.move_speed = 5
      return if $game_player.allies == nil
      for follower in $game_player.allies
          follower.x = $game_temp.hookshot_position[0]
          follower.y = $game_temp.hookshot_position[1]
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Update Schala Phase in Battle
  #--------------------------------------------------------------------------            
  def update_schala_phase_in_battle     
      update_temp_parameters
      update_pre_battle_phase
      update_at_wait
      update_game_over 
      update_battle_end if can_update_battle_end?
      update_jump_priority
      update_slow_motion_effect
      update_force_reset_jump_count
      update_turn_duration
      update_result_phase
     # update_force_turn 
     # update_debug_button
     refresh_token if $game_map.need_refresh_token
  end 

  #--------------------------------------------------------------------------
  # ● Update Result Phase
  #--------------------------------------------------------------------------      
  def update_result_phase
      return if $game_temp.result_phase[1] == 0
      if $game_temp.turn_sprite_phase == 1 and $game_temp.result_phase[1] == 30
         execute_victory_pose
         $game_temp.result_window[0] = true
      end        
      $game_temp.result_phase[1] -= 1 if $game_temp.result_phase[1] > 0
      execute_result if $game_temp.result_phase[1] == 0
  end
  
 #--------------------------------------------------------------------------
 # ● Update Temp Parameters
 #--------------------------------------------------------------------------        
 def update_temp_parameters
     $game_temp.force_wait -= 1 if $game_temp.force_wait > 0
     $game_temp.one_sec_lag -= 1 if $game_temp.one_sec_lag > 0
     $game_temp.command_wait -= 1 if $game_temp.command_wait > 0    
     $game_temp.result_duration -= 1 if $game_temp.result_duration > 0     
     $game_temp.force_reset_turn[1] = 0 if $game_temp.target_phase == nil
     $game_temp.action_lag_time -= 1 if $game_temp.action_lag_time > 0
     $game_temp.wait_active_command -= 1 if $game_temp.wait_active_command > 0
     $game_temp.event_wait_movement -= 1 if $game_temp.event_wait_movement > 0
     $game_temp.action_duration -= 1 if $game_temp.action_duration > 0
     $game_temp.initial_lag -= 1 if $game_temp.initial_lag > 0
  end
  
 #--------------------------------------------------------------------------
 # ● Update Temp Parameters
 #--------------------------------------------------------------------------        
  def update_turn_duration
      return if !$game_temp.battle_phase[0]
      return if $game_temp.target_phase != nil
      return if $game_temp.action_lag_time > 0
      return if $game_temp.command_phase != 0
      $game_temp.turn_duration[0] += 1
      return if $game_temp.turn_duration[0] < $game_temp.turn_duration[1]
      $game_temp.turn_duration[0] = 0
      $game_troop.add_turn
  end
    
  #--------------------------------------------------------------------------
  # ● Update Debug Button
  #--------------------------------------------------------------------------            
  def update_debug_button
      if Input.press?(:CTRL) 
          return if $game_temp.target_phase == nil
          msgbox($game_temp.target_phase.battler.name)
          msgbox($game_temp.target_phase.action_movement[0])
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Update Force Reset All
  #--------------------------------------------------------------------------          
  def update_force_turn      
      return if $game_temp.target_phase == nil
      return if $game_temp.action_lag_time > 0
      return if $game_temp.force_reset_turn[1] == 0
      $game_temp.force_reset_turn[1] -= 1
      if $game_temp.force_reset_turn[1] == 0
         for i in $game_temp.target_actors
             if $game_temp.target_phase == i
                i.reset_battler_parameters
             end
         end     
         for i in $game_temp.target_enemies
             if $game_temp.target_phase == i
                i.reset_battler_parameters
             end
         end                   
         $game_temp.target_phase = nil
         #$game_player.force_reset_all
      end   
  end
  
  #--------------------------------------------------------------------------
  # ● Update Force Reset Jump Count
  #--------------------------------------------------------------------------        
  def update_force_reset_jump_count
      return if $game_temp.force_reset_jump_count == 0
      return if $game_temp.target_actors == nil or $game_temp.target_actors.empty?
      $game_temp.force_reset_jump_count -= 1
      if $game_temp.force_reset_jump_count == 0
         for actor in $game_temp.target_actors
             actor.jump_count = 0
             actor.jump_peak = 0
          end
        
      end
  end
    
  #--------------------------------------------------------------------------
  # ● Update Slow Motion Effect
  #--------------------------------------------------------------------------        
  def update_slow_motion_effect
      return if $game_temp.battle_slow_motion[0] <= 0
      $game_temp.battle_slow_motion[0] -= 1
      Graphics.frame_rate = $game_temp.battle_slow_motion[1] 
      Graphics.frame_rate = 60 if $game_temp.battle_slow_motion[0] <= 0
  end
    
  #--------------------------------------------------------------------------
  # ● Update Pre Battle Phase
  #--------------------------------------------------------------------------        
  def update_pre_battle_phase
      return if !$game_temp.battle_phase[0]
      return if $game_temp.pre_battle_phase == 0
      $game_temp.pre_battle_phase -= 1
      clear_all_tools if $game_temp.pre_battle_phase == 50
      $game_player.clear_jump_speed if $game_temp.pre_battle_phase == 1
      execute_schala_battle_bgm if $game_temp.pre_battle_phase == 0
  end

  #--------------------------------------------------------------------------
  # ● Execute Schala Battle BGM
  #--------------------------------------------------------------------------         
  def execute_schala_battle_bgm
      $game_temp.force_reset_jump_count = 20
      BattleManager.play_battle_bgm if BATTLE_BGM
      set_party_direction
      force_party_direction
  end
  
  #--------------------------------------------------------------------------
  # ● Update AT Wait
  #--------------------------------------------------------------------------          
  def update_at_wait
      if $game_temp.in_turn == nil and $game_temp.command_phase != 0
         clear_command_paramenters
      end       
      if $game_temp.command_phase != 0 or $game_temp.action_phase[0] or
         $game_temp.target_phase != nil or $game_temp.action_lag_time > 0
         $game_temp.at_wait_phase = true
      else
         $game_temp.at_wait_phase = false
      end       
  end 
  
  #--------------------------------------------------------------------------
  # ● Update Game Over
  #--------------------------------------------------------------------------        
  def update_game_over
      return if $game_temp.game_over_phase_duration == 0
      $game_temp.game_over_phase_duration -= 1
      if $game_temp.game_over_phase_duration == 0       
         $game_system.schala_reset
         SceneManager.goto(Scene_Gameover)
      end   
  end
  
  #--------------------------------------------------------------------------
  # ● Update Jump Priority
  #--------------------------------------------------------------------------        
  def update_jump_priority
      return if $game_player.allies.size == 0
      return if !$game_temp.jump_priority[0]
      $game_temp.jump_priority[1] = 1 if !$game_player.allies[0].jumping?
      return if $game_temp.jump_priority[1] == 0
      $game_temp.jump_priority[1] -= 1
      if $game_temp.jump_priority[1] == 0 
         $game_player.priority_type = 1
         for follower in $game_player.followers
             follower.priority_type = 1   
         end
         $game_temp.jump_priority[0] = false
      end
  end  

  #--------------------------------------------------------------------------
  # ● Can Update Battle End
  #--------------------------------------------------------------------------          
  def can_update_battle_end?
      return false if !$game_temp.update_result
#      return false if !$game_temp.battle_phase[1]
#      return false if $game_temp.action_phase[0]   
#      return false if $game_temp.result_duration > 0
      return true
  end
    
  #--------------------------------------------------------------------------
  # ● Can Execute Battle End
  #--------------------------------------------------------------------------          
  def can_execute_battle_end?
      return false if !Input.trigger?(:C)
      return true
  end
  
end 

#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase
  
  #--------------------------------------------------------------------------
  # ● Can Update Active System
  #--------------------------------------------------------------------------      
  def can_update_active_system?
      update_active_system_global
      return false if !$game_temp.global_active_system[0]
      return false if self.action_movement[0] > 0      
      return false if self.action != nil      
      return true
  end

  #--------------------------------------------------------------------------
  # ● Update Active System
  #--------------------------------------------------------------------------  
  def update_active_system
      update_priority_system
      update_at_system if can_update_at_system?
      update_action_command if can_update_action_command?
  end

  #--------------------------------------------------------------------------
  # ● Can Update AT System
  #--------------------------------------------------------------------------   
  def can_update_at_system?
      update_global_active
      return false if !$game_temp.global_at_active[0]
      return false if self.battler.cast_effect[0] > 0 
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● Update At System
  #--------------------------------------------------------------------------    
  def update_at_system
      if self.battler.at < $game_system.at_max
         self.battler.turn = false 
         self.battler.at += self.battler.agi
         execute_at_se if self.battler.at >= $game_system.at_max
      end         
      execute_turn_active if self.battler.at >= $game_system.at_max
  end
  
  #--------------------------------------------------------------------------
  # ● Execute AT SE
  #--------------------------------------------------------------------------        
  def execute_at_se
      return if self.battler.is_a?(Game_Enemy)
      return if $game_temp.in_turn == nil
      Audio.se_play("Audio/SE/" + PLAYER_ACTIVE_SE,100,100) rescue nil
  end
    
  #--------------------------------------------------------------------------
  # ● Update Turn Active
  #--------------------------------------------------------------------------      
  def execute_turn_active
      self.battler.guard_effect = false
      if self.battler.is_a?(Game_Enemy)
         execute_set_enemy_action if can_execute_set_enemy_action?
      else   
         execute_actor_command_turn if can_execute_Actor_command?
      end  
  end

  #--------------------------------------------------------------------------
  # ● Can Execute Set Enemy Action
  #--------------------------------------------------------------------------         
  def can_execute_set_enemy_action?
     # return false if self.move_type == 3
      return true 
  end
  
  #--------------------------------------------------------------------------
  # ● Execute Set Enemy Action
  #--------------------------------------------------------------------------       
  def execute_set_enemy_action
      self.battler.make_actions
      action_id = self.battler.current_action.item.id rescue nil
      if action_id != nil
         self.skill(action_id)
      else   
         self.reset_battler_parameters
      end  
  end
  
  #--------------------------------------------------------------------------
  # ● Can Execute Actor Command
  #--------------------------------------------------------------------------          
  def can_execute_Actor_command?
      update_global_actor_commmand
      return false if !$game_temp.global_actor_command[0]
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● Execute Actor Command Turn
  #--------------------------------------------------------------------------        
  def execute_actor_command_turn
      return if $game_temp.in_turn != nil 
      $game_temp.command_index = 0 
      self.reset_battler_parameters(true)
      clear_command_paramenters
      $game_temp.command_wait = 2
      Audio.se_play("Audio/SE/" + PLAYER_ACTIVE_SE,100,100) rescue nil
      $game_temp.in_turn = self.turn_index
      $game_temp.target_turn = self
      self.battler.turn = true
      self.jump_count = 0
      self.jump_peak = 0            
      update_action_command
   end
      
end
 
 #===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase
  
  #--------------------------------------------------------------------------
  # ● Can Update Action Move?
  #--------------------------------------------------------------------------          
  def can_update_action_move?    
      update_global_action_move
      return false if self.action_movement[0] == 0
      return false if !$game_temp.global_action_move[0]
      return false if self.battler.cast_effect[0] > 0
      $game_temp.target_phase = self if $game_temp.target_phase == nil
      return false unless $game_temp.target_phase == self
      return true
  end

  #--------------------------------------------------------------------------
  # ● Update Action Move
  #--------------------------------------------------------------------------        
  def update_action_move
      $game_temp.force_reset_turn[1] = 0
      $game_temp.phase_action = true
      execute_cast_animation(false) if self.action_movement[3] == -1
      self.action_movement[3] -= 1 if self.action_movement[3] > 0
      update_jump_wait_time
      update_priority_system
      return if self.action_movement[3] > 0 
      case self.action_movement[0]
        when 1 #Move To Target
             update_action_move_to_target
        when 2 #Execute Action
             update_action_move_attack
        when 3 #Return to Position             
             update_action_return_to_position
        when 4     
             update_action_end_movement
     end     
  end
  
  #--------------------------------------------------------------------------
  # ● Update Active System
  #--------------------------------------------------------------------------   
  def update_priority_system
      return false if self.battler.is_a?(Game_Enemy)
      return false if self.action_movement[0] != 3
      self.priority_type = 2 if jump_peak > 10
  end
    
  #--------------------------------------------------------------------------
  # ● Update Jump Wait Time
  #--------------------------------------------------------------------------              
  def update_jump_wait_time
      return if self.action_movement[0] == 1
      return if self.action_movement[0] == 3
      return if self.action_movement[3] == 0
      return if self.jumping?
      self.action_movement[3] = 0
      self.jump_count = 0
      self.jump_peak = 0
  end    
     
  #--------------------------------------------------------------------------
  # ● Update Action End Movement
  #--------------------------------------------------------------------------            
  def update_action_end_movement
      clear_slow_motion
      self.action_movement[0] = 0
      self.action_movement[3] = 0
      self.battler.cast_effect = [0,1]
      $game_temp.wait_active_command = 5
      $game_temp.target_phase = nil
      check_collapsed_battlers
      turn_toward_character(self.action_movement[4]) if self.action_movement[4] != nil
      self.priority_type = self.pre_priority_type
      set_allies_directions(true)
      check_battle_end
      remove_battler_knockback
      return if can_execute_action_times?
      return if can_combo_action?      
      execute_end_action      
  end
  
  #--------------------------------------------------------------------------
  # ● Update Action Return to Position
  #--------------------------------------------------------------------------          
  def update_action_return_to_position
      self.action_movement[0] = 4
      self.pre_priority_type = self.priority_type
      self.battler.fast_breath_effect = false  
      self.jump_count = 0
      self.jump_peak = 0      
      $game_temp.on_target_size = 0
      check_target_status_pop
      clear_all_tools      
      move_to_origin
  end  
 
  #--------------------------------------------------------------------------
  # ● Update Action Move Attack
  #--------------------------------------------------------------------------          
  def update_action_move_attack
      self.action_movement[0] = 3           
      self.priority_type = self.pre_priority_type
      self.jump_count = 0
      self.jump_peak = 0
      skill = $data_skills[self.action_movement[2]] rescue nil      
      execute_action_pose
      if self.action_movement[4] != nil
         turn_toward_character(self.action_movement[4]) 
         self.shoot(self.action_movement[2])
      end         
      if self.battler.breath_effect
         self.battler.fast_breath_effect = true
      end
      if skill.note =~ /<Duration = (\d+)>/
         self.action_movement[3]= $1.to_i
      elsif skill.note =~ /<Action Type = BOOMERANG>/   
         self.action_movement[3]= 300
      else
         self.action_movement[3] = self.action.duration.to_i
      end
      if self.action_movement[3] == nil or self.action_movement[3] < 10
         self.action_movement[3] = 10
      end   
  end

  #--------------------------------------------------------------------------
  # ● Update Action Move to Target
  #--------------------------------------------------------------------------          
  def update_action_move_to_target
      check_target_alive
      skill = $data_skills[self.action_movement[2]] rescue nil
      if !can_execute_action?(skill)
         execute_break_turn
         return
      end
      set_allies_directions(false)    
      record_temp_battler_position
      self.pre_priority_type = self.priority_type
      active_skill_name
      move_to_target if self.action_movement[1] == 0      
      self.action_movement[0] = 2
      if self.battler.is_a?(Game_Actor)
         self.battler.face_phase[0] = 3
      end        
  end
  
end

#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase
  
  #--------------------------------------------------------------------------
  # ● Execute End Action
  #--------------------------------------------------------------------------              
  def execute_end_action    
      $game_temp.target_phase = nil
      $game_temp.action_phase = [false,0,0,0,true]
      $game_temp.event_wait_movement = 0
      $game_temp.skill_name[2] = 0
      $game_temp.on_target_size = 0
      clear_slow_motion
      clear_all_action(self)      
      clear_all_actions_battlers
      reset_battler_parameters
      reset_cooperation_parameters
      remove_battler_knockback
      $game_temp.action_lag_time = 4
      $game_temp.wait_active_command = 5
      $game_temp.phase_action = false   
      $game_temp.action_duration = 0
      $game_temp.tool_on_map.clear
      restore_parallax
      clear_fade    
      set_base_pose
      force_party_direction
      restore_field_parameter
      if force_next_actor?
         $game_temp.in_turn = nil 
         next_actor
      end    
  end  

  #--------------------------------------------------------------------------
  # ● Execute Break Turn
  #--------------------------------------------------------------------------            
  def execute_break_turn
      move_to_origin
      set_allies_directions(true)
      check_battle_end      
      check_collapsed_battlers
      execute_end_action  
  end  
  
  #--------------------------------------------------------------------------
  # ● Reset Battler Parameters
  #--------------------------------------------------------------------------                
  def reset_battler_parameters(turn = false)
      clear_all_action(self)
      self.battler.at = 0 unless turn
      self.battler.turn = false
      self.active = false      
      self.restore_name      
      self.battler.cast_effect = [0,1]
      self.jump_count = 0
      self.jump_peak = 0    
      self.heal = false
      self.fade = false
      self.set_base_pose
      self.force_action_times = 0
      self.force_action = ""         
      self.move_speed = self.pre_move_speed unless self.battler.dead?
  end    
  
  #--------------------------------------------------------------------------
  # ● Reset Battler Basic
  #--------------------------------------------------------------------------                
  def reset_battler_basic
      self.battler.at = 0
      self.battler.turn = false
      self.active = false      
      self.restore_name      
      self.jump_count = 0
      self.jump_peak = 0    
      self.heal = false
      self.fade = false
 end  
  
  #--------------------------------------------------------------------------
  # ● Can Execute Action
  #--------------------------------------------------------------------------            
  def can_execute_action?(skill)
      return false if skill == nil
      return false if self.action_movement[4] == nil
      return false if self.battler.mp < skill.mp_cost
      return false if self.battler.tp < skill.tp_cost
      return false if is_skill_cooperation? and !members_cooperation_alive?
      if can_execute_cooperation_skill? and self_member_cooperation?
         return false if !enough_mp_tp_for_cooperation_members?(skill)        
      end      
      return false if self.battler.cast_effect[0] > 0
      return true
  end   
  
  #--------------------------------------------------------------------------
  # ● Set Allies Direction
  #--------------------------------------------------------------------------                    
  def set_allies_directions(restore = false)
      return if $game_temp.target_actors == nil
      return if $game_temp.target_actors.empty?
      for actor in $game_temp.target_actors
          actor.set_base_pose
          next if actor.dead?
          next if actor.force_direction != 0
          if $game_temp.forced_battle and $game_temp.target_enemies.size == 1
             actor.direction = actor.pre_direction
          end  
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Set Action Times
  #--------------------------------------------------------------------------                  
  def set_action_times
      return if self.action_movement[2] == nil
      return if self.action_movement[2] == 0
      skill = $data_skills[self.action_movement[2]]
      if skill != nil and skill.note =~ /<Action Times = (\d+)>/   
         self.action_movement[6] = $1.to_i
      elsif self.battler.move_times > 0
         self.action_movement[6] = self.battler.move_times.to_i
      else
         self.action_movement[6] = 1
      end      
  end
    
  #--------------------------------------------------------------------------
  # ● Set Combo
  #--------------------------------------------------------------------------                  
  def can_combo_action?
      return false if self.action_movement[2] == nil
      return false if self.action_movement[2] == 0
      return false if self.action_movement[6] > 1
      skill = $data_skills[self.action_movement[2]]
      if skill != nil and skill.note =~ /<Combo Action = (\d+)>/   
         self.action_movement[2] = $1.to_i
         set_action_times
         $game_temp.target_phase = self
         if self.battler.is_a?(Game_Enemy)
            execute_enemy_action 
         else
            execute_actor_action
         end            
         return true
     end
     return false  
  end  
  
  #--------------------------------------------------------------------------
  # ● Move To Target
  #--------------------------------------------------------------------------          
  def move_to_target
      if self.battler.is_a?(Game_Enemy)
         self.orig_pos_x = self.x
         self.orig_pos_y = self.y
      end
      self.action_movement[3] = 60
      self.priority_type = 2
      self.jump_count = 0
      self.jump_peak = 0            
      jump_position_target      
  end    
    
  #--------------------------------------------------------------------------
  # ● Move to Origin
  #--------------------------------------------------------------------------            
  def move_to_origin 
      if self.battler.is_a?(Game_Enemy) and self.action_movement[1] == 0
         self.jump_count = 0
         self.jump_peak = 0         
         jump_origin if can_jump_origin?
      else
        wait = false
        for actor in $game_temp.target_actors
            actor.jump_count = 0
            actor.jump_peak = 0
            if actor.can_jump_origin? 
               actor.jump_origin
               wait = true
            end        
        end
        self.action_movement[3] = 60 if wait
     end
  end     
  
  #--------------------------------------------------------------------------
  # ● Can Jump Origin
  #--------------------------------------------------------------------------              
  def can_jump_origin? 
      return false if (self.x == self.orig_pos_x and self.y == self.orig_pos_y)
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● Move to Origin
  #--------------------------------------------------------------------------              
  def jump_origin
      self.jump_count = 0
      self.jump_peak = 0         
      self.action_movement[3] = 60
      self.priority_type = 2
      self.jump_position(self.x,self.y,self.orig_pos_x,self.orig_pos_y)    
  end
  
  #--------------------------------------------------------------------------
  # ● Execute Move Type
  #--------------------------------------------------------------------------          
  def execute_move_type
      skill = $data_skills[self.action_movement[2]]
      if skill == nil
         msgbox("There's no Skill ID " + self.action_movement[2].to_s + " on Database.") 
         exit
      end
      turn_toward_character(self.action_movement[4])
      self.action_movement[0] = 1
      if skill.note  =~ /<Action Type = NEAR>/
         self.action_movement[1] = 0
      else  
         self.action_movement[1] = 1         
      end  
  end
    
  #--------------------------------------------------------------------------
  # ● Need Recheck Selection
  #--------------------------------------------------------------------------            
   def need_recheck_selection?        
       return true if self.action_movement[4] == nil
       if self.action_movement[4].dead?
          skill = $data_skills[self.action_movement[2]]
          for sk in skill.effects
              if sk.code == 22 and sk.data_id == self.battler.death_state_id
                 return false
                 break
              end
          end           
          return true
      end
      return false
  end    
     
  #--------------------------------------------------------------------------
  # ● Check Target alive
  #--------------------------------------------------------------------------            
  def check_target_alive             
      if need_recheck_selection? 
         if self.battler.is_a?(Game_Actor)        
            skill = $data_skills[self.action_movement[2]]
            if skill.scope >= 7
               select_target_actor(1)
            else 
               select_target_enemy_alive(1)
            end   
          else            
             enemy_target_selection
          end  
      end   
   end  
  
  #--------------------------------------------------------------------------
  # ● Active Skill Name
  #--------------------------------------------------------------------------            
  def active_skill_name
      skill = $data_skills[self.action_movement[2]] rescue nil
      return if skill == nil
      if skill.note =~ /<Skill Name>/
         $game_temp.skill_name[0] = true
         $game_temp.skill_name[1] = skill.name
         $game_temp.skill_name[2] = 999999
      end   
  end   
   
  #--------------------------------------------------------------------------
  # ● Can Execute Action Times
  #--------------------------------------------------------------------------                    
  def can_execute_action_times?
      return false if self.action_movement[6] <= 1
      if self.battler.is_a?(Game_Enemy)
         execute_enemy_action 
         $game_temp.target_phase = self
         return true
      else
         execute_actor_action
         $game_temp.target_phase = self
         return true
     end  
     return false
  end
      
  #--------------------------------------------------------------------------
  # ● Check Collapsed Battlers
  #--------------------------------------------------------------------------                  
  def check_collapsed_battlers
      if $game_temp.target_turn != nil
         if $game_temp.command_phase == 1
            $game_temp.target_turn.select_target_enemy(0,false) 
         elsif   
            $game_temp.target_turn.select_target_actor(0,false) 
         end  
      end
      dead_enemies = []
      for enemy in $game_temp.target_enemies
          dead_enemies.push(enemy) if !enemy.can_collapse
          if enemy.battler.dead?
             enemy.execute_enemy_defeated_process if !enemy.can_collapse
             enemy.can_collapse = true 
          end
      end
      death_se = false
      for dead in dead_enemies
          death_se = true if dead.battler.dead?
      end  
      Sound.play_enemy_collapse if death_se
  end  
    
  #--------------------------------------------------------------------------
  # ● Can Refresh Next Actor
  #--------------------------------------------------------------------------                
  def force_next_actor?
     # return false if self.battler.is_a?(Game_Enemy) 
      all_max_at = true
      all_zero_at = true
      all_active = true
      for a in $game_temp.target_actors
          next if a.battler.dead?
          all_active = false if a.action_movement[0] == 0
          if a.battler.at != $game_system.at_max
             all_max_at = false 
          else   
             all_zero_at = false
          end   
      end         
      return true if all_max_at and $game_temp.in_turn == nil
      return true if all_max_at and !$game_temp.command_selection
      return true if all_zero_at and $game_temp.in_turn != nil
      return true if all_active and all_max_at
      return true if all_active and $game_temp.in_turn != nil
      return false
  end
  
  #--------------------------------------------------------------------------
  # ● Can Refresh Next Actor
  #--------------------------------------------------------------------------              
  def can_refresh_next_actor?
      return false if self.battler.is_a?(Game_Actor)
      refresh = true
      for i in $game_temp.target_actors
          refresh = false if i.battler.at >= $game_system.at_max
      end
      return true if refresh
      return false
  end
  
  #--------------------------------------------------------------------------
  # ● Can Next Actor For End Phase
  #--------------------------------------------------------------------------            
  def can_next_actor_for_end_phase?
      return false if self.battler.is_a?(Game_Enemy)
      return false if $game_temp.command_phase != 0      
      return false if $game_temp.target_turn != nil
      return true
  end  
  
  #--------------------------------------------------------------------------
  # ● Execute Cast Animation
  #--------------------------------------------------------------------------            
  def execute_cast_animation(initial = false)
      return if self.action_movement[2] == nil or self.action_movement[2] == 0
      skill = $data_skills[self.action_movement[2]]
      if skill != nil
         if skill.note=~ /<Cast Animation = (\d+)>/  
            if initial 
               self.action_movement[3] = -1
               return
            end  
            ani_id = $1.to_i
            execute_user_animation(ani_id)
            animation = $data_animations[ani_id]
            ani_duration = animation.frame_max * 4 + 1
            self.action_movement[3] = ani_duration
            if self.action_movement[3] == nil or self.action_movement[3] < 0
               self.action_movement[3] = 0
            end
         end
      end   
  end     
  
  #--------------------------------------------------------------------------
  # ● Execute User Animation
  #--------------------------------------------------------------------------              
  def execute_user_animation(skill_animation_id)
      return if skill_animation_id == nil
      if is_skill_cooperation? and members_cooperation_alive?
         execute_party_animation(skill_animation_id)
      else   
         self.animation_id = skill_animation_id
      end   
      execute_action_pose
  end
  
  #--------------------------------------------------------------------------
  # ● Check Target Status Pop
  #--------------------------------------------------------------------------            
  def check_target_status_pop
      for i in $game_temp.target_enemies
          next if i.dead?
          if i.battler.state_string_time > 0  
             i.popup_status_effect     
          end   
      end   
      for i in $game_temp.target_actors
          next if i.dead?
          if i.battler.state_string_time > 0  
             i.popup_status_effect     
          end   
      end     
  end    
  
  #--------------------------------------------------------------------------
  # ● Execute Action Pose
  #--------------------------------------------------------------------------            
  def execute_action_pose
      duration = nil
      pose = nil
      skill = $data_skills[self.action_movement[2]] rescue nil
      return if skill == nil
      reset_cooperation_pre_pose
      if skill.note =~ /<Duration = (\d+)>/
         duration = $1.to_i
      end  
      if skill.note =~ /<Pose = (\S+)>/   
         pose = $1.to_s
      end    
      if duration != nil and pose != nil
         if can_execute_cooperation_skill?
            make_members_pose(pose,duration)
         else  
            make_pose(pose,duration)
         end
      end  
  end  
  
end

#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase 
  
  #--------------------------------------------------------------------------
  # ● Can Update Action Command
  #--------------------------------------------------------------------------      
  def can_update_action_command?
      return false if self.battler.is_a?(Game_Enemy)
      return false if self.action_movement[0] > 0
      return false if self.battler.cast_effect[0] > 0
      return false if $game_temp.command_wait > 0
      return false if $game_temp.in_turn == nil
      return false if $game_temp.in_turn != self.turn_index
      return false if $game_temp.turn_sprite_phase != 0
      return false if !self.battler.turn
      return false if self.fade
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● Update Action Command
  #--------------------------------------------------------------------------    
  def update_action_command
      if self.battler.at == 0
         clear_turn_parameters
         return
      end
      $game_temp.command_selection = true
      update_target_selection_enemy
      update_target_selection_actor
      update_next_actor_command
      update_execute_command
      update_command_selection
  end

  #--------------------------------------------------------------------------
  # ● Update Command Selection
  #--------------------------------------------------------------------------      
  def update_command_selection 
      return if $game_system.escape_phase[1] > 0
      return if $game_temp.command_phase != 0
      if Input.trigger?(:DOWN) or Input.trigger?(:RIGHT)
         change_command_index(1)
         $game_temp.com_slide_type[0] = 0
      elsif Input.trigger?(:UP) or Input.trigger?(:LEFT)
         change_command_index(-1)
         $game_temp.com_slide_type[0] = 1
      end         
  end
  
  #--------------------------------------------------------------------------
  # ● Change Command Index
  #--------------------------------------------------------------------------        
  def change_command_index(value)
      Sound.play_cursor 
      $game_temp.command_index += value
      $game_temp.command_index = 0 if $game_temp.command_index > 3
      $game_temp.command_index = 3 if $game_temp.command_index < 0
  end
  
  #--------------------------------------------------------------------------
  # ● Update Execute Command
  #--------------------------------------------------------------------------      
  def update_execute_command 
      return if $game_temp.command_phase != 0
      return if $game_temp.command_wait > 0 
      return if !self.battler.turn
      if Input.trigger?(:C) and $game_system.escape_phase[1] == 0
         Sound.play_ok
         $game_system.escape_phase[1] = 0
         $game_temp.command_wait = 5         
         case $game_temp.command_index
              when 0
                if !can_use_normal_attack?
                   Sound.play_cancel
                   return
                end                
                execute_enemy_selection                 
              when 1; execute_skill_selection
              when 2; execute_guard
              when 3; execute_item_selection
         end 
      elsif Input.press?(ESCAPE_BUTTON) and $game_system.escape_phase[0]    
            update_escape_button
            return
      end
      $game_system.escape_phase[1] = 0
  end

  #--------------------------------------------------------------------------
  # ● Update Escape Button
  #--------------------------------------------------------------------------        
  def update_escape_button
      if $game_temp.target_phase != nil
         $game_system.escape_phase[1] = 1 if $game_system.escape_phase[1] == 0
         return 
      end   
      $game_system.escape_phase[1] += 1
      execute_escape if $game_system.escape_phase[1] >= 100
  end
    
  #--------------------------------------------------------------------------
  # ● Execute Command Action
  #--------------------------------------------------------------------------           
  def execute_command_action
      end_command_selection
      set_action_times
  end
  
  #--------------------------------------------------------------------------
  # ● Clear Turn Parameters
  #--------------------------------------------------------------------------             
  def clear_turn_parameters
      self.battler.at = 0
      self.active = true
      self.battler.turn = false      
      execute_cast_animation(true)
      clear_command_paramenters
  end
 
  #--------------------------------------------------------------------------
  # ● End Command Selection
  #--------------------------------------------------------------------------             
  def end_command_selection
      clear_turn_parameters
      if $game_temp.command_index == 0
         execute_base_attack
      elsif $game_temp.command_index == 1 or 
            $game_temp.command_index == 3
         execute_skill
      elsif $game_temp.command_index == 2
         execute_guard
      end
      clear_command_paramenters
  end
    
  #--------------------------------------------------------------------------
  # ● Execute Actor Action
  #--------------------------------------------------------------------------            
  def execute_actor_action      
      self.action_movement[6] -= 1
      self.action_movement[3] = 0
      self.action_movement[0] = 1 
      execute_skill
  end  
  
  #--------------------------------------------------------------------------
  # ● Can Execute Cast Phase?
  #--------------------------------------------------------------------------             
  def can_execute_cast_phase?
      skill = $data_skills[self.action_movement[2]]
      return false if skill == nil
      if skill.speed != 0
         if can_execute_cooperation_skill?
            cooperation_cast_members(skill.speed.abs)
         else
            self.set_cast_effect(skill.speed.abs)
            self.reset_battler_basic
         end
         clear_base_command(true)
         clear_command_paramenters
         set_base_pose
         next_actor          
         return true
      end  
      return false
  end   

  #--------------------------------------------------------------------------
  # ● Set Cast Effect
  #--------------------------------------------------------------------------            
  def set_cast_effect(cast_duration)
      self.battler.cast_effect[0] = cast_duration.abs
      self.battler.cast_effect[1] = cast_duration.abs    
  end  
  
  #--------------------------------------------------------------------------
  # ● Clear Base Command
  #--------------------------------------------------------------------------          
  def clear_base_command(reset_at = true)
      $game_temp.command_wait = 5 unless self.battler.is_a?(Game_Enemy)
      self.battler.at = 0 if reset_at
  end
    
  #--------------------------------------------------------------------------
  # ● Check Target Direction
  #--------------------------------------------------------------------------        
  def check_direction(user_x, user_y, target_x, target_y)
    
  end
  
end

#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase   
  
  #--------------------------------------------------------------------------
  # ● Update Next Actor
  #--------------------------------------------------------------------------      
  def update_next_actor_command
      return if $game_system.escape_phase[1] > 0
      return if $game_temp.command_wait > 0
      return if $game_temp.command_phase != 0
      if Input.trigger?(:R) or Input.trigger?(:B)
         next_actor(1)
      elsif Input.trigger?(:L)
         next_actor(-1)
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Next Actor
  #--------------------------------------------------------------------------        
  def next_actor(value = 1)    
      $game_temp.command_selection = false
      $game_temp.command_index = 0
      Sound.play_cursor
      if $game_temp.in_turn != nil
      for i in 0...$game_temp.target_actors.size
              $game_temp.in_turn += value
              $game_temp.in_turn = 0 if $game_temp.in_turn >= $game_temp.target_actors.size
              $game_temp.in_turn = $game_temp.target_actors.size - 1 if $game_temp.in_turn < 0
              next if $game_temp.target_actors[$game_temp.in_turn].battler.dead?
              next if $game_temp.target_actors[$game_temp.in_turn].battler.at < $game_system.at_max
              $game_temp.target_actors[$game_temp.in_turn].battler.turn = true
              $game_temp.target_actors[$game_temp.in_turn].knock_back_duration = nil
              $game_temp.target_turn = $game_temp.target_actors[$game_temp.in_turn]
              Audio.se_play("Audio/SE/" + PLAYER_ACTIVE_SE,100,100) rescue nil
              $game_temp.com_slide_type[1] = true
              break
      end     
      if $game_temp.target_actors[$game_temp.in_turn] == self 
         clear_command_paramenters
         self.battler.at = (80 * $game_system.at_max / 100).truncate
      end            
      end
      $game_temp.command_selection = false
      clear_base_command(false)
      self.battler.turn = false      
      self.active = false
      $game_temp.command_wait = 5 unless self.battler.is_a?(Game_Enemy)
      $game_temp.help_text = [true, ""]
      reset_actor_turn if $game_temp.in_turn == nil
  end
    
  #--------------------------------------------------------------------------
  # ● Reset Actor  turn
  #--------------------------------------------------------------------------          
  def reset_actor_turn
      for actor in $game_temp.target_actors
          actor.battler.turn = false
          actor.active  = false
      end
  end
  
end

#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase   
  
  #--------------------------------------------------------------------------
  # ● Execute Enemy Selection
  #--------------------------------------------------------------------------          
  def execute_enemy_selection
      $game_temp.command_phase = 1
      select_target_enemy
  end  

  #--------------------------------------------------------------------------
  # ● Update Target Selection Enemy
  #--------------------------------------------------------------------------        
  def update_target_selection_enemy
      return if $game_temp.command_phase != 1
      if Input.trigger?(:DOWN) or Input.trigger?(:RIGHT)
         select_target_enemy(1)
      elsif Input.trigger?(:UP) or Input.trigger?(:LEFT)
         select_target_enemy(-1)
       elsif Input.trigger?(:C)
         if self.action_movement[4] != nil and self.action_movement[4].fade
            Sound.play_buzzer
            return
         end  
         Sound.play_ok
         execute_command_action
      elsif Input.trigger?(:B)   
         cancel_selection
      end        
  end
  
  #--------------------------------------------------------------------------
  # ● Cancel Selection
  #--------------------------------------------------------------------------          
  def cancel_selection
      Sound.play_cancel
      $game_temp.command_wait = 5
      $game_temp.help_text = [true, ""]
      case $game_temp.command_index
           when 0; $game_temp.command_phase = 0
           when 1; $game_temp.command_phase = 3
           when 2; $game_temp.command_phase = 5
           when 3; $game_temp.command_phase = 4 
      end  
  end
    
  #--------------------------------------------------------------------------
  # ● Select Target Enemy
  #--------------------------------------------------------------------------          
  def select_target_enemy(value = 0,cursor_se = true)   
      Sound.play_cursor if cursor_se
      targets = []
      for i in $game_temp.target_enemies
          targets.push(i) if !i.battler.dead?
      end      
      skill = $data_skills[self.action_movement[2]]
      if skill != nil 
         if skill.scope == 2            
            self.action_movement[4] = targets[0]
            execute_command_action
            Sound.play_ok
            return          
          elsif skill.scope.between?(3,6)
            self.action_movement[4] = targets[rand(targets.size)]
            execute_command_action
            Sound.play_ok
            return             
         end
      end            
      $game_temp.battle_target_index += value
      $game_temp.battle_target_index = 0 if $game_temp.battle_target_index >= targets.size
      $game_temp.battle_target_index = targets.size - 1 if $game_temp.battle_target_index < 0
      self.action_movement[4] = targets[$game_temp.battle_target_index]
      self.turn_toward_character(targets[$game_temp.battle_target_index]) rescue nil
      $game_temp.refresh_target_name = true
      execute_guard if self.action_movement[4] == nil
  end  
  
  #--------------------------------------------------------------------------
  # ● Select Target Enemy
  #--------------------------------------------------------------------------          
  def select_target_enemy_alive(value = 0)   
      targets = []
      for i in $game_temp.target_enemies
          targets.push(i) if !i.battler.dead?
      end      
      self.action_movement[4] = targets[0]
      self.turn_toward_character(targets[0]) rescue nil
      execute_break_turn if self.action_movement[4] == nil
  end    
  
end

#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase   
  
  #--------------------------------------------------------------------------
  # ● Execute Actor Selection
  #--------------------------------------------------------------------------          
  def execute_actor_selection
      $game_temp.command_phase = 2      
      select_target_actor
  end

  #--------------------------------------------------------------------------
  # ● Update Target Selection Actor
  #--------------------------------------------------------------------------        
  def update_target_selection_actor
      return if $game_temp.command_phase != 2
      if Input.trigger?(:DOWN) or Input.trigger?(:RIGHT)
         select_target_actor(1)
      elsif Input.trigger?(:UP) or Input.trigger?(:LEFT)
         select_target_actor(-1)
       elsif Input.trigger?(:C)
           if self.action_movement[4] != nil and self.action_movement[4].fade
              Sound.play_buzzer
              return
           end           
           Sound.play_ok
           skill = $data_skills[self.action_movement[2]]
           if skill.scope.between?(9,10)
              if !self.action_movement[4].battler.dead?
                 Sound.play_buzzer
                 return  
              end
           else    
              if self.action_movement[4].battler.dead?
                 Sound.play_buzzer
                 return               
              end            
           end
           execute_command_action         
      elsif Input.trigger?(:B)
         cancel_selection
      end
  end

  #--------------------------------------------------------------------------
  # ● Select Target Actor
  #--------------------------------------------------------------------------          
  def select_target_actor(value = 0,cursor_se = true)
      Sound.play_cursor if cursor_se
      skill = $data_skills[self.action_movement[2]]
      if skill != nil and (skill.scope == 8 or 
         skill.scope == 10 or skill.scope == 11)
         Sound.play_ok
         self.action_movement[4] = self
         execute_command_action
         return
      end
      targets = []
      for i in $game_temp.target_actors
          targets.push(i)
      end
      $game_temp.battle_target_index += value
      $game_temp.battle_target_index = 0 if $game_temp.battle_target_index >= targets.size
      $game_temp.battle_target_index = targets.size - 1 if $game_temp.battle_target_index < 0
      self.action_movement[4] = targets[$game_temp.battle_target_index]
      self.turn_toward_character(targets[$game_temp.battle_target_index]) rescue nil
      $game_temp.refresh_target_name = true
      execute_guard if self.action_movement[4] == nil
  end  

end 

#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase   
  
  #--------------------------------------------------------------------------
  # ● Execute Base Attack Command
  #--------------------------------------------------------------------------        
  def execute_base_attack
      return if self.action_movement[4] == nil     
      if !can_use_normal_attack?
         self.reset_battler_parameters
         next_actor
         return 
      end   
      self.active = true      
      execute_move_type
  end  
  
  #--------------------------------------------------------------------------
  # ● Can Use Normal Attack
  #--------------------------------------------------------------------------          
  def can_use_normal_attack?
      return false if self.battler.cast_effect[0] > 0
      weapon = self.battler.equips[0]
      return false if weapon == nil
      weapon.note =~ /<Action ID = (\d+)>/
      action_id = $1.to_i
      return false if action_id == nil or action_id == 0
      self.action_movement[2] = action_id
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● Set Direction
  #--------------------------------------------------------------------------            
  def execute_skill_selection
      $game_temp.command_phase = 3
  end  

  #--------------------------------------------------------------------------
  # ● Execute Skill
  #--------------------------------------------------------------------------                
  def execute_skill
      $game_temp.command_phase = 0    
      execute_move_type
      self.action_movement[6] = 1 if can_execute_cast_phase?
  end
  #--------------------------------------------------------------------------
  # ● Execute Item Selection
  #--------------------------------------------------------------------------            
  def execute_item_selection
      $game_temp.command_phase = 4
  end  

  #--------------------------------------------------------------------------
  # ● Execute Item
  #--------------------------------------------------------------------------                
  def execute_item
      $game_temp.command_phase = 0   
      execute_move_type
  end  
  
  #--------------------------------------------------------------------------
  # ● Execute Guard Selection
  #--------------------------------------------------------------------------          
  def execute_guard
      self.reset_battler_parameters
      self.battler.guard_effect = true      
      clear_base_command(true)
      clear_command_paramenters
      $game_temp.in_turn = nil
      $game_temp.target_turn = nil
  end  
  
  #--------------------------------------------------------------------------
  # ● Execute Escape
  #--------------------------------------------------------------------------          
  def execute_escape  
      clear_base_command(true)
      clear_command_paramenters
      $game_temp.turn_sprite_phase = 3
      for i in $game_temp.target_enemies
          i.fade = true 
          i.through = true
          i.disabled = true          
          i.erase if i.battler.dead?   
      end
      execute_result
  end  
  
end

#===============================================================================
# ■ Game Player
#===============================================================================
class Game_Player < Game_Character
  
  #--------------------------------------------------------------------------
  # ● Can Update ABS Command?
  #--------------------------------------------------------------------------                 
  def can_update_abs_command?
      return false if !$game_system.abs_tool_command
      return false if $game_temp.battle_phase[0]   
      return false if $game_map.interpreter.running?
      return false if $game_temp.one_sec_lag > 0
      return false if self.battler == nil
      return false if @vehicle_getting_on || @vehicle_getting_off
      return false if $game_player.transparent
      return false if self.action != nil        
      return true
  end    
  
  #--------------------------------------------------------------------------
  # ● Update Abs System
  #--------------------------------------------------------------------------                  
  def update_abs_command
      if Input.trigger?(XAS_TOOL::TOOL_BUTTON)
         execute_abs_action_command
      elsif Input.trigger?(XAS_TOOL::SHIFT_L_TOOL_BUTTON)
         change_tool_id(-1)
      elsif Input.trigger?(XAS_TOOL::SHIFT_R_TOOL_BUTTON)
         change_tool_id(1)
      elsif Input.trigger?(XAS_TOOL::SHIFT_LEADER_BUTTON)
         change_leader_command
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Change Leader
  #--------------------------------------------------------------------------                    
  def change_leader_command
      Sound.play_cursor
      actor_id = $game_player.battler.id    
      $game_party.change_leader
      $game_temp.tool_slide_side = 0
  end
  
  #--------------------------------------------------------------------------
  # ● Change Tool ID
  #--------------------------------------------------------------------------                    
  def change_tool_id(value = 0)
      return if self.battler.tool_id[0].size == 0
      $game_temp.tool_slide_side = value
      Sound.play_equip
      self.battler.tool_id[1] += value
      self.battler.tool_id[1] = (self.battler.tool_id[0].size - 1) if self.battler.tool_id[1] < 0
      self.battler.tool_id[1] = 0 if self.battler.tool_id[1] >= self.battler.tool_id[0].size
  end
  
  #--------------------------------------------------------------------------
  # ● Execute ABS Action Command
  #--------------------------------------------------------------------------                   
  def execute_abs_action_command
      action_id = self.battler.tool_id[0][self.battler.tool_id[1]]
      return if action_id == nil
      $game_player.shoot(action_id)
  end
      
end

#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ MOVEMENT - DIAGONAL MOVEMENT
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


#===============================================================================
# ■ Game Character
#===============================================================================
class Game_CharacterBase
  
  #--------------------------------------------------------------------------
  # ● Set Direction
  #--------------------------------------------------------------------------          
   alias diagonal_set_direction set_direction
   def set_direction(d)
       diagonal_set_direction(d)
       @diagonal_direction = 0
       reset_diagonal
   end
   
end   

#===============================================================================
# ■  Game Character
#===============================================================================
class Game_Character < Game_CharacterBase
  
  attr_accessor :diagonal
  attr_accessor :diagonal_direction
  attr_accessor :sprite_angle_enable
  attr_accessor :diagonal_time
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------        
  alias diagonal_initialize initialize
  def initialize
      diagonal_initialize
      @diagonal = false
      @diagonal_direction = 0
      @sprite_angle_enable = false
      @diagonal_time = 0
  end  
    
  #--------------------------------------------------------------------------
  # ● Reset Diagonal
  #--------------------------------------------------------------------------            
  def reset_diagonal
      return if @direction_fix
      return if @diagonal == false
      @diagonal_direction = 0    
      @diagonal_time = 0
      @angle = 0 if @sprite_angle_enable
  end  
  
  #--------------------------------------------------------------------------
  # ● Enable Diagonal
  #--------------------------------------------------------------------------            
  def enable_diagonal(dir = 0)
     return if @direction_fix
     return if @diagonal == false
     return if dir == 0
     @diagonal_direction = dir
     @diagonal_time = 5
     @angle = 315 if @sprite_angle_enable and @tool_id > 0
  end  
  
  #--------------------------------------------------------------------------
  # ● Turn Upper Right
  #--------------------------------------------------------------------------  
  def turn_upper_right
      enable_diagonal(9)
      @direction = 8 unless @direction_fix
  end  
  
  #--------------------------------------------------------------------------
  # ● Turn Upper Left
  #--------------------------------------------------------------------------  
  def turn_upper_left
      enable_diagonal(7)
      @direction = 4 unless @direction_fix
  end   
  
  #--------------------------------------------------------------------------
  # ● Turn Lower Right
  #--------------------------------------------------------------------------  
  def turn_lower_right
      enable_diagonal(3)
      @direction = 6 unless @direction_fix
  end      
  
  #--------------------------------------------------------------------------
  # ● Turn Lower Left
  #--------------------------------------------------------------------------  
  def turn_lower_left
      enable_diagonal(1)
      @direction = 2 unless @direction_fix
  end   
    
  #--------------------------------------------------------------------------
  # ● Move forward
  #--------------------------------------------------------------------------                
  alias diagonal_move_forward move_forward
  def move_forward
      return if move_forward_diagonal?
      diagonal_move_forward
  end
  
  #--------------------------------------------------------------------------
  # ● Move forward Diagonal?
  #--------------------------------------------------------------------------                  
  def move_forward_diagonal?
      return false if !@diagonal
      if @diagonal_direction != 0
         case @diagonal_direction
              when 1 #Lower Left
                 move_diagonal(4, 2)
                 @direction = 2
              when 3 #Lower Right
                 move_diagonal(6, 2)
                 @direction = 6
              when 7 #Upper Left
                 move_diagonal(4, 8)
                 @direction = 4
              when 9 #Upper Right
                 move_diagonal(6, 8)
                 @direction = 8
          end
          enable_diagonal(@diagonal_direction)
         return true
      end  
      return false
  end
  
  #--------------------------------------------------------------------------
  # ● Move Backward
  #--------------------------------------------------------------------------                
  alias diagonal_move_backward move_backward
  def move_backward
      return if move_backward_diagonal?
      diagonal_move_backward
  end
  
  #--------------------------------------------------------------------------
  # ● Move Backward Diagonal?
  #--------------------------------------------------------------------------                  
  def move_backward_diagonal?
      return false if @diagonal == false
      if @diagonal_direction != 0
         last_direction_fix = @direction_fix
         @direction_fix = true       
         case @diagonal_direction
              when 1
                 move_diagonal(6, 8)
                 @direction = 6
              when 3
                 move_diagonal(4, 8)
                 @direction = 4
              when 7
                 move_diagonal(6, 2)
                 @direction = 6
              when 9         
                 move_diagonal(4, 2)
                 @direction = 2
         end
         enable_diagonal(@diagonal_direction)      
         @direction_fix = last_direction_fix
         return true
      end  
      return false
  end  
  
  #--------------------------------------------------------------------------
  # ● Turn Toward Player
  #--------------------------------------------------------------------------
  alias turn_toward_player_diagonal turn_toward_player
  def turn_toward_player
      if @diagonal
         diagonal_turn_toward_player
         return 
      end
      turn_toward_player_diagonal
  end  
  
  #--------------------------------------------------------------------------
  # ● Diagonal Turn Toward Player
  #-------------------------------------------------------------------------- 
  def diagonal_turn_toward_player
      sx = distance_x_from($game_player.x)
      sy = distance_y_from($game_player.y)
      sd = sx.abs - sy.abs
      sdx = sd.abs - sx.abs
      sdy = sd.abs - sy.abs
      return if sx == 0 and sy == 0
      #Turn Upper Right
      if sx < 0 and sy > 0
         if sx.abs > sy.abs and sdx.abs < sd.abs
            set_direction(6)
         elsif sx.abs < sy.abs and sdy.abs < sd.abs
            set_direction(8) 
         else
            turn_upper_right
         end
         enable_diagonal(9)
      #Turn Upper Left
      elsif sx > 0 and sy > 0
         if sx.abs > sy.abs and sdx.abs < sd.abs
            set_direction(4)
         elsif sx.abs < sy.abs and sdy.abs < sd.abs
            set_direction(8)            
         else
            set_direction(4)
            turn_upper_left
         end
         enable_diagonal(7)  
      #Turn Lower Left  
      elsif sx > 0 and sy < 0
         if sx.abs > sy.abs and sdx.abs < sd.abs
            set_direction(4)
         elsif sx.abs < sy.abs and sdy.abs < sd.abs
            set_direction(2)         
         else                    
            turn_lower_left
         end
         enable_diagonal(1)   
       #Turn Lower Right    
       elsif sx < 0 and sy < 0         
         if sx.abs > sy.abs and sdx.abs < sd.abs
            set_direction(6)
         elsif sx.abs < sy.abs and sdy.abs < sd.abs
            set_direction(2)           
         else        
            turn_lower_right
         end
         enable_diagonal(3) 
      elsif sx < 0 
         set_direction(6)
      elsif sx > 0 
         set_direction(4)
      elsif sy > 0 
         set_direction(8)
      elsif sy < 0 
         set_direction(2)   
      end     
  
  end  
 
  #--------------------------------------------------------------------------
  # ● Move toward Player
  #--------------------------------------------------------------------------
  alias move_toward_player_diagonal move_toward_player
  def move_toward_player
      if @diagonal 
         diagonal_move_toward_player
         return  
      end
      move_toward_player_diagonal
  end   
   
  #--------------------------------------------------------------------------
  # ● Diagonal Move Toward Player
  #--------------------------------------------------------------------------  
  def diagonal_move_toward_player
      if self.target_2 != nil
         sx = distance_x_from(self.target_2.x)
         sy = distance_y_from(self.target_2.y)
      else
         sx = distance_x_from($game_player.x)
         sy = distance_y_from($game_player.y)        
      end  
      if sx == 0 and sy == 0
         return
      end
      abs_sx = sx.abs
      abs_sy = sy.abs
      if abs_sx == abs_sy
        rand(2) == 0 ? abs_sx += 1 : abs_sy += 1
      end
      if abs_sx
         if sx < 0 and sy > 0
            move_diagonal(6, 8)
            move_random unless moving?
            enable_diagonal(9) 
         elsif sx > 0 and sy > 0
            move_diagonal(4, 8)
            move_random unless moving?
            enable_diagonal(7) 
         elsif sx > 0 and sy < 0
            move_diagonal(4, 2)
            move_random unless moving?
            enable_diagonal(1) 
         elsif sx < 0 and sy < 0
            move_diagonal(6, 2)
            move_random unless moving?
            enable_diagonal(3) 
         elsif sx < 0 
            move_straight(6)
         elsif sx > 0 
            move_straight(4)
         elsif sy > 0 
            move_straight(8)
         elsif sy < 0 
            move_straight(2)
         end
         if abs_sx != 1 and abs_sy != 1
            move_random unless moving?
         end  
      end
 end
  
  #--------------------------------------------------------------------------
  # ● Diagonal Move Toward Target
  #--------------------------------------------------------------------------   
  def diagonal_move_toward_target
      return if self.target_2 == nil
      sx = distance_x_from(self.target_2.x)
      sy = distance_y_from(self.target_2.y)
      if sx == 0 and sy == 0
         return
      end
      abs_sx = sx.abs
      abs_sy = sy.abs
      if abs_sx == abs_sy
        rand(2) == 0 ? abs_sx += 1 : abs_sy += 1
      end
      if abs_sx
         if sx < 0 and sy > 0
            move_diagonal(6, 8)
            move_random unless moving?
            enable_diagonal(9) 
         elsif sx > 0 and sy > 0
            move_diagonal(4, 8)
            move_random unless moving?
            enable_diagonal(7) 
         elsif sx > 0 and sy < 0
            move_diagonal(4, 2)
            move_random unless moving?
            enable_diagonal(1) 
         elsif sx < 0 and sy < 0
            move_diagonal(6, 2)
            move_random unless moving?
            enable_diagonal(3) 
         elsif sx < 0 
            move_straight(6)
         elsif sx > 0 
            move_straight(4)
         elsif sy > 0 
            move_straight(8)
         elsif sy < 0 
            move_straight(2)
         end
         if abs_sx != 1 and abs_sy != 1
            move_random unless moving?
         end  
      end
 end 
 
 #--------------------------------------------------------------------------
 # ● turn_right_45
 #--------------------------------------------------------------------------      
 def turn_right_45
     if @diagonal and @diagonal_direction != 0     
        case @diagonal_direction
          when 1;  set_direction(4) 
          when 3;  set_direction(2)
          when 7;  set_direction(8)
          when 9;  set_direction(6)  
        end
     else  
        case @direction
          when 2;  turn_lower_left
          when 4;  turn_upper_left
          when 6;  turn_lower_right
          when 8;  turn_upper_right
        end
     end  
 end

 #--------------------------------------------------------------------------
 # ● turn_left_45
 #--------------------------------------------------------------------------  
 def turn_left_45
     if @diagonal and @diagonal_direction != 0     
        case @diagonal_direction
          when 1;  set_direction(2) 
          when 3;  set_direction(6)
          when 7;  set_direction(4)
          when 9;  set_direction(8)
        end
     else  
        case @direction
          when 2;  turn_lower_right
          when 4;  turn_lower_left
          when 6;  turn_upper_right
          when 8;  turn_upper_left
        end
     end  
 end 
 
 #--------------------------------------------------------------------------
 # ● turn_right_90
 #--------------------------------------------------------------------------   
 alias diagonal_turn_right_90 turn_right_90
  def turn_right_90
      if @diagonal and @diagonal_direction != 0
         turn_diagonal_right_90
         return
      end  
      diagonal_turn_right_90
  end
  
 #--------------------------------------------------------------------------
 # ● turn_diagonal_right_90
 #--------------------------------------------------------------------------    
  def turn_diagonal_right_90
      case @diagonal_direction
         when 1;  turn_upper_left
         when 3;  turn_lower_left
         when 7;  turn_upper_right
         when 9;  turn_lower_right
      end
  end
    
 #--------------------------------------------------------------------------
 # ● turn_left_90
 #--------------------------------------------------------------------------    
  alias diagonal_turn_left_90 turn_left_90
  def turn_left_90
      if @diagonal and @diagonal_direction != 0
         turn_diagonal_left_90
         return 
      end
      diagonal_turn_left_90
  end  
    
 #--------------------------------------------------------------------------
 # ● turn_diagonal_left_90
 #--------------------------------------------------------------------------    
  def turn_diagonal_left_90
      case @diagonal_direction
         when 1;  turn_lower_right
         when 3;  turn_upper_right
         when 7;  turn_lower_left
         when 9;  turn_upper_left
      end
  end     
    
  #--------------------------------------------------------------------------
  # ● diagonal_turn_180
  #--------------------------------------------------------------------------
  alias diagonal_turn_180 turn_180
  def turn_180  
      if @diagonal and @diagonal_direction != 0
         turn_diagonal_180 
         return
      end
      diagonal_turn_180
  end
  
 #--------------------------------------------------------------------------
 # ● turn_diagonal_180 
 #--------------------------------------------------------------------------    
  def turn_diagonal_180 
      case @diagonal_direction
         when 1;  turn_upper_right
         when 3;  turn_upper_left
         when 7;  turn_lower_right
         when 9;  turn_lower_left
      end
  end  
    
 #--------------------------------------------------------------------------
 # ● turn_random
 #--------------------------------------------------------------------------    
  alias diagonal_turn_random turn_random
  def turn_random
      if @diagonal 
         turn_diagonal_random
         return 
      end  
      diagonal_turn_random 
  end  
  
 #--------------------------------------------------------------------------
 # ● turn_diagonal_random
 #--------------------------------------------------------------------------    
  def turn_diagonal_random
      d = rand(8)
      case d
          when 0;  set_direction(8) 
          when 1;  set_direction(6) 
          when 2;  set_direction(4) 
          when 3;  set_direction(2) 
          when 4;  turn_lower_left  
          when 5;  turn_lower_right
          when 6;  turn_upper_left  
          when 7;  turn_upper_right
      end
  end 
 
end    

#===============================================================================
# ■ Game_Player
#===============================================================================
class Game_Player < Game_Character
  
  #--------------------------------------------------------------------------
  # ● Move By Input
  #--------------------------------------------------------------------------        
  alias schala_movable? movable?
  def movable?
      return false if $game_temp.battle_phase[0]
      return false if $game_temp.one_sec_lag > 0
      schala_movable?
  end
  
  #--------------------------------------------------------------------------
  # ● Update Scroll
  #--------------------------------------------------------------------------      
  alias lock_screen_update_scroll update_scroll
  def update_scroll(last_real_x, last_real_y)
      if $game_temp.pre_battle_phase == 0
         return if $game_temp.battle_phase[0]
      end
      lock_screen_update_scroll(last_real_x, last_real_y)
  end
  
end

#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ MOVEMENT - FORCE ACTION
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase 
  
  #--------------------------------------------------------------------------
  # ● moving 2? 
  #--------------------------------------------------------------------------  
  def moving2?
      @real_x != @x || @real_y != @y
  end   
  
  #--------------------------------------------------------------------------
  # ● Can Force Action?
  #--------------------------------------------------------------------------          
  def can_force_action?
      return false if @force_action_times == 0      
      return false if self.jumping?
      return false if self.knockbacking?
      return false if self.stop
      return false if $game_temp.hookshot_phase == 2
      unless @force_action == "All Shoot" or @force_action == "Four Shoot"  
         return false if self.moving2?
      end   
      return true
  end

  #--------------------------------------------------------------------------
  # ● Update Force Action
  #--------------------------------------------------------------------------        
  def update_force_action
      @force_action_times -= 1
      execute_force_action
      if @tool_id > 0 and (@tool_effect != "" or @hookshot) 
         execute_force_action_tool_effect
      end
      reset_auto_action if @force_action_times == 0 
  end 
  
  #--------------------------------------------------------------------------
  # ● Execute Force Action
  #--------------------------------------------------------------------------          
  def execute_force_action  
      case @force_action
        when "Forward" 
            move_forward
        when "Backward" 
            move_backward
        when "Toward Player"   
            move_toward_player 
        when "Move Left"    
            move_straight(4)
        when "Move Right"
            move_straight(6)
        when "Move Up"    
            move_straight(8)
        when "Move Down"
            move_straight(2)
        when "Target"   
            unless self.target_2.x == self.x and self.target_2.y == self.y
                 diagonal_move_toward_target
            else
                 move_forward
                 @force_action = "Forward" 
            end 
        when "Boomerang"
             if self.target_2.x == self.x and self.target_2.y == self.y
                if self.target_2 == self.action.user
                   self.action.user.action_movement[3] = 10
                   self.action.duration = 10
                   @force_action_times = 0
                end  
                self.target_2 = self.action.user
             end
             diagonal_move_toward_target
        when "All Shoot"  
              if self.action != nil
                 turn_right_45
                 self.shoot(self.action.id) unless @force_action_times == 0
              end
        when "Four Shoot"  
              if self.action != nil
                 turn_right_90
                 self.shoot(self.action.id) unless @force_action_times == 0
              end               
        when "Three Shoot"  
              if self.action != nil
                 case @force_action_times
                     when 2
                       turn_right_45
                     when 1
                       turn_left_90
                     when 0
                       turn_right_45
                 end  
                 self.shoot(self.action.id) unless @force_action_times == 0
              end       
        when "Two Shoot"  
              if self.action != nil
                 turn_180
                 self.shoot(self.action.id) unless @force_action_times == 0
              end   
        end  
  end  
  
  #--------------------------------------------------------------------------
  # ● Execute Force Action Tool Effect
  #--------------------------------------------------------------------------
  def execute_force_action_tool_effect 
      action_effect_during_move     
      action_effect_after_move if @force_action_times == 0
  end  
  
  #--------------------------------------------------------------------------
  # ● Auto Action Effect During Move
  #--------------------------------------------------------------------------            
  def reset_auto_action  
      @force_action = ""
      @force_action_times = 0
      @anime_count = 0
  end
  
  #--------------------------------------------------------------------------
  # ● Action Effect During Move
  #--------------------------------------------------------------------------          
  def action_effect_during_move    
  end  

  #--------------------------------------------------------------------------
  # ● Action Effect After Move
  #--------------------------------------------------------------------------            
  def action_effect_after_move
  end      
      
end  


 
#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase
  
  #--------------------------------------------------------------------------
  # ● Action Effect During Move
  #--------------------------------------------------------------------------          
  alias hookshot_effect_action_effect_during_move action_effect_during_move  
  def action_effect_during_move
      hookshot_effect_action_effect_during_move
      if @hookshot and @force_action == "Toward Player"  
         if @x == $game_player.x and @y == $game_player.y
            if $game_player.action != nil
               $game_player.action.duration = 2        
            end   
            $game_player.make_pose("",2)
            self.action.duration = 10
            self.opacity = 0
          end 
       #   self.move_toward_player 
      elsif @tool_effect == "Hookshot_Event"   
            case @direction
               when 2
                 xh = @x 
                 yh = @y - 1
               when 4
                 xh = @x + 1 
                 yh = @y
               when 6
                 xh = @x - 1
                 yh = @y           
               when 8
                 xh = @x
                 yh = @y + 1         
           end
           unless $game_player.moving2?   
              if xh == $game_player.x and yh == $game_player.y
                  if $game_player.action != nil
                     $game_player.action.duration = 2               
                  end   
                  $game_player.make_pose("",2)
                  if self.action != nil
                     self.action.duration = 10
                  end
                  @force_action_times = 0
                  @force_action_type = ""     
                  $game_temp.hookshot = false
              end           
           end 
      end
  end  
  
  #--------------------------------------------------------------------------
  # ● Action EffectAfter Move
  #--------------------------------------------------------------------------            
  alias hookshot_action_effect_after_move action_effect_after_move
  def action_effect_after_move
      hookshot_action_effect_after_move
      if @hookshot
         @force_action_times = 30
         @force_action = "Toward Player"
         @direction_fix = true
      end     
  end     
  
  #--------------------------------------------------------------------------
  # ● Can Update Battler Move Speed
  #--------------------------------------------------------------------------                  
#  alias hookshot_can_update_battler_move_speed can_update_battler_move_speed?
#  def can_update_battler_move_speed?  
#      return false if $game_temp.hookshot
#      hookshot_can_update_battler_move_speed
#  end  

end
 
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ MOVEMENT - EXTRA MOVEMENT
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase
  
  #--------------------------------------------------------------------------
  # ● Flash
  #--------------------------------------------------------------------------           
  def flash(red,green,blue, duration, opacity = 255)
      $game_map.screen.start_flash(Color.new(red,green,blue,opacity), duration)
  end  
 
  #--------------------------------------------------------------------------
  # ● Jump Center Screen
  #--------------------------------------------------------------------------           
  def jump_center_screen
      jump_position(self.x, self.y, $game_player.cx, $game_player.cy)
  end  
  
  #--------------------------------------------------------------------------
  # ● Moveto Random
  #--------------------------------------------------------------------------         
  def moveto_random(rand_x, rand_y, user)    
      if self.tool_id > 0 and user
         p_range_x = self.action.user.x - rand_x 
         p_range_y = self.action.user.y - rand_y          
      else
         p_range_x = self.x - rand_x
         p_range_y = self.y - rand_y 
      end
      rand_x2 = rand_x * 2
      rand_y2 = rand_y * 2
      moveto(p_range_x + rand(rand_x2),p_range_x + rand(rand_x2))      
  end
  
  #--------------------------------------------------------------------------
  # ● Moveto Random Scren
  #--------------------------------------------------------------------------           
  def moveto_random_screen
      rx = rand(15)
      ry = rand(11)
      rgx = ($game_player.cx - $game_player.center_x) + 1
      rgy = ($game_player.cy - $game_player.center_y) + 1
      moveto(rgx + rx, rgy + ry)
  end
  
  #--------------------------------------------------------------------------
  # ● jump Near Player
  #--------------------------------------------------------------------------  
  def jump_near_player
      pre_pos = [self.x,self.y]
      moveto($game_player.x,$game_player.y)
      60.times do
         move_random
         break if self.x != $game_player.x or self.y != $game_player.y
       end  
       4.times do 
         move_random
       end
       pre_pos2 = [self.x,self.y]
       moveto(pre_pos[0],pre_pos[1])
       return if pre_pos2[0] == $game_player.x and pre_pos2[1] == $game_player.y
       self.jump_position(self.x,self.y,pre_pos2[0],pre_pos2[1])         
  end  
  
  #--------------------------------------------------------------------------
  # ● Jump_position
  #--------------------------------------------------------------------------        
  def jump_position(user_x, user_y, target_x, target_y,high = 10)
      self.jump_count = 0
      self.jump_peak = 0    
      nx = target_x - user_x
      ny = target_y - user_y
      nx = (real_cx - user_x) if user_x + nx < real_cx
      nx = (real_cx_max - user_x) if user_x + nx > real_cx_max
      ny = (real_cy - user_y) if user_y + ny < real_cy
      ny = (real_cy_max - user_y) if user_y + ny > real_cy_max
      jump_high(nx,ny,high)
  end  
  
  #--------------------------------------------------------------------------
  # ● Jump_pos
  #--------------------------------------------------------------------------        
  def jump_pos(target_x, target_y,high = 10)
      self.jump_count = 0
      self.jump_peak = 0    
      nx = target_x - self.x
      ny = target_y - self.y
      nx = (real_cx - self.x) if self.x + nx < real_cx
      nx = (real_cx_max - self.x) if self.x + nx > real_cx_max
      ny = (real_cy - self.y) if self.y + ny < real_cy
      ny = (real_cy_max - self.y) if self.y + ny > real_cy_max      
      jump_high(nx,ny,high)
  end     
  
  #--------------------------------------------------------------------------
  # ● Jump Target
  #--------------------------------------------------------------------------          
  def jump_target(high = 10)
      return if self.target_2 == nil
      nx = self.target_2.x - self.x
      ny = self.target_2.y - self.y
      jump_high(nx,ny,high)    
  end
  
  #--------------------------------------------------------------------------
  # ● Passable Position
  #--------------------------------------------------------------------------          
  def passable_position?(x, y, d)
      return false unless $game_map.valid?(x, y)  
      return true if @through || debug_through?
      return false unless map_passable?(x, y, d)
      return false unless map_passable?(x, y, reverse_dir(d))
      for i in $game_temp.target_actors
          return false if (x == i.x and y == i.y)
      end  
      for e in $game_temp.target_enemies
          return false if !e.battler.dead? and (x == e.x and y == e.y)
      end        
      return false if collide_with_characters?(x, y)
      return true
  end  
  
  #--------------------------------------------------------------------------
  # ● Jump_position target
  #--------------------------------------------------------------------------        
  def jump_position_target
      return if self.action_movement[4] == nil 
      turn_toward_character(self.action_movement[4])
      target_x = self.action_movement[4].x
      target_y = self.action_movement[4].y
      self.jump_count = 0
      self.jump_peak = 0 
      nx = self.action_movement[4].x - self.x
      ny = self.action_movement[4].y - self.y
      jump_high(nx ,ny ,10) 
      turn_toward_character(self.action_movement[4])
  end      
  
  #--------------------------------------------------------------------------
  # ● Jump_high
  #--------------------------------------------------------------------------
  def user_jump(x,y,high = 10)    
      return if self.action == nil
      return if self.action.user == nil
      self.action.user.jump_count = 0
      self.action.user.jump_peak = 0
      self.action.user.jump_high(x ,y ,high)      
  end    
  
  #--------------------------------------------------------------------------
  # ● User Jump Position
  #--------------------------------------------------------------------------
  def user_jump_position(x,y,high = 10)    
      return if self.action == nil
      return if self.action.user == nil
      self.action.user.jump_count = 0
      self.action.user.jump_peak = 0
      nx = x - self.action.user.x
      ny = y - self.action.user.y
      self.action.user.jump_high(nx ,ny ,high)      
  end      
  
  #--------------------------------------------------------------------------
  # ● Jump_position target side
  #--------------------------------------------------------------------------        
  def jump_position_target_side
      return if self.action_movement[4] == nil 
      turn_toward_character(self.action_movement[4])
      target_x = self.action_movement[4].x
      target_y = self.action_movement[4].y
      self.jump_count = 0
      self.jump_peak = 0 
      dir = 1
      nx = nil
      ny = nil
      case self.direction
         when 2; dir = 1
         when 4; dir = 2
         when 6; dir = 3
         when 8; dir = 4
      end
      4.times do 
            if dir == 1 
                  ex = 0
                  ey = -1
            elsif dir == 2   
                  ex = 1
                  ey = 0
            elsif dir == 3    
                  ex = -1
                  ey = 0
            elsif dir == 4    
                  ex = 0
                  ey = 1
            end           
            if passable_position?(target_x + ex, target_y + ey,2 * dir)
               nx = (target_x + ex) - self.x
               ny = (target_y + ey) - self.y
               break
            end   
            dir += 1
            dir = 1 if dir > 4
      end
      if nx == nil
         nx = self.action_movement[4].x - self.x
         ny = self.action_movement[4].y - self.y
      end   
      jump_high(nx ,ny ,10) unless (nx == self.x and ny == self.y)
      turn_toward_character(self.action_movement[4])
  end     
  
  #--------------------------------------------------------------------------
  # ● P Direction
  #--------------------------------------------------------------------------                 
  def p_direction
      if @diagonal_direction != 0
         case @diagonal_direction
              when 1;   @face_direction = [-1,1]
              when 3;   @face_direction = [1,1]
              when 7;   @face_direction = [-1,-1]
              when 9;   @face_direction = [1,1]
         end
       else
         case @direction
              when 2;   @face_direction = [0,1]
              when 4;   @face_direction = [-1,0]
              when 6;   @face_direction = [1,0]
              when 8;   @face_direction = [0,-1]
         end       
       end
  end  
  
  #--------------------------------------------------------------------------
  # ● Turn Reverse
  #--------------------------------------------------------------------------          
  def turn_reverse(dir)
      case dir     
        when 2; set_direction(8)
        when 4; set_direction(6)
        when 6; set_direction(4)
        when 8; set_direction(2)
      end    
  end
  
  #--------------------------------------------------------------------------
  # ● Org Here
  #--------------------------------------------------------------------------        
  def org_here
      @orig_pos_x = @x
      @orig_pos_y = @y
  end  
  
  #--------------------------------------------------------------------------
  # ● return_org
  #--------------------------------------------------------------------------          
  def return_org(type = 0)
      if type == 1
         moveto(@orig_pos_x,@orig_pos_x) 
      else  
         jump(0,0)
      end
      @x = @orig_pos_x
      @y = @orig_pos_y
  end  
  
  #--------------------------------------------------------------------------
  # ● Dual Switch
  #--------------------------------------------------------------------------    
  def dual_switch(switch_on, switch_off,percentage = 100)
      enable_per = rand(100)
      if enable_per <= percentage 
         $game_switches[switch_on] = true    
         $game_switches[switch_off] = false
         $game_map.need_refresh = true
      end   
  end   
  
  #--------------------------------------------------------------------------
  # ● Turn Toward
  #--------------------------------------------------------------------------
  def turn_toward(character)
    sx = distance_x_from(character.x)
    sy = distance_y_from(character.y)
    if sx.abs > sy.abs
      set_direction(sx > 0 ? 4 : 6)
    elsif sy != 0
      set_direction(sy > 0 ? 8 : 2)
    end
  end  
  
  #--------------------------------------------------------------------------
  # ● Move Forward 2
  #--------------------------------------------------------------------------  
  def move_forward2
      return if moving2?
      move_forward
  end  
  
  #--------------------------------------------------------------------------
  # ● Bounce Direction
  #--------------------------------------------------------------------------  
  def bounce_direction
      @diagonal = true
      turn_random  
  end
  
  #--------------------------------------------------------------------------
  # ● Turn_back
  #--------------------------------------------------------------------------            
  def turn_back
      if @diagonal_direction != 0
         case @diagonal_direction
              when 1
                turn_upper_right
              when 3
                turn_upper_left
              when 7
                turn_lower_right 
              when 9         
                turn_lower_left
         end
      else
          case @direction
               when 2;   set_direction(8) 
               when 4;   @direction = 6#move_straight(6)#set_direction(6) 
               when 6;   set_direction(4) 
               when 8;   set_direction(2) 
          end
      end     
  end  
  
  #--------------------------------------------------------------------------
  # ● Jump_high
  #--------------------------------------------------------------------------
  def jump_high(x_plus,y_plus,high = 10)    
      @x += x_plus
      @y += y_plus
      distance = Math.sqrt(x_plus * x_plus + y_plus * y_plus).round
      @jump_peak = high + distance - @move_speed
      @jump_count = @jump_peak * 2
      @stop_count = 0
      $game_temp.event_wait_movement = @jump_count
      straighten
  end
  
  #--------------------------------------------------------------------------
  # ● Force Move Route
  #--------------------------------------------------------------------------
  alias x_force_move_route force_move_route
  def force_move_route(move_route)
      if self.battler != nil and self.is_a?(Game_Event)
         return
      end  
      x_force_move_route(move_route)
  end  

  #--------------------------------------------------------------------------
  # ● Passable Temp
  #--------------------------------------------------------------------------    
 def passable_temp_id?(x, y)
     return false unless $game_map.valid?(x, y)    
     return true if @through or debug_through?     
     return false unless map_passable?(x, y,@direction)         
     return false if collide_with_characters_temp_id?(x, y) 
     return true                                   
  end
  
  #--------------------------------------------------------------------------
  # ● Collide With Characters
  #--------------------------------------------------------------------------      
  def collide_with_characters_temp_id?(x, y)
      for event in $game_map.events_xy(x, y)         
          unless event.through or event.battler != nil    
             return true if self.is_a?(Game_Event)       
             return true if event.priority_type >= 1     
          end
      end
      return false
  end   
  
  #--------------------------------------------------------------------------
  # ● Move backward Above
  #--------------------------------------------------------------------------        
  def move_backward_above
      return if @x != $game_player.x
      return if @y != $game_player.y
      $game_player.move_backward
      for allies in $game_player.allies
          allies.move_backward
      end
  end  
    
end

#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase
  
  #--------------------------------------------------------------------------
  # ● Update Jump
  #--------------------------------------------------------------------------             
#  alias mog_schala_jumping_speed update_jump
#  def update_jump
#      return if can_jump_speed?
#      mog_schala_jumping_speed
#  end

  #--------------------------------------------------------------------------
  # ● Can Jump Speed
  #--------------------------------------------------------------------------           
  def can_jump_speed?
      return false if !SLOW_INITIAL_JUMP_POSITION
      return false if @jump_speed == nil
      return false if self.is_a?(Game_Event)
      if @jump_speed[0]
         @jump_speed[1] += 1
         #straighten
         return true if @jump_speed[1] < @jump_speed[2] 
         @jump_speed[1] = 0
      end
      @jump_speed[0] = false if @jump_count == 0
      return false
  end  
  
  #--------------------------------------------------------------------------
  # ● Update High Fix
  #--------------------------------------------------------------------------            
  def update_high_fix  
      if @jump_count <= 0
         @priority_type = 1 if $game_temp.target_phase == nil
         @jump_count = 0        
      elsif @jump_count > 0 and @jump_peak > 10
         @priority_type = 3
      end
  end     
    
end

#===============================================================================
# ■ Game Player
#===============================================================================
class Game_Player < Game_Character

  #--------------------------------------------------------------------------
  # ● Update
  #--------------------------------------------------------------------------          
  alias schala_jump_fix_update update
  def update
      schala_jump_fix_update
      update_high_fix
  end

end

#===============================================================================
# ■ Game Follower
#===============================================================================
class Game_Follower < Game_Character  
  
  #--------------------------------------------------------------------------
  # ● Update
  #--------------------------------------------------------------------------          
  alias schala_jump_fix_follower_update update
  def update
      schala_jump_fix_follower_update
      update_high_fix
  end  

end

#===============================================================================
# ■ Actor Action
#===============================================================================
module Actor_Action
  
  #--------------------------------------------------------------------------
  # ● Set Actor
  #--------------------------------------------------------------------------               
  def set_actor(id)
      if $game_player.actor.id == id
         return $game_player
      end
      for follower in $game_player.followers
          return follower if follower.actor.id == id        
      end
      return $game_player
  end  

  #--------------------------------------------------------------------------
  # ● Real CX
  #--------------------------------------------------------------------------             
  def real_cx
      $game_player.cx - 8
  end

  #--------------------------------------------------------------------------
  # ● Real CX Max
  #--------------------------------------------------------------------------               
  def real_cx_max
      $game_player.cx + 8
  end  
  
  #--------------------------------------------------------------------------
  # ● Real CY
  #--------------------------------------------------------------------------             
  def real_cy
      $game_player.cy - 6
  end  

  #--------------------------------------------------------------------------
  # ● real CY Max
  #--------------------------------------------------------------------------             
  def real_cy_max
      $game_player.cy + 6
  end    
  
  #--------------------------------------------------------------------------
  # ● Party Animation
  #--------------------------------------------------------------------------                 
  def party_animation(animation_id)
      $game_player.animation_id = animation_id unless $game_player.actor.dead?
      for follower in $game_player.followers
          next if follower.actor.dead?
          follower.animation_id = animation_id
      end
  end

  #--------------------------------------------------------------------------
  # ● Party Jump Reset
  #--------------------------------------------------------------------------                 
  def party_jump_reset
      unless $game_player.actor.dead?
             $game_player.jump_count = 0
             $game_player.jump_peak = 0
      end
      for follower in $game_player.followers
          next if follower.actor.dead?
          follower.jump_count = 0
          follower.jump_peak = 0
      end
  end

  #--------------------------------------------------------------------------
  # ● Party Priority
  #--------------------------------------------------------------------------                 
  def party_priority(priority_type)
      $game_player.priority_type = priority_type unless $game_player.actor.dead?
      for follower in $game_player.followers
          next if follower.actor.dead?
          follower.priority_type = priority_type
      end    
      party_jump_reset
  end

  #--------------------------------------------------------------------------
  # ● Party Direction
  #--------------------------------------------------------------------------                 
  def party_direction(direction)
      $game_player.direction = direction unless $game_player.actor.dead?
      for follower in $game_player.followers
          next if follower.actor.dead?
          follower.direction = direction
      end    
  end

  #--------------------------------------------------------------------------
  # ● Party Jump Orign
  #--------------------------------------------------------------------------                 
  def party_jump_origin
      if $game_player.can_jump_origin?
         $game_player.jump_origin
         $game_player.direction = $game_player.pre_direction2
      end   
      for follower in $game_player.followers
          if follower.can_jump_origin?
             follower.jump_origin
             follower.direction = follower.pre_direction2
          end   
      end
  end  

  #--------------------------------------------------------------------------
  # ● Actor Animation
  #--------------------------------------------------------------------------               
  def actor_animation(id,animation_id)
      actor = set_actor(id)
      actor.animation_id = animation_id
  end

  #--------------------------------------------------------------------------
  # ● Actor Set Priority
  #--------------------------------------------------------------------------                 
  def actor_set_priority(id,priority)
      actor = set_actor(id)
      actor.priority_type = priority
  end  

  #--------------------------------------------------------------------------
  # ● Actor Jump Origin
  #--------------------------------------------------------------------------                 
  def actor_jump_origin(id)
      actor = set_actor(id)
      actor.jump_origin if actor.can_jump_origin?
      actor.direction = actor.pre_direction2
  end  

  #--------------------------------------------------------------------------
  # ● Actor Jump
  #--------------------------------------------------------------------------             
  def actor_jump(id,x,y)
      actor = set_actor(id)
      actor.pre_direction2 = actor.direction
      actor.jump_position(actor.x,actor.y,real_cx + x,real_cy + y)
  end

  #--------------------------------------------------------------------------
  # ● Actor Direction
  #--------------------------------------------------------------------------               
  def actor_direction(id,direction)
      actor = set_actor(id)
      actor.pre_direction2 = actor.direction
      actor.direction = direction
  end
  
  #--------------------------------------------------------------------------
  # ● Actor Make pose
  #--------------------------------------------------------------------------               
  def actor_make_pose(id,pose,time)
      actor = set_actor(id)
      actor.make_pose(pose,time)
  end  
  
  #--------------------------------------------------------------------------
  # ● Actor Turn Direction Target
  #--------------------------------------------------------------------------               
  def actor_turn_toward_target(id)
      actor = set_actor(id)
      actor.turn_toward_character(user_target)
  end    
  
  #--------------------------------------------------------------------------
  # ● Actor Skill ID
  #--------------------------------------------------------------------------               
  def actor_skill(id,skill_id)
      actor = set_actor(id)
      return if actor.battler.dead?
      actor.action_movement[4] = action.user.action_movement[4]
      actor.shoot(skill_id)
      actor.battler.at = 0
      actor.battler.cast_effect = [0,1]      
  end    

  #--------------------------------------------------------------------------
  # ● Actor Moveto Target
  #--------------------------------------------------------------------------                      
  def actor_moveto_target(id ,px = 0 , py = 0,jump = false)
      actor = set_actor(id)
      return if actor.battler.dead?    
      actor.action_movement[4] = action.user.action_movement[4]
      jump_count = 0
      jump_peak = 0    
      nx = user_target.x + px
      ny = user_target.y + py
      nx = real_cx_max if nx > real_cx_max
      nx = real_cx if nx < real_cx
      ny = real_cy_max if ny > real_cy_max
      ny = real_cy if ny < real_cy
      if jump
         high = 20
         actor.jump_high(0,0,high) 
      end   
      actor.x = nx
      actor.y = ny          
  end    
  
  #--------------------------------------------------------------------------
  # ● User
  #--------------------------------------------------------------------------                 
  def user
      @action.user rescue return $game_temp.target_phase
  end  
  
  #--------------------------------------------------------------------------
  # ● User Target
  #--------------------------------------------------------------------------                   
  def user_target
      $game_temp.target_phase.action_movement[4] rescue return @action.user.action_movement[4] 
  end  
    
  #--------------------------------------------------------------------------
  # ● User Step Back
  #--------------------------------------------------------------------------                 
  def step_back(power)
      tx = 0
      ty = 0
      case direction
         when 2
             tx = self.x
             ty = -power + self.y 
         when 4
             tx = power + self.x
             ty = self.y         
         when 6
             tx = -power + self.x   
             ty = self.y                
         when 8
             tx = self.x
             ty = power + self.y
      end
      jump_pos(tx,ty)
  end

  #--------------------------------------------------------------------------
  # ● Rush Forward
  #--------------------------------------------------------------------------                   
  def rush_forward(power)
      tx = 0
      ty = 0
      case direction
         when 2
             tx = self.x
             ty = power + self.y 
         when 4
             tx = -power + self.x
             ty = self.y         
         when 6
             tx = power + self.x   
             ty = self.y                
         when 8
             tx = self.x
             ty = -power + self.y
      end      
      jump_pos(tx,ty,3)
  end  

  #--------------------------------------------------------------------------
  # ● Rush Forward
  #--------------------------------------------------------------------------                     
  def user_moveto_target(px = 0 , py = 0)
      user.jump_count = 0
      user.jump_peak = 0    
      nx = user_target.x + px
      ny = user_target.y + py
      nx = real_cx_max if nx > real_cx_max
      nx = real_cx if nx < real_cx
      ny = real_cy_max if ny > real_cy_max
      ny = real_cy if ny < real_cy
      user.jump_high(0,0,5)
      user.x = nx
      user.y = ny      
  end  
    
  #--------------------------------------------------------------------------
  # ● Move Position
  #--------------------------------------------------------------------------                      
  def moveto_target(px = 0 , py = 0,jump = false )
      jump_count = 0
      jump_peak = 0    
      nx = user_target.x + px
      ny = user_target.y + py
      nx = real_cx_max if nx > real_cx_max
      nx = real_cx if nx < real_cx
      ny = real_cy_max if ny > real_cy_max
      ny = real_cy if ny < real_cy
      self.jump_high(0,0,10) if jump
      self.x = nx
      self.y = ny          
  end
  
  #--------------------------------------------------------------------------
  # ● Turn Toward Enemy
  #--------------------------------------------------------------------------                        
  def turn_toward_enemy
      turn_toward(target_enemy)
  end
  
  #--------------------------------------------------------------------------
  # ● Set Actor
  #--------------------------------------------------------------------------               
  def player(id)
      return $game_player if $game_player.actor.id == id
      for follower in $game_player.followers
          return follower if follower.actor.id == id        
      end
      return $game_player
  end  
  
  #--------------------------------------------------------------------------
  # ● Move Position
  #--------------------------------------------------------------------------                      
  def move_to(target, px = 0 , py = 0,height = 10)
      jump_count = 0
      jump_peak = 0
      if target_enemy != nil and $game_temp.on_target_size != 0
         case $game_temp.on_target_size 
              when 1;   py -= (target_enemy.sprite_size[5]).truncate
              when 2;   py -= (target_enemy.sprite_size[3]).truncate
              when 3;   py += (target_enemy.sprite_size[5]).truncate
              when 4;   py += (target_enemy.sprite_size[3]).truncate                
         end     
      end       
      if target == target_screen
         if height > 0 
            jump_position(self.x,self.y,real_cx + px,real_cy + py, height)
         else
            moveto_action(real_cx + px, real_cy + py) 
         end  
       else
        if height > 0 
           jump_position(self.x, self.y ,target.x + px, target.y + py, height)
        else
           moveto_action(target.x + px , target.y + py ) 
        end  
      end
  end  
  
  #--------------------------------------------------------------------------
  # ● Base Position
  #--------------------------------------------------------------------------                          
  def base_position(value)
      $game_temp.on_target_size = value
  end
  
  #--------------------------------------------------------------------------
  # ● Target Screen
  #--------------------------------------------------------------------------                        
  def target_screen
      return 
  end
  
  #--------------------------------------------------------------------------
  # ● Move Position
  #--------------------------------------------------------------------------
  def target_enemy
      return $game_temp.target_phase.action_movement[4] rescue return $game_player
  end

  #--------------------------------------------------------------------------
  # ● Record Position
  #--------------------------------------------------------------------------  
  def record_position
      self.temp_position = [self.x,self.y,self.direction,self.priority_type]
  end
  
  #--------------------------------------------------------------------------
  # ● Record Position
  #--------------------------------------------------------------------------  
  def restore_position(high = 10)
      jump_org(high)
  end  

  #--------------------------------------------------------------------------
  # ● Char Pose
  #--------------------------------------------------------------------------                
  def char_pose(pose = "", time = 10)
      self.make_pose(pose,time)
      self.update_battler_pose
  end  
  
  #--------------------------------------------------------------------------
  # ● Active Hit
  #--------------------------------------------------------------------------              
  def active_hit(enable)
      if target_enemy != nil and $game_map.events[@event_id] != nil
         $game_map.events[@event_id].moveto(target_enemy.x,target_enemy.y) if enable
      end      
      for i in $game_map.events.values
          i.enable_hit(enable)        
      end
  end  
  
  #--------------------------------------------------------------------------
  # ● Record Temp battler Position
  #--------------------------------------------------------------------------               
  def record_temp_battler_position
      for i in $game_temp.target_actors
          i.record_position
      end
      for i in $game_temp.target_enemies
          i.record_position
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Moveto Action
  #--------------------------------------------------------------------------
  def moveto_action(x, y)
      @x = x % $game_map.width
      @y = y % $game_map.height
      @real_x = @x
      @real_y = @y
      @prelock_direction = 0
      straighten
      update_bush_depth
  end  
  
  #--------------------------------------------------------------------------
  # ● Fade events
  #--------------------------------------------------------------------------    
  def fade_events(value,target = false)
      for i in $game_map.events.values
          if target_enemy != nil
             next if i == target_enemy and target
          end
          next if i.tool_id > 0
          i.fade = value
      end
  end  
  
  #--------------------------------------------------------------------------
  # ● Fade Party
  #--------------------------------------------------------------------------  
  def fade_party(value)
      return if target_enemy == nil
      if target_enemy.battler.is_a?(Game_Actor)
          for i in $game_temp.target_enemies
              next if i.battler.dead?
              next if !i.target
              i.fade = value
          end    
      else  
          for i in $game_temp.target_actors
              i.fade = value
          end
      end      
  end
   
  #--------------------------------------------------------------------------
  # ● Tilemap Visible
  #--------------------------------------------------------------------------          
  def tilemap_visible(value)
      $game_temp.tilemap_visible = value
      for i in $game_map.events.values
          next if i.tool_id > 0
          next if i.battler != nil
          i.fade = value == true ? false : true
      end            
  end  
    
  #--------------------------------------------------------------------------
  # ● Parallax Visible
  #--------------------------------------------------------------------------          
  def parallax_visible(value)
      $game_temp.parallax_visible = value
  end      
  
  #--------------------------------------------------------------------------
  # ● Clear Fade
  #--------------------------------------------------------------------------            
  def clear_fade
      $game_temp.parallax_visible = true
      $game_temp.tilemap_visible = true
      fade_events(false,false)
      fade_party(false)    
  end
  
  #--------------------------------------------------------------------------
  # ● Restore Parallax
  #--------------------------------------------------------------------------                
  def restore_parallax
      return if !$game_temp.pre_parallax_name[5]
      $game_map.parallax_name = $game_temp.pre_parallax_name[0]
      $game_map.parallax_loop_x = $game_temp.pre_parallax_name[1]
      $game_map.parallax_loop_y = $game_temp.pre_parallax_name[2]
      $game_map.parallax_sx = $game_temp.pre_parallax_name[3] 
      $game_map.parallax_sy = $game_temp.pre_parallax_name[4]
      $game_temp.pre_parallax_name[5] = false
  end
  
  #--------------------------------------------------------------------------
  # ● Restore Field Tone
  #--------------------------------------------------------------------------                  
  def restore_field_tone
      $game_map.interpreter.restore_tone
  end    
  
  #--------------------------------------------------------------------------
  # ● Rolling Effect
  #--------------------------------------------------------------------------                    
  def rolling_effect(value)
      self.round_knockback[0] = value
      self.round_knockback[1] = 0
      self.angle = 0
  end
  
end

#===============================================================================
# ■ Game Interpreter
#===============================================================================
class Game_Interpreter
      include Actor_Action
end

#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase
      include Actor_Action  
end
    
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ TOOL - INITIALIZE
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


#===============================================================================
# ■ Game_Map
#===============================================================================
class Game_Map
  
  attr_accessor :need_refresh_token

  #--------------------------------------------------------------------------
  # ● need_add_tokens 
  #--------------------------------------------------------------------------  
  def need_add_tokens
      @need_add_tokens = [] if @need_add_tokens == nil
      return @need_add_tokens
  end
  
  #--------------------------------------------------------------------------
  # ● need_remove_tokens 
  #--------------------------------------------------------------------------
  def need_remove_tokens
      @need_remove_tokens = [] if @need_remove_tokens == nil
      return @need_remove_tokens
  end
  
  #--------------------------------------------------------------------------
  # ● add_token 
  #--------------------------------------------------------------------------
  def add_token(token_event)
      $game_temp.tool_event = [] if $game_temp.tool_event == nil
      $game_temp.tool_event.push(token_event)
      self.need_add_tokens.push(token_event)
      self.need_refresh_token = true
  end
  
  #--------------------------------------------------------------------------
  # ● remove_token
  #--------------------------------------------------------------------------
  def remove_token(token_event)
      @events.delete(token_event.id)
      self.need_remove_tokens.push(token_event)
      self.need_refresh_token = true
  end
 
  #--------------------------------------------------------------------------
  # ● clear_tokens 
  #--------------------------------------------------------------------------
  def clear_tokens
      $game_temp.tool_on_map = []
      for event in @events.values.dup
          remove_token(event) if event.is_a?(Token_Event)
      end
      channels = ["A", "B", "C", "D"]
      for id in 1001..(token_id_shift - 1)
          for a in channels
              key = [self.map_id, id, a]
              $game_self_switches.delete(key)
          end
      end
      clear_token_id
  end
    
  #--------------------------------------------------------------------------
  # ● Update
  #--------------------------------------------------------------------------      
  alias x_temp_tool_hash_update update
  def update(main = false)
      x_temp_tool_hash_update(main)
      update_add_tool_hash
  end

  #--------------------------------------------------------------------------
  # ● Update Add Toll Hash
  #--------------------------------------------------------------------------      
  def update_add_tool_hash  
      return if $game_temp.tool_event == nil
      for i in $game_temp.tool_event
          $game_map.events[i.id] = i
          execute_tool_effects_hash(i)
      end  
      $game_temp.tool_event.clear
      $game_temp.tool_event = nil
  end
    
  #--------------------------------------------------------------------------
  # ● Execute Toll Effects Hash
  #--------------------------------------------------------------------------        
  def execute_tool_effects_hash(i)
      
  end  
end

#===============================================================================
# ■ Game_SelfSwitches  
#===============================================================================
class Game_SelfSwitches
  def delete(key)
      @data.delete(key)
  end
end

#===============================================================================
# ■ Game_Map  
#===============================================================================
class Game_Map
    
  attr_accessor :token_id
  
  #--------------------------------------------------------------------------
  # ● token_id_shift 
  #--------------------------------------------------------------------------  
  def token_id_shift
      @token_id  = 1000 if @token_id == nil
      @token_id += 1
      return @token_id
  end

  #--------------------------------------------------------------------------
  # ● clear_token_id 
  #--------------------------------------------------------------------------  
  def clear_token_id
      @token_id = nil
  end
end

#===============================================================================
# ■ XRXS_CTS_RefreshToken 
#===============================================================================
module XRXS_CTS_RefreshToken
  
  #--------------------------------------------------------------------------
  # ● refresh_token
  #--------------------------------------------------------------------------  
  def refresh_token
      for event in $game_map.need_add_tokens
          @character_sprites.push(Sprite_Character.new(@viewport1, event))
      end
      $game_map.need_add_tokens.clear
      for sprite in @character_sprites.dup
          if $game_map.need_remove_tokens.empty?
             break
          end
          if $game_map.need_remove_tokens.delete(sprite.character)
             @character_sprites.delete(sprite)
             sprite.dispose
          end
      end
      $game_map.need_refresh_token = false
  end
end

#===============================================================================
# ■  Spriteset_Map
#===============================================================================
class Spriteset_Map
  include XRXS_CTS_RefreshToken
end

#===============================================================================
# ■ Game_Player
#===============================================================================
class Game_Player < Game_Character

  #--------------------------------------------------------------------------
  # ● x_reserve_transfer
  #--------------------------------------------------------------------------     
  alias x_reserve_transfer reserve_transfer 
  def reserve_transfer(map_id, x, y, direction)
      $game_map.clear_tokens
      if $game_temp.tool_event != nil 
         $game_temp.tool_event.clear
         $game_temp.tool_event = nil
      end   
      x_reserve_transfer(map_id, x, y, direction)
  end
  
end

#===============================================================================
# ■ Token_Event
#===============================================================================
class Token_Event < Game_Event
  
  #--------------------------------------------------------------------------
  # ● Token_Event
  #--------------------------------------------------------------------------
  def initialize(map_id, event)
      event.id = $game_map.token_id_shift
      super
  end
  
  #--------------------------------------------------------------------------
  # ● erase
  #--------------------------------------------------------------------------
  def erase
      super
      $game_map.remove_token(self)
      $game_temp.tool_on_map.delete(self.tool_id)
  end
end


#===============================================================================
# ■  XRXS_ActionTemplate
#===============================================================================
module XRXS_ActionTemplate
  map_id = XAS_SYSTEM::ACTION_TEMPLATE_MAP_ID
  map = load_data(sprintf("Data/Map%03d.rvdata2", map_id))
  @@events = map.events
end

#===============================================================================
# ■  Token_Event
#===============================================================================
class Token_Event < Game_Event
  include XRXS_ActionTemplate
end

#===============================================================================
# ■  Game_Temp
#===============================================================================
class Game_Temp
  attr_accessor :active_token
end

#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ TOOL - SHOOT COMMAND
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


#===============================================================================
# ■ XAS ACTION
#===============================================================================
module XAS_ACTION
  
  attr_reader   :action
  attr_reader   :erased
  
  #--------------------------------------------------------------------------
  # ● shoot
  #--------------------------------------------------------------------------
  def shoot(action_id = 0)
      return if action_id == 0 or action_id == nil
      skill = $data_skills[action_id]
      return unless can_shoot?(skill)
      execute_user_effects(skill)
      execute_call_event(action_id)      
      self.action_attachment(action_id)
      execute_set_pose(action_id)
      check_tool_shooting
      unless $game_temp.tool_on_map.include?(action_id)
             $game_temp.tool_on_map.push(action_id) 
      end   
  end
  
  #--------------------------------------------------------------------------
  # ● Check Toll Shooting
  #--------------------------------------------------------------------------  
  def check_tool_shooting
      return if self.action.user == nil
      if self.action.user.tool_id > 0 and self.action.duration == 1
         skill = $data_skills[self.action.user.tool_id]
         dur = $1.to_i if skill.note =~ /<Duration = (\d+)>/
         dur = 1 if dur == nil or dur == 0
         self.action.duration = dur
      end        
  end

  #--------------------------------------------------------------------------
  # ● Can Shoot
  #--------------------------------------------------------------------------    
  def can_shoot?(skill)
      if self.battler == nil and self.tool_id > 0
         @battler = self.action.user.battler
      end  
      if limited_action?(skill)
         return false if $game_temp.tool_on_map.include?(skill.id)
      end
      return false if self.battler == nil
      return false if self.battler.dead?
      return false if skill == nil
      return false if $game_temp.hookshot_phase != 0
      return false if $game_temp.pre_battle_phase > 0
      return true if ignore_can_shoot?(skill)
      unless enough_skill_cost?(skill)
         Audio.se_play("Audio/SE/" + XAS_SOUND::ACTION_COST , 100, 100) 
         return false 
      end
      return true
  end 
  
  #--------------------------------------------------------------------------
  # ● Limited Action
  #--------------------------------------------------------------------------     
  def limited_action?(skill)
      return true  if skill.note =~ /<Limit One Action>/
      return false
  end  
  
  #--------------------------------------------------------------------------
  # ● Ignore Can Shoot?     
  #--------------------------------------------------------------------------                
  def ignore_can_shoot?(skill)
      return false
  end
  
  #--------------------------------------------------------------------------
  # ● enough_skill_cost?
  #--------------------------------------------------------------------------          
  def enough_skill_cost?(skill)
      if can_execute_cooperation_skill? and self_member_cooperation?
         if enough_mp_tp_for_cooperation_members?(skill) 
            mp_tp_cost_for_cooperation_members(skill)
         else           
            return false
         end
      else
         return false unless enough_mp_cost?(skill)
         return false unless enough_tp_cost?(skill)
      end
      return false unless enough_item_cost?(skill) 
      return true
  end
    
  #--------------------------------------------------------------------------
  # ● Enough TP Cost
  #--------------------------------------------------------------------------        
  def enough_tp_cost?(skill)  
      if @force_action_times > 0
         return true if @force_action == "All Shoot" 
         return true if @force_action == "Four Shoot"  
         return true if @force_action == "Three Shoot" 
         return true if @force_action == "Two Shoot" 
      end
      if self.battler.tp < skill.tp_cost 
         self.battler.damage = "No TP"
         self.battler.damage_pop = true
         return false
      else   
         self.battler.tp -= skill.tp_cost
         return true
      end
      return true 
  end    
  
  #--------------------------------------------------------------------------
  # ● Enough MP Cost
  #--------------------------------------------------------------------------        
  def enough_mp_cost?(skill)  
      if @force_action_times > 0
         return true if @force_action == "All Shoot" 
         return true if @force_action == "Four Shoot"  
         return true if @force_action == "Three Shoot" 
         return true if @force_action == "Two Shoot" 
      end
      if self.battler.mp < skill.mp_cost 
         self.battler.damage = XAS_WORD::NO_MP
         self.battler.damage_pop = true
         return false
      else   
         self.battler.mp -= skill.mp_cost
         return true
      end
      return true 
  end  
  
  #--------------------------------------------------------------------------
  # ● Enough MP Cost
  #--------------------------------------------------------------------------      
  def enough_item_cost?(skill)
      return true if self.battler.is_a?(Game_Enemy)
      if @force_action_times > 0
         return true if @force_action == "All Shoot"
         return true if @force_action == "Four Shoot"
         return true if @force_action == "Three Shoot"
         return true if @force_action == "Two Shoot" 
      end      
      skill.note =~ /<Item Cost = (\d+)>/
      item_id = $1.to_i 
      if item_id != nil and item_id != 0
         item_cost = $data_items[item_id]
         number = $game_party.item_number(item_cost)
         if number == 0 or number == nil
            self.battler.damage = XAS_WORD::NO_ITEM
            self.battler.damage_pop = true
            return false 
         else
            $game_party.lose_item(item_cost, 1, false)
            return true
         end            
      end    
      return true 
  end    
  
  #--------------------------------------------------------------------------
  # ● Execute User Effects
  #--------------------------------------------------------------------------  
  def execute_user_effects(skill)
      self.battler.shield = false
      unless @force_action_times > 0
          #All Directions
          if skill.note =~ /<All Directions>/
             @force_action = "All Shoot" 
             @force_action_times = 8  
             @diagonal = true
          elsif skill.note =~ /<Four Directions>/
             @force_action = "Four Shoot" 
             @force_action_times = 4       
          elsif skill.note =~ /<Three Directions>/
             @force_action = "Three Shoot" 
             @force_action_times = 3     
             @diagonal = true
          elsif skill.note =~ /<Two Directions>/
             @force_action = "Two Shoot" 
             @force_action_times = 2         
          end  
      end  
  end
    
  #--------------------------------------------------------------------------
  # ● Execute Set Pose
  #--------------------------------------------------------------------------      
  def execute_set_pose(action_id)
      @action.duration = @action.sunflag
      make_pose(@action.self_motion, @action.sunflag ) unless @action.self_motion == ""
      @pattern = 0
      @pattern_count  = 0
      @step_anime = true
      @self_motion = nil      
      self.need_refresh = true if self.is_a?(Game_Player)
  end  
    
  #--------------------------------------------------------------------------
  # ● execute_call_event
  #--------------------------------------------------------------------------  
  def execute_call_event(action_id)
      bullet_token = Token_Bullet.new(self, action_id)
      $game_map.add_token(bullet_token)
      return bullet_token
  end
      
  #--------------------------------------------------------------------------
  # ● action_attachment
  #--------------------------------------------------------------------------
  def action_attachment(action_id)
      @action = Game_Action_XAS.new(self, action_id)
      @action.attachment(action_id)
  end
  
end  

#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ TOOL - SHOOT SETTING
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


#===============================================================================
# ■ Game_Action_XAS
#===============================================================================
class Game_Action_XAS
  
  attr_accessor   :user
  attr_accessor   :id                    
  attr_accessor   :attack_id            
  attr_accessor   :attack_range
  attr_accessor   :attack_range_type
  attr_accessor   :hit_events
  attr_accessor   :now_count
  attr_accessor   :pre_now_count
  attr_accessor   :duration
  attr_accessor   :target_invunerable_duration
  attr_accessor   :multi_hit
  attr_accessor   :all_damage
  attr_accessor   :sunflag
  attr_accessor   :self_motion
  attr_accessor   :third_animation_id
  attr_accessor   :attack_range_type
  attr_accessor   :attack_range_plan
  attr_accessor   :first_impact_time
  attr_accessor   :duration 
  attr_accessor   :item_cost
  attr_accessor   :hit_shake
  attr_accessor   :attack_id_plan
  attr_accessor   :hit_action
  attr_accessor   :impact
  attr_accessor   :clear_hit
  attr_accessor   :take_treasure_type
  attr_accessor   :piercing
  #--------------------------------------------------------------------------
  # ● initialize
  #--------------------------------------------------------------------------
  def initialize(user, action_id)
      @user        = user
      @id          = action_id
      @now_count   = 0
      @duration    = nil
      @attack_id   = 0
      @attack_range = 0
      @hit_events  = []
      @skill = $data_skills[action_id]
      @multi_hit = false
      @all_damage = false
      @sunflag = 15
      @duration = 15
      @self_motion = ""
      @attack_range_type = 1
      @attack_range_plan = [0]
      @first_impact_time  = 0
      @target_invunerable_duration = 5
      @third_animation_id = 0 
      @item_cost = 0
      @hit_shake = true
      @hit_action = 0
      @impact = true
      @clear_hit = [false,0]
      @take_treasure_type = 0
      @piercing = true
  end
  
  #--------------------------------------------------------------------------
  # ● attachment 
  #--------------------------------------------------------------------------
  def attachment(action_id)
      @attack_id_plan = [action_id]
      if @skill.note =~ /<Disable Hit>/  
         @impact = false
      end            
      if @skill.note =~ /<Disable Piercing>/ 
         @piercing = false
      end          
      if @skill.note =~ /<Sunflag = (\d+)>/
         @sunflag = $1.to_i
      end
      if @skill.note =~ /<Duration = (\d+)>/
         @duration = $1.to_i
      end
      @duration = 10 if @duration < 10
      $game_temp.action_duration = @duration
      if @skill.note =~ /<Pose = (\S+)>/   
         @self_motion = $1.to_s
      end
      if @skill.note =~ /<Take Treasure = (\d+)>/
         @take_treasure_type = $1.to_i
      end
      if @skill.scope == 2 or @skill.scope == 8 or @skill.scope == 10
         @attack_range_plan = [18]
         @attack_range_type = 1
      end      
      if @skill.note =~ /<Area = (\w+)>/ 
         case $1
            when "CROSS"   
               area = 7
            when "WALL" 
               area = 6        
            when "FRONTRHOMBUS"  
               area = 5
            when "FRONTSQUARE"
               area = 4
            when "LINE"
               area = 3
            when "SQUARE"
               area = 2               
            else   
               area = 1 
         end     
         @attack_range_type = area
      end
      if @skill.note =~ /<Range = (\d+)>/   
         @attack_range_plan = [$1.to_i]
      end     
      if @skill.note =~ /<Impact Time  = (\d+)>/   
         @first_impact_time = $1.to_i
       end   
      if @skill.repeats > 1
         @multi_hit = true
         value = (70 / @skill.repeats).truncate
         @target_invunerable_duration = value
      end  
      if @skill.note =~ /<User Hit Animation = (\d+)>/       
         @third_animation_id = $1.to_i
      end   
      if @skill.note =~ /<Item Cost = (\d+)>/    
         @item_cost = $1.to_i
      end         
      if @skill.note =~ /<Hit Action ID = (\d+)>/
         @hit_action = $1.to_i
      end
      if @skill.note =~ /<All Damage>/
         @all_damage = true 
      end
      if @skill.note =~ /<Disable Shake Effect>/
         @hit_shake = false
      end
      if @skill.note =~ /<Disable Hit>/
         @impact = false
         if @skill.repeats == 1
            @clear_hit = [true,0]
            @multi_hit = true
            @target_invunerable_duration = 5
         end   
      end
      @sunflag = 1 if @sunflag <= 0 
  end
  
  #--------------------------------------------------------------------------
  # ● update
  #--------------------------------------------------------------------------
  def update
      update_action_impact
      update_action_duration
  end  
    
  #--------------------------------------------------------------------------
  # ● update Action Duration
  #--------------------------------------------------------------------------  
  def update_action_duration
      if @attack_id_plan != nil
         id = @attack_id_plan[@now_count]
         unless id.nil? 
           @attack_id = id
           @hit_events.clear
           @hit_events.push(self.user) unless @all_damage
         end
      end
      if @attack_range_plan != nil
         range = @attack_range_plan[@now_count]
         @attack_range = range unless range.nil?
      end
      @now_count += 1
  end
    
  #--------------------------------------------------------------------------
  # ● Update Action Impact
  #--------------------------------------------------------------------------
  def update_action_impact
      @first_impact_time -= 1 if @first_impact_time > 0
      if @clear_hit[0]
         if @clear_hit[1] > 0
            @clear_hit[1] -= 1
            @impact = false if @clear_hit[1] == 0
         end  
      end   
  end
  
  #--------------------------------------------------------------------------
  # ● done? 
  #--------------------------------------------------------------------------
  def done?
      return (self.duration.to_i > 0 and self.now_count >= self.duration)
  end
end

#===============================================================================
# ■ Token_Bullet  
#===============================================================================
class Token_Bullet < Token_Event
include XRXS_ActionTemplate
  #--------------------------------------------------------------------------
  # ● initialize 
  #--------------------------------------------------------------------------
  def initialize(user, action_id)
      event_id = action_id
      skill = $data_skills[action_id]
      if skill.note =~ /<Event ID = (\d+)>/
         event_id = $1.to_i
      end  
      original_event = @@events[event_id]
      if original_event == nil
         msgbox("There's no Event ID " + event_id.to_s + " on Tool Map!") 
         SceneManager.exit
         return 
      end  
      event = original_event.dup 
      event.x = user.x
      event.y = user.y
      pre_direction = event.pages[0].graphic.direction
      event.pages[0].graphic.direction = user.direction
      @character_name = event.pages[0].graphic
      super($game_map.map_id, event)
      self.action_attachment(action_id)
      self.tool_id = action_id
      self.diagonal = false
      self.diagonal_direction = 0
      self.sprite_angle_enable = false
      @action.user = user
      @remain_for_an_act = @action.duration.is_a?(Numeric)
      check_tool_effects(user,skill,pre_direction)
  end
  
  #--------------------------------------------------------------------------
  # ● update 
  #--------------------------------------------------------------------------
  def update
      super
      if @action == nil and @remain_for_an_act
         $game_temp.tool_on_map.delete(self.tool_id)
         erase 
      end
      check_event_trigger_attack
  end
end

#===============================================================================
# ■ Game Player
#===============================================================================
class Game_Player < Game_Character
  attr_accessor :need_refresh
end

#===============================================================================
# ■ Token_Bullet  
#===============================================================================
class Token_Bullet < Token_Event
  
  #--------------------------------------------------------------------------
  # ● Check Tool Effects
  #-------------------------------------------------------------------------- 
  def check_tool_effects(user,skill,pre_direction)
      if skill.note =~ /<Animation Time = (\d+) - (\d+)>/
         self.timed_animation = [$1.to_i, $2.to_i] 
         self.timed_animation[0] = 0 if self.timed_animation[0] < 0
         self.timed_animation[1] = 1 if self.timed_animation[1] < 1         
      end      
      self.target_2 = user.action_movement[4] rescue nil
      if @action.all_damage    
         user.battler.invunerable_duration = 0
       end
     if skill.note =~ /<Animation = (\d+)>/  
        if self.target_2 != nil and !self.target_2.battler.dead? and
           self.target_2 != user
           self.target_2.animation_id = $1.to_i 
        else  
           self.animation_id = $1.to_i
        end
     end      
      # Force Update Out Screen
     if user.battler.sensor_range >= 15 or
        skill.note =~ /<Update Out Screen>/
        self.force_update = true
     end  
     #Diagonal Effect
     if skill.note =~ /<Diagonal>/ or
        skill.note =~ /<All Direction>/ or
        skill.note =~ /<Three Direction>/
        self.diagonal = true
        self.diagonal_direction = user.diagonal_direction
        self.sprite_angle_enable = true
        user.diagonal_time = 5 if user.diagonal_direction != 0
        user.diagonal = true     
     end 
     if skill.note =~ /<Action Type = AUTO TARGET>/
       if user.action_movement[4] != nil    
          self.moveto(user.action_movement[4].x, user.action_movement[4].y)
       end
     end
     if skill.note =~ /<Action Type = PROJECTILE>/
        self.tool_effect = "Projectile"
        @direction_fix = true 
        self.force_update = true
        self.moveto(user.x, user.y)        
        @move_frequency = 6
        @move_speed = 6
        @direction_fix = true
        @walk_anime = true
        @step_anime = true
        @force_action = "Target" 
        @force_action_times = 30       
     end
     
     if skill.note =~ /<Action Type = BOOMERANG>/
        self.tool_effect = "Boomerang"
        self.action.duration = 290
        @direction_fix = true 
        self.force_update = true
        self.moveto(user.x, user.y)
        self.target_2 = user.action_movement[4]
        @move_frequency = 6
        @move_speed = 5
        @direction_fix = false
        @walk_anime = true
        @step_anime = true
        @force_action = "Boomerang"
        @force_action_times = 30       
     end     
      
   end
end 
 
 #■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ TOOL - AREA
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


#===============================================================================
# ■ XAS ACTION
#===============================================================================
module XAS_ACTION

  #--------------------------------------------------------------------------
  # ● action_update
  #--------------------------------------------------------------------------
  def action_update
      return unless @action.is_a?(Game_Action_XAS)
      @action.update
  end
    
  #--------------------------------------------------------------------------
  # ● Can Impact Target
  #--------------------------------------------------------------------------  
  def can_impact_target?
      return false if @action.nil? 
      return false if @action.attack_id == 0 
      return false if @action.first_impact_time > 0
      return false if !@action.impact
      return false if self.jumping?
      return true
  end  

  #--------------------------------------------------------------------------
  # ● check_event_trigger_attack
  #--------------------------------------------------------------------------
  def check_event_trigger_attack()
      return unless can_impact_target?
      hit_check = false
      range = @action.attack_range
      hit = []
      ally = []
      targets = [$game_player] + $game_player.allies + $game_map.events.values
       if !@action.user.heal 
         skill = $data_skills[@action.id]
         if skill.scope >= 7
            @action.user.heal = true
            skip_include = true  
         end   
      end      
      for event in targets
          next if event == self
          next if event.erased 
          next if @action.hit_events.include?(event) unless skip_include
          body_size      = event.body_size
          event_center_x = event.x 
          event_center_y = event.y - body_size
          dx = event_center_x - self.x
          dy = event_center_y - self.y
          dx = (dx >= 0 ? [dx - body_size, 0].max : [dx + body_size, 0].min)
          dy = (dy >= 0 ? [dy - body_size, 0].max : [dy + body_size, 0].min)
          hit_check = true if in_range?(dx,dy,event,range) 
          hit.push(event) if hit_check
          hit_check = false
      end
      for event in hit
          if event.action_effect(self, self.action.attack_id)
             hit_check = true
          end
          if event.action_effect_page(self, self.action.attack_id)
             hit_check = true
         end         
         @action.hit_events.push(event) unless @action.multi_hit
         end
      if hit_check
         $game_temp.active_token = self
      end
  end

  #--------------------------------------------------------------------------
  # ● In Range?
  #--------------------------------------------------------------------------  
  def in_range?(dx,dy,event,range) 
      case @action.attack_range_type
            when 1 #RHOMBUS
              return true if (dx.abs + dy.abs <= range)
            when 2 #SQUARE
              return true if (dx.abs <= range and dy.abs <= range)
            when 3 #LINE
              case self.direction
                  when 2
                    return true if (dx == 0 and dy >= 0 and dy <= range)
                  when 8
                    return true if (dx == 0 and dy <= 0 and dy >= -range)
                  when 6
                    return true if (dy == 0 and dx >= 0 and dx <= range)
                  when 4
                    return true if (dy == 0 and dx <= 0 and dx >= -range)
              end
            when 4  #FRONT SQUARE   
              case self.direction
                 when 2
                    return true if (dx.abs <= range and dy >= 0 and dy.abs <= range)
                 when 4
                    return true if (dx.abs <= range and dx <= 0 and dy.abs <= range)  
                 when 6
                    return true if (dx.abs <= range and dx >= 0 and dy.abs <= range)
                 when 8
                    return true if (dx.abs <= range and dy <= 0 and dy.abs <= range)
              end              
            when 5  #FRONT RHOMBUS     
              case self.direction
                  when 2
                    return true if (dx.abs + dy.abs <= range and dy >= 0)
                  when 8
                    return true if (dx.abs + dy.abs <= range and dy <= 0)
                  when 6
                    return true if (dx.abs + dy.abs <= range and dx >= 0)
                  when 4
                    return true if (dx.abs + dy.abs <= range and dx <= 0)
              end          
            when 6  #WALL
              case self.direction
                 when 2
                    return true if (dx.abs <= range and dy == 0 )
                 when 4
                    return true if (dy.abs <= range and dx == 0)  
                 when 6
                    return true if (dy.abs <= range and dx == 0)
                 when 8
                    return true if (dx.abs <= range and dy == 0)
               end  
            when 7 #CROSS
                 return true if (dx.abs <= range and dy == 0)
                 return true if (dy.abs <= range and dx == 0)  
            end
     return false       
  end      
  
  #--------------------------------------------------------------------------
  # ●  action_effect Page
  #--------------------------------------------------------------------------
  def action_effect_page(attacker, attack_id)
      return false unless self.is_a?(Game_Event)
      return false if $game_temp.battle_phase[0]
      check_auto_effect_page(attacker, attack_id) if attacker.action != nil
      for page in @event.pages
          if page.condition.variable_valid and
             page.condition.variable_id == XAS_SYSTEM::HIT_ID and 
             page.condition.variable_value == attack_id
             self.reaction_valid_attack_id = attack_id
             self.refresh
             @trigger = 0
             self.start
             return true
          end
      end
      return false
  end
  
  #--------------------------------------------------------------------------
  # ● Check Auto Effect Page
  #--------------------------------------------------------------------------  
  def check_auto_effect_page(attacker, attack_id)
      execute_hookshot_effect_page(attacker, attack_id)
      if self.treasure != nil
         if can_hit_take_treasure?(attacker, attack_id)
            execute_take_treasure(attacker, attack_id) 
         elsif self.temp_id == 0 and can_hold_treasure?(attacker, attack_id)   
            execute_hold_treasure(attacker, attack_id) 
         end  
      end
  end    
  
  #--------------------------------------------------------------------------
  # ● Can Hit Take Treasure
  #--------------------------------------------------------------------------      
  def can_hit_take_treasure?(attacker, attack_id)
      return true if attacker.action.take_treasure_type == 1
      return false
  end
  
  #--------------------------------------------------------------------------
  # ● Can Hold Treasure?
  #--------------------------------------------------------------------------        
  def can_hold_treasure?(attacker, attack_id)
      return true if attacker.action.take_treasure_type == 2
      return false 
  end  
  
  #--------------------------------------------------------------------------
  # ● Execute Hold Treasure
  #--------------------------------------------------------------------------      
  def execute_hold_treasure(attacker, attack_id)
      tr_time = (100 + XAS_BA::TREASURE_ERASE_TIME * 60) - 5
      return if self.treasure_time > tr_time
      self.temp_id = attacker.id
      self.direction_fix = true
      self.priority_type = 2
      hookshot_back(attacker)
  end  
  
  #--------------------------------------------------------------------------
  # ● hookshot_back
  #--------------------------------------------------------------------------        
  def hookshot_back(attacker)
      return unless attacker.hookshot
      attacker.force_action_times = 30
      attacker.force_action = "Toward Player"
      attacker.direction_fix = true  
  end
      
  #--------------------------------------------------------------------------
  # ● Execute Take Treasure
  #--------------------------------------------------------------------------      
  def execute_take_treasure(attacker, attack_id)
      tr_time = (100 + XAS_BA::TREASURE_ERASE_TIME * 60) - 5
      return if self.treasure_time > tr_time
      gain_treasure(self)
      hookshot_back(attacker)
  end  
  
  #--------------------------------------------------------------------------
  # ● Gain treasure
  #--------------------------------------------------------------------------        
  def gain_treasure(enemy)
      return if $game_temp.battle_phase[0]
      return if enemy == nil
      return if enemy.treasure == nil
      return if enemy.erased
      case enemy.treasure[0]
           when 1; item = $data_items[enemy.treasure[1]] rescue nil
           when 2; item = $data_weapons[enemy.treasure[1]] rescue nil
           when 3; item = $data_armors[enemy.treasure[1]] rescue nil
      end
      return if item == nil
      $game_party.gain_item(item,1)
      $game_player.animation_id = $1.to_i if item.note =~ /<Drop Animation = (\d+)>/
      Audio.se_play("Audio/SE/" + XAS_SOUND::ITEM_DROP , 100, 100) 
      execute_item_popup(item)
      enemy.treasure = nil
      enemy.erase_final
  end
  
  #--------------------------------------------------------------------------
  # ● Execute Item Popup
  #--------------------------------------------------------------------------         
  def execute_item_popup(item)
      return if !XAS_DAMAGE_POP::DAMAGE_ITEM_POP
      $game_player.actor.damage = item.name.to_s
      $game_player.actor.damage_pop = true
      $game_player.actor.damage_type = "Item"
  end  
  
  #--------------------------------------------------------------------------
  # ● Execute Hookshoot Effect
  #--------------------------------------------------------------------------    
  def execute_hookshot_effect_page(attacker, attack_id)
      return unless attacker.hookshot
      return unless self.name =~ /<Hookshot>/   
      return if self.battler != nil
      case $game_player.direction
         when 2
           xh = self.x 
           yh = self.y - 1
         when 4
           xh = self.x + 1 
           yh = self.y
         when 6
           xh = self.x - 1
           yh = self.y           
         when 8
           xh = self.x
           yh = self.y + 1         
      end           
      if passable_temp_id?(xh, yh)
         attacker.tool_effect = "Hookshot_Event"
         attacker.force_action_times = 999
         attacker.force_action = ""    
         distance = (self.x - $game_player.x).abs + (self.y - $game_player.y).abs
         return if distance <= 1         
         $game_temp.hookshot_position = [xh,yh] 
         $game_player.active_hookshot
         self.refresh
         @trigger = 0
         self.start
      end
  end  
  
  #--------------------------------------------------------------------------
  # ● Can Hold Treasure?
  #--------------------------------------------------------------------------        
  alias hookshot_can_hold_treasure can_hold_treasure?
  def can_hold_treasure?(attacker, attack_id)
      return true if attacker.tool_effect == "Hookshot"
      hookshot_can_hold_treasure(attacker, attack_id)
  end    
  
  #--------------------------------------------------------------------------
  # ● body_size
  #--------------------------------------------------------------------------
  def body_size
      return 0
  end
  
  #--------------------------------------------------------------------------
  # ● action_clear
  #--------------------------------------------------------------------------
  def action_clear
      @action = nil
  end
    
end

#===============================================================================
# ■ Game_Character
#===============================================================================
class Game_Character < Game_CharacterBase
    include XAS_ACTION
end

#===============================================================================
# ■  Game_Event
#===============================================================================
class Game_Event < Game_Character

  #--------------------------------------------------------------------------
  # * Refresh
  #--------------------------------------------------------------------------
  alias x_conditions_met conditions_met? 
  def conditions_met?(page)
      c = page.condition
      if c.variable_valid
         if c.variable_id == XAS_SYSTEM::HIT_ID and 
            c.variable_value == self.reaction_valid_attack_id
            return true
         end
       end
      x_conditions_met(page)
  end
  
end

#===============================================================================
# ■  XAS_Dispose
#===============================================================================
module XAS_Dispose
  
  #--------------------------------------------------------------------------
  # ● update
  #--------------------------------------------------------------------------  
  def update
      action_update
      super
      if @action.is_a?(Game_Action_XAS) and @action.done?
         self.step_anime = false if !$game_temp.battle_phase[0]
         self.set_base_pose
         self.update_battler_pose
         self.straighten
         self.action_clear
       end
  end
     
end

#===============================================================================
# ■  Game_Player
#===============================================================================
class Game_Player < Game_Character
  include XAS_Dispose
end

#===============================================================================
# ■  Game_Event
#===============================================================================
class Game_Event < Game_Character
  include XAS_Dispose
end

#===============================================================================
# ■ XAS_StopToAction 
#===============================================================================
module XAS_StopToAction
  
  #--------------------------------------------------------------------------
  # ● acting? 
  #--------------------------------------------------------------------------  
  def acting?
      return false if self.battler == nil
      return true if self.action != nil 
      return false
  end
  
  #--------------------------------------------------------------------------
  # ● moving? 
  #--------------------------------------------------------------------------  
  def moving?
      return (super or self.acting? or self.stop)
  end  
  
end

#===============================================================================
# ■ Game_Player  
#===============================================================================
class Game_Player < Game_Character
  include XAS_StopToAction
end

#===============================================================================
# ■ Game_Event  
#===============================================================================
class Game_Event < Game_Character
  attr_accessor :reaction_valid_attack_id
end

#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ TOOL - HIT EFFECT
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


#===============================================================================
# ■ XRXS_BattlerAttachment
#==============================================================================
module XRXS_BattlerAttachment 

  #--------------------------------------------------------------------------
  # ● Action Effect
  #--------------------------------------------------------------------------  
  def action_effect(bullet, action_id)
      return unless can_hit_base?(bullet, action_id)
      skill = $data_skills[action_id]
      user = bullet.action.user
      attacker = (user == nil ? nil : user.battler)     
      tar_invu = bullet.action.target_invunerable_duration     
      if can_disable_damage_for_enemy?
         execute_hit_field(attacker,skill, bullet , user, tar_invu )     
         return
      end
      #CAN HIT?
      return unless action_can_hit_target?(bullet, user, skill,tar_invu)
      if can_revive_battler(skill) 
         self.battler.hp = 1 
         self.restore_name
         self.set_base_pose
      end
      return false if self.battler.dead? and self.battler.is_a?(Game_Actor)
      #INVUNERABLE ACTIONS
      if target_invunerable_actions?(user, skill, bullet)
         execute_guard_effect(user, skill, bullet, tar_invu, false)
         return
      end   
      execute_hit_effect(attacker,skill, bullet , user, tar_invu )
      execute_shake_effect(skill,bullet,user) if self.battler.result.hp_damage > 0
      execute_death_effect if self.battler.dead? 
  end  
  
  #--------------------------------------------------------------------------
  # ● Can Hit Base?
  #--------------------------------------------------------------------------    
  def can_hit_base?(bullet, action_id)
     # return false if !self.target
      return false if self.battler == nil
      if self.battler.is_a?(Game_Enemy)
         if $game_temp.battle_phase[0] 
            return false if !self.target 
            return false if self.battler.abs_mode
         end  
      end         
      return false if self.battler.dead? and !$game_temp.battle_phase[0]
      return false if bullet == nil
      return false if action_id == nil or action_id <= 0
      return false if !self.can_update
      return false if $game_temp.pre_battle_phase > 0
      return false if $game_temp.hookshot_phase != 0
      return false if self.battler.invunerable 
      return true
  end  
  
  #--------------------------------------------------------------------------
  # ● Revive Battler
  #--------------------------------------------------------------------------    
  def can_revive_battler(skill)
      return false if self.battler == nil
      return false if !self.battler.dead?
      for sk in skill.effects
          if sk.code == 22 and sk.data_id == self.battler.death_state_id
             return true
             break
          end
      end
      return false
  end
    
  #--------------------------------------------------------------------------
  # ● Execute Shake Effect
  #--------------------------------------------------------------------------   
  def execute_shake_effect(skill,bullet,user)
      @knock_back_duration = 30 unless !$game_temp.battle_phase[0]
      return if !bullet.action.hit_shake
      if skill.note =~ /<Earthquake Hit>/
         $game_map.screen.start_shake(10, 6, 60)
      else
         $game_map.screen.start_shake(1, 15, 20)
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Execute Death Effect
  #--------------------------------------------------------------------------           
  def execute_death_effect
      if !$game_temp.battle_phase[0]
          death_in_field
      else
          death_in_battle 
      end      
  end
  
  #--------------------------------------------------------------------------
  # ● Death in Field
  #--------------------------------------------------------------------------             
  def death_in_field
      if self.battler.is_a?(Game_Actor)
         $game_party.refresh_leader
         $game_party.check_gameover
      else   
         self.execute_enemy_defeated_on_field
      end  
  end  
  
  #--------------------------------------------------------------------------
  # ● Death in Battle
  #--------------------------------------------------------------------------             
  def death_in_battle
      self.fade = false
      dead_in_turn(self)
      reset_dead_parameters(self)
  end  
  
  #--------------------------------------------------------------------------
  # ● Target Invunerable Actions?
  #--------------------------------------------------------------------------            
  def target_invunerable_actions?(user, skill, bullet)
      return true if self.battler.invunerable_actions.include?(skill.id)
      return false
  end
  
  #--------------------------------------------------------------------------
  # ● Shoot Target Shield
  #--------------------------------------------------------------------------          
  def shoot_target_shield?(bullet,user, skill)
      return false unless self.battler.shield
      return false if bullet.action.ignore_guard
      return true if face_direction?(bullet)
      return false
  end
  
  #--------------------------------------------------------------------------
  # ● Action can hit target?
  #--------------------------------------------------------------------------        
  def action_can_hit_target?(bullet, user, skill,tar_invu)
      return false if skill == nil
      return false if user == nil      
      return false if self.battler.invunerable_duration > 0    
      return false if self.disabled
      return false if self.can_collapse
      return false if self.erased
      return false if self.transparent
   #  return false if $game_temp.turn_sprite_phase != 0
      return false if skill.scope == 0
      return false if self.fade
      if bullet.action.first_impact_time > 0
         return false 
      end
      unless bullet.action.all_damage  
          if skill.scope >= 7
             if user.battler.is_a?(Game_Actor)
                return false if self.battler.is_a?(Game_Enemy)
             else
                return false if self.battler.is_a?(Game_Actor)           
             end
          else
             if user.battler.is_a?(Game_Actor)
                return false if self.battler.is_a?(Game_Actor)
             else
                return false if self.battler.is_a?(Game_Enemy)           
             end         
          end
      end
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● Execute Hit Effect
  #--------------------------------------------------------------------------      
  def execute_hit_effect(attacker,skill, bullet , user, tar_invu)
      shoot_effect_before_damage(skill, bullet, user)
      execute_battler_skill_effect(attacker ,skill, user)
      if target_missed?(attacker)
         self.battler.invunerable_duration = 30
         return 
      end      
      shoot_effect_after_damage(skill, bullet, user) if can_damage_after_effect?
      self.battler.invunerable_duration = tar_invu
      execute_blow_effect(skill,bullet)
      execute_animation(skill, bullet, user)
      execute_tool_effects(skill, bullet , user)
      execute_hit_in_turn if can_hit_in_turn?
      check_piercing(bullet)
      set_directions(user)
  end
 
  #--------------------------------------------------------------------------
  # ● Can Hit In Turn
  #--------------------------------------------------------------------------  
  def can_hit_in_turn?
      return false if !self.battler.is_a?(Game_Actor)   
      return false if self != $game_temp.target_turn
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● Execute Hit in Turn
  #--------------------------------------------------------------------------                  
  def execute_hit_in_turn
      $game_system.escape_phase[1] = 0 if self.battler.restriction >= 4
  end  
  
  #--------------------------------------------------------------------------
  # ● Check Piercing
  #--------------------------------------------------------------------------        
  def check_piercing(bullet)
      return if bullet.action.piercing
      bullet.action.duration = 10
  end
    
  #--------------------------------------------------------------------------
  # ● Execute Tool Effects
  #--------------------------------------------------------------------------              
  def execute_tool_effects(skill, bullet , user)
      execute_hit_action_effect(skill, bullet, user)
  end
    
  #--------------------------------------------------------------------------
  # ● Execute Battler Skill Effect
  #--------------------------------------------------------------------------          
  def execute_battler_skill_effect(attacker ,skill, user)
      self.battler.item_apply_schala(attacker, skill)
  end
  
  #--------------------------------------------------------------------------
  # ● Target Missed?
  #--------------------------------------------------------------------------        
  def target_missed?(attacker)
      if self.battler.result.missed 
         self.battler.damage = XAS_WORD::MISSED
         self.battler.damage_pop = true         
         return true
      end    
      if self.battler.result.evaded
         self.battler.damage = XAS_WORD::EVADED
         self.battler.damage_pop = true             
         return true 
      end  
      return false
  end  
  #--------------------------------------------------------------------------
  # ● Shoot Effect Before Damage
  #--------------------------------------------------------------------------        
  def shoot_effect_before_damage(skill, bullet, user)
  end
  
  #--------------------------------------------------------------------------
  # ● Shoot Effect After Damage
  #--------------------------------------------------------------------------          
  def shoot_effect_after_damage(skill, bullet, user)

  end
  
  #--------------------------------------------------------------------------
  # ● Execute Hit Action Effect
  #--------------------------------------------------------------------------             
  def execute_hit_action_effect(skill, bullet, user)
      return if bullet.action.hit_action == 0
      self.battler.invunerable_duration = 1
      bullet.shoot(bullet.action.hit_action)
      bullet.action.duration = 9
      bullet.action.multi_hit = false
  end
  
  #--------------------------------------------------------------------------
  # ● Can Damage Effect
  #--------------------------------------------------------------------------          
  def can_damage_after_effect?
      return false if self.battler.damage == nil
      return false unless self.battler.damage.is_a?(Numeric)
      return true
  end  
  
  #--------------------------------------------------------------------------
  # ● Execute Blow Effect
  #--------------------------------------------------------------------------      
  def execute_blow_effect(skill,bullet)
      execute_hookshot_effect(skill,bullet)
  end
  
  #--------------------------------------------------------------------------
  # ● Execute Hookshot_effect
  #--------------------------------------------------------------------------      
  def execute_hookshot_effect(skill,bullet)
      return unless bullet.hookshot
      bullet.force_action_times = 30
      bullet.force_action = "Toward Player"
      bullet.direction_fix = true
  end

  #--------------------------------------------------------------------------
  # ● Execute Animation
  #--------------------------------------------------------------------------        
  def execute_animation(skill, bullet, user)    
      self.animation_id = skill.animation_id if skill.animation_id != 0
      user_animation = bullet.action.third_animation_id
      user.animation_id = user_animation if user_animation != 0
  end  
    
  #--------------------------------------------------------------------------
  # ● Knock Back Disable
  #--------------------------------------------------------------------------      
  def knock_back_disable
    return false
  end
  
  #--------------------------------------------------------------------------
  # ● Dead?
  #--------------------------------------------------------------------------          
  def dead?
    return self.battler == nil ? false : self.battler.dead?
  end
  
end


#===============================================================================
# ■ XRXS_BattlerAttachment
#==============================================================================
module XRXS_BattlerAttachment 
 
 #--------------------------------------------------------------------------
 # ● Execute Guard Effect
 #--------------------------------------------------------------------------      
 def execute_guard_effect(attacker, skill, bullet, inv, erase_bullet = true)
     self.battler.invunerable_duration = inv
     damage_pop(XAS_WORD::GUARD)
     guard_animation_id = XAS_ANIMATION::GUARD_ANIMATION_ID
     self.animation_id = guard_animation_id if guard_animation_id != 0   
     if bullet != nil 
        bullet.erase if erase_bullet      
     end   
 end
   
 #--------------------------------------------------------------------------
 # ● Can Attack Effect
 #--------------------------------------------------------------------------      
 def damage_pop(text)
     self.battler.damage = text
     self.battler.damage_pop = true
 end
 
 #--------------------------------------------------------------------------
 # ● Set Directions
 #--------------------------------------------------------------------------      
 def set_directions(attacker)
     return if $game_temp.forced_battle
     return unless self.battler.result.hp_damage > 0
     return if self == attacker
     target = attacker.direction
     case target
          when 2
             self.direction = 8
          when 4
             self.direction = 6
          when 6
             self.direction = 4
          when 8  
             self.direction = 2     
     end
     
 end   
 
 #--------------------------------------------------------------------------
 # ● Shd Direction?
 #--------------------------------------------------------------------------      
 def face_direction?(attacker)
     target = self.direction  
     case target
          when 2
             return true if attacker.direction == 8
          when 4
             return true if attacker.direction == 6
          when 6
             return true if attacker.direction == 4
          when 8  
             return true if attacker.direction == 2     
     end
     return false
 end   
 
end   

#===============================================================================
# ■ XRXS_BattlerAttachment
#==============================================================================
module XRXS_BattlerAttachment 
  
  #--------------------------------------------------------------------------
  # ● Can Disable Damage For Enemy
  #--------------------------------------------------------------------------    
  def can_disable_damage_for_enemy?
#      return false if $game_system.abs_damage_enemies
      return false if $game_temp.battle_phase[0]
      return false if !self.battler.is_a?(Game_Enemy)
      return false if self.battler.abs_mode
      return true 
  end
    
  #--------------------------------------------------------------------------
  # ● Execute Hit Field
  #--------------------------------------------------------------------------  
  def execute_hit_field(attacker,skill, bullet , user, tar_invu )   
      execute_animation(skill, bullet, user)
      execute_tool_effects(skill, bullet , user)
      set_directions(user) 
      execute_shake_effect(skill,bullet,user)
      execute_blow_effect(skill,bullet)
      check_piercing(bullet)
      if self.battler.paralyze
         @knock_back_duration = SCHALA_SYSTEM::BATTLER_PARALYZE_DURATION
      end   
  end    
  
end 

#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ BATTLER - INITIALIZE
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


#===============================================================================
# ■ Game Character
#==============================================================================
class Game_Character < Game_CharacterBase
  
  #--------------------------------------------------------------------------
  # ● Update Battler
  #--------------------------------------------------------------------------      
  def update_battler      
#      update_battler_pose
      update_battler_parameters
      update_battler_stop_movement
      update_battler_knockbacking      
      unless self.battler.hp == 0
          update_battler_states_effect
      else
          update_battler_defeat_process
      end 
  end  

end

#===============================================================================
# ■ Game Player
#===============================================================================
class Game_Player < Game_Character
  include XRXS_BattlerAttachment
  
  #--------------------------------------------------------------------------
  # ● Battler
  #--------------------------------------------------------------------------  
  def battler
      return $game_party.members[0]
  end
  
end

#===============================================================================
# ■ Game Follower
#===============================================================================
class Game_Follower < Game_Character
  include XRXS_BattlerAttachment

  #--------------------------------------------------------------------------
  # ● Battler
  #--------------------------------------------------------------------------    
  def battler
      return $game_party.members[@member_index]
  end
end

#===============================================================================
# ■ Game_Vehicle
#===============================================================================
class Game_Vehicle < Game_Character
  include XRXS_BattlerAttachment
  
  #--------------------------------------------------------------------------
  # ● Battler
  #--------------------------------------------------------------------------      
  def battler
      return @battler
  end  
end  

#===============================================================================
# ■ Game Event
#===============================================================================
class Game_Event < Game_Character
  
  include XRXS_BattlerAttachment
  
  #--------------------------------------------------------------------------
  # ● Battler
  #--------------------------------------------------------------------------    
  def battler
    return @battler
  end
  
 #--------------------------------------------------------------------------
 # ● Battler?
 #--------------------------------------------------------------------------           
 def battler?
     return false if self.erased
     return false if self.battler == nil
     return false if self.dead?
     return true
 end  
 
  #--------------------------------------------------------------------------
  # ● Refresh
  #--------------------------------------------------------------------------    
  alias xrxs64c_refresh refresh
  def refresh
      xrxs64c_refresh
      self.battler_recheck
  end
     
  #--------------------------------------------------------------------------
  # ● Battler Recheck
  #--------------------------------------------------------------------------    
  def battler_recheck
      return if @battler != nil
      return if @page == nil
      @enemy_id = 0
      if self.name =~ /<Enemy(\d+)>/i
         @enemy_id = $1.to_i    
         return if @enemy_id <= 0
         @battler = Game_Enemy.new(1, @enemy_id)
         self.force_update = true if self.battler.sensor_range >= 15         
         set_original_name
      end  
  end
    
  #--------------------------------------------------------------------------
  # ● Battler Recheck
  #--------------------------------------------------------------------------      
  def enemy_id
      return @enemy_id
  end
  
  #--------------------------------------------------------------------------
  # ● body_size
  #--------------------------------------------------------------------------        
  def body_size
      if self.battler != nil
         return self.battler.body_size
      else
         return 0
      end  
  end

end


#===============================================================================
# ■ Game_Battler
#===============================================================================
class Game_Battler 
  attr_accessor :sensor_range
  attr_accessor :body_size
  attr_accessor :breath_effect
  attr_accessor :float_effect
  attr_accessor :breath_duration
  attr_accessor :fast_breath_effect
  attr_accessor :attack_animation_id
  attr_accessor :float_effect
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------      
  alias x_e_initialize initialize 
  def initialize  
      x_e_initialize
      @sensor_range = SCHALA_SYSTEM::BATTLE_SENSOR_RANGE
      @body_size = 0
      @breath_effect = false
      @breath_duration = 0
      @fast_breath_effect = false
      @attack_animation_id = 0
      @float_effect = [false,0,0,0]
  end  
    
end

#===============================================================================
# ■ Game_Enemy
#===============================================================================
class Game_Enemy < Game_Battler
    
  #--------------------------------------------------------------------------
  # ● Usable Item Conditions Met?
  #--------------------------------------------------------------------------       
  def usable_item_conditions_met?(item)
      movable? 
  end  
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------      
  alias x_e2_initialize initialize 
  def initialize(index, enemy_id)
      x_e2_initialize(index, enemy_id)
      enemy = $data_enemies[@enemy_id]
      setup_enemy_note(enemy)
  end  
  
  #--------------------------------------------------------------------------
  # ● Setup X Note Elements
  #--------------------------------------------------------------------------          
  def setup_enemy_note(enemy)
      if enemy.note =~ /<Sensor Range = (\d+)>/
         @sensor_range = $1.to_i
      end   
      if enemy.note =~ /<Body Size = (\d+)>/
         @body_size = $1.to_i
      end
      if enemy.note =~ /<Attack Animation = (\d+)>/
         @attack_animation_id = $1.to_i
      end  
      if enemy.note =~ /<Death Zoom = (\d+)>/
         @death_zoom_effect = $1.to_i
      end 
      if enemy.note =~ /<Knockback Duration = (\d+)>/
         @knockback_duration = $1.to_i
      end       
      if enemy.note =~ /<Breath Effect>/  
         @breath_effect = true
      end
      if enemy.note =~ /<Float Effect>/  
         @float_effect[0] = true
      end      
      invunerable_actions_ids = XAS_BA_ENEMY::INVUNERABLE_ACTIONS[@enemy_id]
      if invunerable_actions_ids != nil
         @invunerable_actions = invunerable_actions_ids
      end   
  end  
  
end  

#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ BATTLER - EVENT SENSOR
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


#===============================================================================
# ■ XRXS_Enemy_Sensor
#===============================================================================
module XRXS_EnemySensor
  
  #--------------------------------------------------------------------------
  # ● Update Sensor
  #--------------------------------------------------------------------------        
  def update_sensor
      sensor_area = self.battler.sensor_range
      distance = ($game_player.x - self.x).abs + ($game_player.y - self.y).abs
      enable   = (distance <= sensor_area)
      if can_pre_battle_phase?(enable) and !self.defeated[0] and
         !$game_party.encounter_none?
         self.first_target = true
         self.balloon_id = SCHALA_SYSTEM::EVENT_SENSOR_BALLOON_ID
         battle_start
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Can Pre Battle Phase
  #--------------------------------------------------------------------------          
  def can_pre_battle_phase?(enable)
      return false if $game_party.members.size == 0      
      return false if !enable
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● Can Update Sensor
  #--------------------------------------------------------------------------            
  def can_update_sensor?
      return false if $game_temp.battle_phase[0]
      return false if self.battler == nil
      return false if self.battler.abs_mode
      return false if !$game_temp.global_sensor_active[0]
      return false if @knock_back_duration != nil
      return false if self.dead? 
      return false if self.erased 
      return false if self.defeated[0]
      return false if self.stop
      return false if self.disabled
      return true
  end
  
end

#===============================================================================
# ■  Game Event
#===============================================================================
class Game_Event < Game_Character
  
  attr_accessor :sensor_enable

  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------            
  alias x_sensor_initialize initialize
  def initialize(map_id, event)
      @sensor_enable = false
      x_sensor_initialize(map_id, event)
  end  
  
  #--------------------------------------------------------------------------
  # ● Conditions Met
  #--------------------------------------------------------------------------
  alias x_sensor_conditions_met conditions_met?
  def conditions_met?(page)
      x_sensor_conditions_met(page)   
  end
    
end

#===============================================================================
# ■  Game Event
#===============================================================================
class Game_Character < Game_CharacterBase
      include XRXS_EnemySensor
end

#===============================================================================
# ■  Game Character
#===============================================================================
class Game_Character < Game_CharacterBase
      attr_writer   :opacity
end
    
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ BATTLER - ACTION
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

#===============================================================================
# ■ Game Character
#==============================================================================
class Game_Character < Game_CharacterBase
  
  #--------------------------------------------------------------------------
  # ● update_battler_parameters
  #--------------------------------------------------------------------------    
  def update_battler_parameters
      @stop_count = -1 if can_stop_battler? 
      self.battler.invunerable_duration -= 1 if self.battler.invunerable_duration > 0 
  end    
  
  #--------------------------------------------------------------------------
  # ● Can Stop Battler
  #--------------------------------------------------------------------------      
  def can_stop_battler? 
      return false if self.is_a?(Game_Player)
      return true if self.knockbacking?
      return true if self.dead?
      return true if self.stop 
      return false 
  end
  
  #--------------------------------------------------------------------------
  # ● Can Stop Battler Movement
  #--------------------------------------------------------------------------            
  def can_stop_battler_movement?
      return true if self.battler.restriction >= 4
      return false if self.dead?   
      return false
  end  
  
  #--------------------------------------------------------------------------
  # ● Impact
  #--------------------------------------------------------------------------              
  def enable_hit(enable = true)
      return if self.tool_id == 0
      return if self.action == nil
      self.action.impact = enable
      self.action.clear_hit[1] = 5 if self.action.clear_hit[0] and enable
  end
  
  #--------------------------------------------------------------------------
  # ● Update Battler Stop Movement
  #--------------------------------------------------------------------------              
  def update_battler_stop_movement 
      unless can_stop_battler_movement?
          @stop = false   
          return
      end
      @knock_back_duration = nil
      @stop = true      
      @step_anime = false if self.is_a?(Game_Event)
      if self.battler.restriction >= 4
         make_pose("_Hit", 2) unless !$game_temp.battle_phase[0]
      else
         set_base_pose
      end  
  end
    
  #--------------------------------------------------------------------------
  # ● Stop
  #--------------------------------------------------------------------------                
  def stop_test
      return false if self.battler == nil
      return true if self.restriction >= 4
      return true if @knock_back_duration != nil
      return false
  end  
  
  #--------------------------------------------------------------------------
  # ● Update Battler Knobacking
  #--------------------------------------------------------------------------            
  def update_battler_knockbacking
       return unless self.knockbacking?
       @pattern = 0
       @knock_back_duration -= 1 if can_remove_knockback?
       make_pose("_Hit", 2)        
       if @knock_back_duration <= 0 and $game_temp.target_phase == nil
          @knock_back_duration = nil          
          set_base_pose
       end
  end  
    
  #--------------------------------------------------------------------------
  # ● Can Remove Knockback
  #--------------------------------------------------------------------------              
  def can_remove_knockback?
      return false if self.battler.dead?
      return true
  end

  #--------------------------------------------------------------------------
  # ● knockbacking?
  #--------------------------------------------------------------------------            
  def knockbacking?
      return false if self.battler == nil
      return false if @stop
      return true if @knock_back_duration != nil
      return false
  end

  #--------------------------------------------------------------------------
  # ● collapsing?
  #--------------------------------------------------------------------------          
  def collapsing?
      return self.collapse_duration.to_i > 0
  end
  
end

#===============================================================================
# ■ XAS_DamageStop
#===============================================================================
module XAS_DamageStop
  
  #--------------------------------------------------------------------------
  # ● Acting
  #--------------------------------------------------------------------------             
  def acting?
      return (super or self.knockbacking? or self.collapsing? or self.stop)
  end
    
end

#===============================================================================
# ■ Game_Player
#===============================================================================
class Game_Player < Game_Character
      include XAS_DamageStop
end

#===============================================================================
# ■ Game_Event
#===============================================================================
class Game_Event < Game_Character
      include XAS_DamageStop
end
    
#===============================================================================
# ■ Game Character
#==============================================================================
class Game_Character < Game_CharacterBase
  
  #--------------------------------------------------------------------------
  # ● Invunerable
  #--------------------------------------------------------------------------      
  def invunerable(enable = false)
      return if @battler == nil or @battler.dead?
      @battler.invunerable = enable
  end  
  
  #--------------------------------------------------------------------------
  # ● Fast Breath
  #--------------------------------------------------------------------------        
  def fast_breath(enable = true)
     return if @battler == nil or @battler.dead?
     @battler.fast_breath_effect = enable
  end  
  
end

#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ BATTLER - MOVE SPEED
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


#==============================================================================
# ■ Game_Character
#==============================================================================
class Game_Character < Game_CharacterBase
  
  include XAS_BA
  attr_accessor :move_speed  

 #--------------------------------------------------------------------------
 # ● Update Animation
 #--------------------------------------------------------------------------      
  def update_animation
      super
      update_force_move_routine_move
  end 
    
 #--------------------------------------------------------------------------
 # ● Update Force Move Routine Move
 #--------------------------------------------------------------------------        
  def update_force_move_routine_move
      return if @force_action == ""
      return if @move_route == nil
      command = @move_route.list[@move_route_index]
      return if command == nil
      if command.code == ROUTE_PLAY_SE    
         params = command.parameters
         params[0].play 
         advance_move_route_index
      end   
  end
 
 #--------------------------------------------------------------------------
 # ● Update Routine Move
 #--------------------------------------------------------------------------      
 alias x_update_routine_move update_routine_move
 def update_routine_move
     return if @force_action_times > 0
     x_update_routine_move
 end
 
 #--------------------------------------------------------------------------
 # ● Can Cancel Move Type Custom
 #--------------------------------------------------------------------------    
  alias x_move_speed_process_move_command process_move_command
  def process_move_command(command)
      return if can_cancel_move_type_custom?(command)
      x_move_speed_process_move_command(command)
  end
  
 #--------------------------------------------------------------------------
 # ● Can Cancel Move Type Custom
 #--------------------------------------------------------------------------    
  def can_cancel_move_type_custom?(command)
      return true if command == nil
      return true if @force_action_times > 0
      return false
  end  
  
end  

#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ BATTLER - STATES
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


#==============================================================================
# ■ Game_Battler
#==============================================================================
class Game_Battler

  attr_accessor :state_loop_effect_time
  attr_accessor :state_loop_speed
  attr_accessor :state_duration 
  attr_accessor :state_string
  attr_accessor :state_string_time
  
 #--------------------------------------------------------------------------
 # ● Initialize
 #--------------------------------------------------------------------------  
  alias x_state_initialize initialize
  def initialize
      @state_duration = []
      @state_loop_effect_time = []
      @state_loop_speed = []
      @state_string = ""
      @state_string_time = 0
      x_state_initialize
  end
    
 #--------------------------------------------------------------------------
 # ● Add State
 #--------------------------------------------------------------------------    
  alias x_add_state add_state
  def add_state(state_id)
      unless @states.include?(state_id)
          state = $data_states[state_id] 
          xas_add_state(state)
      end        
      x_add_state(state_id)
  end 
  
 #--------------------------------------------------------------------------
 # ● Xas Add State
 #--------------------------------------------------------------------------      
  def xas_add_state(state)
      time_durarion = $data_states[state.id].min_turns rescue nil
      return if time_durarion == nil
      if time_durarion == 0 or time_durarion == 1 or
         $data_states[state.id].auto_removal_timing == 0
         time_durarion = 20
      end   
      @state_duration[state.id] = 60 * time_durarion
      @state_loop_effect_time[state.id] = 0 
      loop_speed = $data_states[state.id].max_turns  
      if $data_states[state.id].auto_removal_timing == 0 or loop_speed < 120
         loop_speed = 120
      end   
      @state_loop_speed[state.id] = loop_speed
      execute_damage_state(state,0)
  end      
 
 #--------------------------------------------------------------------------
 # ● Remove State
 #--------------------------------------------------------------------------        
  alias x_remove_state remove_state
  def remove_state(state_id)
      if state?(state_id)
         state = $data_states[state_id] 
         xas_remove_state(state)
      end  
      x_remove_state(state_id)      
  end    
    
 #--------------------------------------------------------------------------
 # ● XAS Remove State
 #--------------------------------------------------------------------------         
  def xas_remove_state(state)
      @state_duration.delete(state.id)  
      @state_loop_effect_time.delete(state.id)  
      @state_loop_speed.delete(state.id)
      execute_damage_state(state,1)
  end  

 #--------------------------------------------------------------------------
 # ● Execute_Damage_State
 #--------------------------------------------------------------------------           
  def execute_damage_state(state,type)
      return if state == nil or state.id == 1
      case type
         when 0
             damage = "+ " + state.name.to_s
         when 1  
             damage = "- " + state.name.to_s
      end
      @state_string = damage
      @state_string_time = 10     
  end  
  
end

#==============================================================================
# ■ Game_Character
#==============================================================================
class Game_Character < Game_CharacterBase
  
 #--------------------------------------------------------------------------
 # ● Update Battler States Effect
 #--------------------------------------------------------------------------    
 def update_battler_states_effect
     return if $game_temp.target_phase != nil
     return if $game_temp.command_phase != 0
     update_state_string_pop
     return unless can_update_states_effect?
     for i in self.battler.states
         state = $data_states[i.id]  
         if state == nil or self.battler.state_duration[state.id] == nil or
            self.battler.state_loop_effect_time[state.id] == nil or
            self.battler.state_loop_speed[state.id] == nil
            self.battler.remove_state(state.id)
            next
            return
         end           
         update_state_loop(state)
         update_remove_state(state)
     end  
       
 end  
  
 #--------------------------------------------------------------------------
 # ● Update Pre State Setup
 #--------------------------------------------------------------------------        
 def update_state_abs_effects(state)
     for i in state.features
        if can_execute_state_slip_damage?(i)           
           if i.data_id == 7
              dmg = (self.battler.mhp * i.value).truncate
              if dmg == 0
                 if i.value >= 0.01
                    dmg = 1
                 else
                    dmg = -1
                 end
              end               
              self.battler.damage = -dmg
              self.battler.damage_pop = true
              self.battler.hp -= -dmg
           elsif i.data_id == 8
              dmg = (self.battler.mmp * i.value).truncate
              if dmg == 0
                 if i.value >= 0.01
                    dmg = 1
                 else
                    dmg = -1
                 end
              end 
              self.battler.damage = -dmg
              self.battler.damage_pop = true
              self.battler.damage_type = "Mp"
              self.battler.mp -= -dmg           
           end
           if self.battler.dead?
              check_collapsed_battlers
              check_battle_end
           end              
        end
      end
 end
   
 #--------------------------------------------------------------------------
 # ● Can Execute State Slip Damage
 #--------------------------------------------------------------------------         
 def can_execute_state_slip_damage?(state)
     return false if state.code != 22
     return false if !state.data_id.between?(7,8)
     return true
 end  
 
 #--------------------------------------------------------------------------
 # ● Update State Loop
 #--------------------------------------------------------------------------      
 def update_state_loop(state)
     self.battler.state_loop_effect_time[state.id] += 1
     if self.battler.state_loop_effect_time[state.id] > self.battler.state_loop_speed[state.id]
        self.battler.state_loop_effect_time[state.id] = 0
        update_state_abs_effects(state)
        if state.note =~ /<Animation ID = (\d+)>/
           state_anime = $1.to_i
           if state_anime != nil
              self.animation_id = state_anime
           end
        end    
        execute_states_effects(state)          
     end          
 end
 
 #--------------------------------------------------------------------------
 # ● Execute States Effect
 #--------------------------------------------------------------------------       
 def execute_states_effects(state)         
 end
 
 #--------------------------------------------------------------------------
 # ● Update Remove State
 #--------------------------------------------------------------------------       
 def update_remove_state(state)
     self.battler.state_duration[state.id] -= 1
     if self.battler.state_duration[state.id] <= 0     
        self.battler.remove_state(state.id) 
     end          
 end
 
 #--------------------------------------------------------------------------
 # ● Can Update States Effect
 #--------------------------------------------------------------------------      
  def can_update_states_effect?
      return false if $game_temp.turn_sprite_phase != 0
      return false if self.dead?
      return false if self.battler.states == nil
      return false if self.battler.states.size == 0
      return false if self.battler.state_duration == []
      return true
  end

 #--------------------------------------------------------------------------
 # ● Update State String Pop
 #--------------------------------------------------------------------------       
  def update_state_string_pop
      return false if self.battler.state_string_time == 0
      self.battler.state_string_time -= 1
      if self.battler.state_string_time == 0
         popup_status_effect
      end  
  end  
    
 #--------------------------------------------------------------------------
 # ● Popup Statues Effect
 #--------------------------------------------------------------------------         
 def popup_status_effect
     return if self.battler == nil
     self.battler.state_string_time = 0
     self.battler.damage = self.battler.state_string
     self.battler.damage_pop = true
     self.battler.state_string = ""     
 end
   
end  

#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ BATTLER - DEFEAT PROCESS
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

#===============================================================================
# ■ Scene Base
#===============================================================================
class Scene_Base  
  
  #--------------------------------------------------------------------------
  # ● Check Gameover
  #--------------------------------------------------------------------------              
  alias schala_check_gameover check_gameover
  def check_gameover
      return #if $game_temp.battle_phase[0]
      schala_check_gameover
  end
    
end  

#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase
  
  attr_accessor :collapse_duration
  attr_accessor :battler_visible
  attr_writer   :opacity
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------            
  alias x_collapse_initialize initialize
  def initialize
      @collapse_duration = 0
      x_collapse_initialize
  end  
  
end

#===============================================================================
# ■ Game Character
#===============================================================================
class Game_Character < Game_CharacterBase

  #--------------------------------------------------------------------------
  # ● Update Battler Defeat Process
  #--------------------------------------------------------------------------              
  def update_battler_defeat_process
  end
  
  #--------------------------------------------------------------------------
  # ● Can Check Enemy Defeated?
  #--------------------------------------------------------------------------            
  def can_check_enemy_defeated?  
      return false if self.battler.is_a?(Game_Actor)
      return false if self.battler.defeated
      return false if !self.can_collapse
      return true
  end     
  
  #--------------------------------------------------------------------------
  # ● Execute Enemy Defeaed Process
  #--------------------------------------------------------------------------         
   def execute_enemy_defeated_process
       self.battler.defeated = true
       self.through = true
       @knock_back_duration = 121
       enemy = $data_enemies[self.battler.enemy_id]
       make_treasure(enemy)
       @collapse_duration = 120
       execute_active_switch(enemy)
       execute_defeated_animation(enemy)
   end    
 
  #--------------------------------------------------------------------------
  # ● Execute Enemy Defeaed On Field
  #--------------------------------------------------------------------------         
   def execute_enemy_defeated_on_field
       self.battler.defeated = true
       self.through = true
       self.can_collapse = true      
       if self.battler.disable_respawn_time   
           self.defeated[0] = true  
           self.defeated[1] = 9999999999
       else  
          self.defeated[0] = true  
          self.defeated[1] = $game_system.playtime
       end
       @knock_back_duration = 121
       enemy = $data_enemies[self.battler.enemy_id]
       make_treasure(enemy)
       @collapse_duration = 120
       execute_gain_exp_gold(enemy)
       execute_active_switch(enemy)
       execute_defeated_animation(enemy)
       Sound.play_enemy_collapse
   end       
   
  #--------------------------------------------------------------------------
  # ● Execute Gain Exp Gold
  #--------------------------------------------------------------------------           
  def execute_gain_exp_gold(enemy)  
      exp = self.battler.exp
      ap = self.battler.ap
      alive_actors = []
      index = 0
      for i in $game_party.members
          alive_actors.push(i) if !i.dead?
          index += 0
          break if index > ($game_party.max_battle_members - 1)
      end
      for i in alive_actors
          level_old = i.level
          i.gain_exp(exp)
          i.gain_ap(ap)
          execute_level_effect_2(i) if i.level > level_old
      end
      $game_party.gain_gold(self.battler.gold)
  end  
  
  #--------------------------------------------------------------------------
  # ● Execute Level Effect
  #--------------------------------------------------------------------------             
  def execute_level_effect_2(i)
      i.damage = XAS_WORD::LEVEL_UP
      i.damage_pop = true
      i.animation_id = XAS_ANIMATION::LEVEL_UP_ANIMATION_ID
  end   
   
   
end   
 
#===============================================================================
# ■ Game Party
#===============================================================================
class Game_Party < Game_Unit
  
 #--------------------------------------------------------------------------
 # ● Setup Starting Members  
 #--------------------------------------------------------------------------      
  alias x_old_level_setup_starting_members setup_starting_members  
  def setup_starting_members  
      x_old_level_setup_starting_members    
      for actor in $game_party.members
          actor.old_level = actor.level
      end
  end
  
end

#===============================================================================
# ■ Sprite Character
#==============================================================================
class Sprite_Character < Sprite_Base  
  
  #--------------------------------------------------------------------------
  # ● Update Collapse Effects
  #--------------------------------------------------------------------------            
  def update_collaspse_effects
      return if !self.visible
      if @character.can_collapse
         update_collapse_duration
         return unless can_collapse_effects?
         update_collpase_zoom_effects
         update_exp_gold_pop
      else
         update_knockback_shake_effect
      end
  end
    
  #--------------------------------------------------------------------------
  # ● Update Update Knockback Shake Effect
  #--------------------------------------------------------------------------              
  def update_knockback_shake_effect
      return false if !XAS_BA::KNOCKBACKING_SHAKE 
      return false if @character.battler == nil
      return false if @character.battler.is_a?(Game_Actor) and @character.battler.dead?
      self.x = self.x + rand(5) 
  end  
  
  #--------------------------------------------------------------------------
  # ● Can Collapse Effects
  #--------------------------------------------------------------------------              
  def can_collapse_effects?
      return false if @character.battler.is_a?(Game_Actor)
      return false unless @character.dead? 
      return false if @character.erased    
      return false if !self.visible
      return true
  end  
  
  #--------------------------------------------------------------------------
  # ● Update Exp Gold Pop
  #--------------------------------------------------------------------------              
  def update_exp_gold_pop
      return unless XAS_DAMAGE_POP::DAMAGE_EXP_GOLD_POP 
      exp_pop = @character.battler.exp
      gold_pop = @character.battler.gold
      case @character.collapse_duration
           when 110
                enemy = $data_enemies[@character.battler.enemy_id]
#                @character.make_treasure(enemy)       
           when 80
             if exp_pop != 0
                word = XAS_WORD::EXP
                @character.battler.damage = word + " " + exp_pop.to_s
                @character.battler.damage_pop = true
                @character.battler.damage_type = "Exp"
             end  
           when 40
             if gold_pop != 0
                word = $data_system.currency_unit
                @character.battler.damage = word + " " + gold_pop.to_s
                @character.battler.damage_pop = true
                @character.battler.damage_type = "Gold"
             end               
      end      
  end
  
  #--------------------------------------------------------------------------
  # ● Update Collapse Duration
  #--------------------------------------------------------------------------              
  def update_collapse_duration
      @character.collapse_duration -= 1
      self.opacity -= 5
      if @character.collapse_duration <= 0
         self.visible = false
         self.opacity = 0
         self.zoom_x = 1.00
         self.zoom_y = 1.00
         @character.erase
      end  
  end  

  #--------------------------------------------------------------------------
  # ● Update Collapse Zoom Effects
  #--------------------------------------------------------------------------                
  def update_collpase_zoom_effects
      case @character.battler.death_zoom_effect
          when 1
             @character.zoom_y += 0.05
             @character.zoom_x -= 0.01            
          when 2  
             @character.zoom_y -= 0.01
             @character.zoom_x += 0.03             
          when 3  
             @character.zoom_y += 0.03
             @character.zoom_x += 0.03              
          when 4   
             @character.zoom_y -= 0.005
             @character.zoom_x -= 0.005
          when 5   
            case @character.collapse_duration
                when 60..120
                 @character.zoom_y -= 0.01
                 @character.zoom_x += 0.06                             
                when 0..59  
                 @character.zoom_y += 0.2
                 @character.zoom_x -= 0.1 
             end
      end
  end  
  
end

#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ BATTLER - TREASURE
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


#===============================================================================
# ■ XAS_BA_Item_Drop
#==============================================================================
module XAS_BA_ItemDrop
  
  #--------------------------------------------------------------------------
  # ● Defeat Process
  #--------------------------------------------------------------------------               
  def make_treasure(enemy)
      @treasure_appearance_rate = 0
      treasure = nil 
      pass = false
      for i in 1...5
         pass = true if $game_player.passable_position?(self.x,self.y, i * 2)  
      end
      return if !pass
      for di in enemy.drop_items
           next if di.kind == 0
           set_treasure_appearance_rate(di.denominator)
           @treasure_appearance_rate = 1 if @treasure_appearance_rate < 1
           next if rand(@treasure_appearance_rate) != 0
           if di.kind == 1
              treasure = $data_items[di.data_id]
              tr_id = treasure.id
           elsif di.kind == 2
              treasure = $data_weapons[di.data_id]
              tr_id = treasure.id
           elsif di.kind == 3
              treasure = $data_armors[di.data_id]
              tr_id = treasure.id
           end
           break if treasure != nil 
       end   
       create_event_treasure(treasure,di,tr_id) if treasure != nil
   end  
     
  #--------------------------------------------------------------------------
  # ● Set Treasure Appearance Rate
  #--------------------------------------------------------------------------   
   def set_treasure_appearance_rate(treasure_rate)
       @treasure_appearance_rate = treasure_rate
       @treasure_appearance_rate /= 2 if can_double_treasure_appearance_rate?
  end
     
  #--------------------------------------------------------------------------
  # ● Can Double Treasure Appearance Rate?
  #--------------------------------------------------------------------------  
  def can_double_treasure_appearance_rate?
      return true if $game_party.drop_item_double?
      return false
  end
    
  #--------------------------------------------------------------------------
  # ● Create Event Treasure
  #--------------------------------------------------------------------------                  
   def create_event_treasure(treasure,di,tr_id)
       command = RPG::MoveCommand.new
       command.code = 14
       command.parameters = [0,0]
       route = RPG::MoveRoute.new
       route.repeat = false
       route.list = [command, RPG::MoveCommand.new]         
       page = RPG::Event::Page.new
       page.move_type = 3
       page.move_route = route
       page.move_frequency = 6
       page.priority_type = 1
       page.trigger = 1
       page.through = true
       event = RPG::Event.new(self.x, self.y)
       event.pages = [page]       
       event = RPG::Event.new(self.x, self.y)
       token = Token_Event.new($game_map.map_id, event)
       token.icon_name = treasure.icon_index
       token.treasure = [di.kind,tr_id]
       token.treasure_time = 120 + XAS_BA::TREASURE_ERASE_TIME * 60
       token.jump(0,0)
       token.force_update = true
       token.move_speed = 6
       $game_map.add_token(token)
    end      
end

#===============================================================================
# ■ Game Event
#===============================================================================
class Game_Event < Game_Character
  include XAS_BA_ItemDrop
  
  #--------------------------------------------------------------------------
  # ● Update Treasure Duration
  #--------------------------------------------------------------------------               
  def update_treasure_duration
      return if $game_temp.battle_phase[0] and @treasure_time > 0
      return if @treasure_time == 0
      return if @temp_id != 0
      @treasure_time -= 1
      self.erase if @treasure_time == 0
  end
  
end

#===============================================================================
# ■ Game Character
#==============================================================================
class Game_Character < Game_CharacterBase
  attr_accessor :icon_name
  attr_accessor :treasure
end

#===============================================================================
# ■ Game Character
#==============================================================================
class Sprite_Character < Sprite_Base
  
  #--------------------------------------------------------------------------
  # ● Update
  #--------------------------------------------------------------------------             
  alias xrxs_charactericon_update update
  def update
      xrxs_charactericon_update
      if @character.icon_name != nil 
         self.bitmap = Cache.system("Iconset")
         self.src_rect.set(@character.icon_name  % 16 * 24, @character.icon_name / 16 * 24, 24, 24)
         self.ox = 12
         self.oy = 24
      end
  end
end

#===============================================================================
# ■ Game Player
#==============================================================================
class Game_Player < Game_Character
  
  #--------------------------------------------------------------------------
  # ● Check Event Trigger Here
  #--------------------------------------------------------------------------               
  alias treasure_check_event_trigger_here check_event_trigger_here
  def check_event_trigger_here(triggers)
      return false if $game_map.interpreter.running?
      check_treasure_here         
      treasure_check_event_trigger_here(triggers)
  end  
 
  #--------------------------------------------------------------------------
  # ● check_treasure_here   
  #--------------------------------------------------------------------------                 
  def check_treasure_here   
      for event in $game_map.events_xy(@x, @y)
          next if event.treasure == nil 
          gain_treasure(event)
      end  
  end     
  
  #--------------------------------------------------------------------------
  # ● Can Execute Field Item Effect
  #--------------------------------------------------------------------------                  
  def can_execute_field_item_effect?(item)
      if item.note =~ /<Drop HP Damage = (\S+)>/
         damage = $1.to_i
         damage2 = damage * self.battler.mhp / 100
         self.battler.damage = damage2
         self.battler.damage_pop = true
         self.battler.hp -= damage2
         return true
      end  
      if item.note =~ /<Drop MP Damage = (\S+)>/
         damage = $1.to_i
         damage2 = damage * self.battler.mmp / 100
         self.battler.mp -= damage2         
         self.battler.damage_type = "Mp"   
         self.battler.damage = damage2
         self.battler.damage_pop = true
         return true
      end       
      if item.note =~ /<Drop Gold = (\d+)>/
         gold = $1.to_i
         damage = $data_system.terms.gold + " " + gold.to_s
         self.battler.damage = damage
         self.battler.damage_pop = true
         $game_party.gain_gold(gold)
         return true
      end
      return false  
  end  
end 

#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ SPRITE - DAMAGE SPRITE
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#===============================================================================
# ■  XRXS_DAMAGE_OFFSET
#===============================================================================
module XRXS_DAMAGE_OFFSET
  
  #--------------------------------------------------------------------------
  # ● Update
  #--------------------------------------------------------------------------              
  def update
      super
      update_damage_offset 
  end
    
  #--------------------------------------------------------------------------
  # ● Update Damage offset
  #--------------------------------------------------------------------------                
  def update_damage_offset
      return if $game_temp.global_active_system[0]
      return if @damage_sprites == nil
      for damage_sprite in @damage_sprites
          damage_sprite.x = self.x
          damage_sprite.y = self.y
      end      
  end
    
end

#===============================================================================
# ■ Sprite_Character
#===============================================================================
class Sprite_Character < Sprite_Base
      include XRXS_DAMAGE_OFFSET
end
    
#==============================================================================
# ■ Sprite Base
#==============================================================================
class Sprite_Base < Sprite
  
  include XAS_DAMAGE_POP
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------   
  alias x_damage_pop_initialize initialize
  def initialize(viewport = nil)      
      @_damage_duration = 0
      x_damage_pop_initialize(viewport) 
  end
  
  #--------------------------------------------------------------------------
  # ● Damage
  #--------------------------------------------------------------------------     
  def damage(value, type = "")
      dispose_damage
      @damage_ox = 0
      @damage_type = type
      # NUMBER PICTURE
      if value.is_a?(Numeric) 
         bitmap_number_image = $game_temp.schala_cache_damage[0]
         bitmap_im_cw = $game_temp.schala_cache_damage[1]
         bitmap_im_ch = $game_temp.schala_cache_damage[2]     
         bitmap = Bitmap.new(bitmap_number_image.width,(bitmap_im_ch * 2) + 5)
         bitmap_number_text = value.to_s.split(//)
         center_x = (((2 + bitmap_number_text.size) * bitmap_im_cw) / 2)
         # Damage Color         
         if value >= 0
            if @damage_type == "Critical"
               h = bitmap_im_ch * 2  
               h2 = bitmap_im_ch * 4
               $game_map.screen.start_shake(5, 5, 60)
            elsif @damage_type == "Mp"   
               h = bitmap_im_ch * 0  
               h2 = bitmap_im_ch * 3
            else
               h = 0
            end
            f = 0
          else # Recover Color   
            h = bitmap_im_ch  
            h2 = bitmap_im_ch * 3 if @damage_type == "Mp"     
            f = 1
        end   
        for r in f..bitmap_number_text.size - 1
            bitmap_number_abs = bitmap_number_text[r].to_i
            bitmap_src_rect = Rect.new(bitmap_im_cw * bitmap_number_abs, h, bitmap_im_cw, bitmap_im_ch)
            bitmap.blt(center_x + (bitmap_im_cw  *  r), bitmap_im_ch + 5, bitmap_number_image, bitmap_src_rect)                  
        end 
        ex = (bitmap_im_cw / 2) * (bitmap_number_text.size + f)
        @damage_ox = (bitmap_number_image.width - (bitmap_number_image.width / 2) - ex) - center_x 
        @damage_ox -= 16 if value > 0
        # Add Extra String (MP / Critical)
        if h2 != nil
           string_x = (center_x - (bitmap_number_image.width / 2) + (bitmap_im_cw / 2) * bitmap_number_text.size)
           bitmap_src_rect = Rect.new(0, h2,  bitmap_number_image.width, bitmap_im_ch)
           bitmap.blt(string_x , 0, bitmap_number_image, bitmap_src_rect)   
        end        
      else 
          #TEXT STRING
          damage_string = value.to_s
          bitmap = Bitmap.new(160, 48)
          bitmap.font.name = DAMAGE_FONT_NAME
          bitmap.font.size = DAMAGE_FONT_SIZE
          bitmap.font.bold = DAMAGE_FONT_BOLD
          bitmap.font.italic = DAMAGE_FONT_ITALIC
          bitmap.font.color = Color.new(0,0,0)
          bitmap.draw_text(0, 12, 160, 36, damage_string, 1)
          case @damage_type
               when "Exp";   string_color = DAMAGE_EXP_FONT_COLOR
               when "Gold";  string_color = DAMAGE_GOLD_FONT_COLOR
               when "Item";  string_color = DAMAGE_ITEM_FONT_COLOR
          else
             string_color = DAMAGE_DEFAULT_FONT_COLOR
          end
          bitmap.font.color = string_color
          bitmap.draw_text(0, 12, 160, 36, damage_string, 1)              
      end 
       @_damage_sprite = ::Sprite.new(self.viewport)
       @_damage_sprite.bitmap = bitmap
       @_damage_sprite.ox =  bitmap.width / 2
       @_damage_sprite.oy = 20
       @_damage_sprite.x = self.x + 16
       @_damage_sprite.y = self.y - self.oy / 2
       @_damage_sprite.opacity = 0
       @_damage_sprite.z = 100
       @_damage_duration = 75
   end

  #--------------------------------------------------------------------------
  # ● Dispose Damage
  #--------------------------------------------------------------------------       
  def dispose_damage
      if @_damage_sprite != nil
         @_damage_sprite.bitmap.dispose
         @_damage_sprite.dispose
         @_damage_sprite = nil
         @_damage_duration = 0
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Dispose
  #--------------------------------------------------------------------------         
  alias x_damage_dispose dispose
  def dispose 
      dispose_damage
      x_damage_dispose
  end
  
  #--------------------------------------------------------------------------
  # ● Update
  #--------------------------------------------------------------------------           
  alias x_damage_pop_update update
  def update
      if @_damage_duration > 0
         @_damage_duration -= 1
         if @_damage_duration == 0
            dispose_damage
         end
       end      
       x_damage_pop_update
  end    
    
end  

#===============================================================================
# ■ XRXS DAMAGE
#===============================================================================
module XRXS_DAMAGE
  
  #--------------------------------------------------------------------------
  # ● Damage X Init Velocity
  #--------------------------------------------------------------------------                             
  def damage_x_init_velocity
      return 0.2 * (rand(5) - 2) 
  end
    
  #--------------------------------------------------------------------------
  # ● Damage Y Init Velocity
  #--------------------------------------------------------------------------                             
  def damage_y_init_velocity
      return 9
  end
    
  #--------------------------------------------------------------------------
  # ● Update
  #--------------------------------------------------------------------------                               
  def update
      super
      @damage_sprites   = [] if @damage_sprites.nil?
      @damage_durations = [] if @damage_durations.nil?
      if @_damage_sprite != nil and @_damage_sprite.visible
         if @damage_ox != nil
            dam_ox = @damage_ox
         else   
            dam_ox = 0
         end        
         if @damage_type != nil
            dam_type = @damage_type
         end  
         x = damage_x_init_velocity
         y = damage_y_init_velocity
         d = @_damage_duration
         @damage_sprites.push(Sprite_Damage.new(@_damage_sprite, x, y, d,dam_ox,dam_type))
         @_damage_sprite.visible = false
      end
      for damage_sprite in @damage_sprites
          damage_sprite.update
      end
      for i in 0...@damage_sprites.size
          @damage_sprites[i] = nil if @damage_sprites[i].disposed?
      end
      @damage_sprites.compact!
  end
 
  #--------------------------------------------------------------------------
  # ● Dispose
  #--------------------------------------------------------------------------                                
  def dispose
      super
      if @damage_sprites != nil
         for damage_sprite in @damage_sprites
             damage_sprite.dispose
         end
      end
  end
   
end

#===============================================================================
# ■ RPG Sprite
#===============================================================================
class Sprite_Base < Sprite
      include XRXS_DAMAGE
end

#===============================================================================
# ■ Sprite Damage
#===============================================================================
class Sprite_Damage < Sprite
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------                        
  def initialize(sprite, init_x_speed, init_y_speed, duration,dam_ox,dam_type = nil)
      super(nil)
      self.bitmap = sprite.bitmap.dup unless sprite.bitmap.nil?
      self.opacity = 255
      self.x = sprite.x
      self.y = sprite.y
      self.z = sprite.z
      self.ox = sprite.ox - dam_ox
      self.oy = sprite.oy
      @now_x_speed = init_x_speed
      @now_y_speed = init_y_speed
      @potential_x_energy = 0.0
      @potential_y_energy = 0.0
      @duration = duration
      @dam_type = dam_type
      @dam_type = "" if dam_type == nil
  end

  #--------------------------------------------------------------------------
  # ● Update    
  #--------------------------------------------------------------------------                       
  def update
    super
    if XAS_DAMAGE_POP::DAMAGE_CRITICAL_ZOOM
       if @dam_type != "Critical"
          update_normal_popup
       else  
          update_critical_effect   
       end      
    else      
       update_normal_popup
    end
    if @duration > 0
       @duration -= 1
       self.dispose if @duration == 0
    end
  end
  
  #--------------------------------------------------------------------------
  # ● Update    
  #--------------------------------------------------------------------------                       
  def update_antilag
      self.opacity -= 25
      @duration -= 1 if @duration > 1
  end  
  
  #--------------------------------------------------------------------------
  # ● update_critical_effect
  #--------------------------------------------------------------------------                           
  def update_critical_effect  
      case @duration
         when 55..75
           self.zoom_x += 0.1
           self.zoom_y += 0.1
         else   
           if self.zoom_x > 0.1   
              self.zoom_x -= 0.1
              self.zoom_y -= 0.1
           end
       end
  end
  
  #--------------------------------------------------------------------------
  # ● update_normal_popup
  #--------------------------------------------------------------------------                         
  def update_normal_popup
      self.opacity -= 25 if @duration <= 10
      n = self.oy + @now_y_speed
      if n <= 0
         @now_y_speed *= -1
         @now_y_speed /=  2
         @now_x_speed /=  2
      end
      self.oy  = [n, 0].max    
      @potential_y_energy += 0.58
      speed = @potential_y_energy.floor
      @now_y_speed        -= speed
      @potential_y_energy -= speed
      @potential_x_energy += @now_x_speed
      speed = @potential_x_energy.floor
      self.ox             += speed
      @potential_x_energy -= speed  
    end
 
end
  
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
#■ SPRITE - SPRITE EFFECTS
#■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


#===============================================================================
# ■ Sprite_Character
#===============================================================================
class Sprite_Character < Sprite_Base
  include XAS_SYSTEM
  
  #--------------------------------------------------------------------------
  # ● Update X Effects
  #--------------------------------------------------------------------------              
  def update_sprites_effects
      force_through if @character.defeated[0] and @character.collapse_duration == 0
      execute_damage_pop  if can_damage_pop_base?
      update_visible
      update_opacity
      return if !self.visible or self.opacity == 0
      update_sprite_position
      update_angle
      update_zoom
      update_blend
  end
 
  #--------------------------------------------------------------------------
  # ● Can Update Sprite Effects
  #--------------------------------------------------------------------------                    
  def can_update_sprite_effects?
      return false if @character.erased
      return true if @character.tool_id > 0
      return false if @character.battler == nil      
      return true
  end    
  
  #--------------------------------------------------------------------------
  # ● Force Through
  #--------------------------------------------------------------------------                
  def force_through
      self.visible = false
      self.opacity = 0 
      self.character.through = true  
      @character.erase
  end
      
  #--------------------------------------------------------------------------
  # ● Update Opacity
  #--------------------------------------------------------------------------      
  def update_opacity
      return if @character.tool_id != 0
      update_initial_opacity
      if @character.collapse_duration > 0
         update_collaspse_effects
         return
      end  
      return if @character.can_collapse      
      @character.erase if @character.disabled and self.opacity <= 0
  end
  
  #--------------------------------------------------------------------------
  # ● Update Initial Opacity
  #--------------------------------------------------------------------------        
  def update_initial_opacity
      return if !$game_temp.check_death_opacity
      return if @character.battler == nil
      return if !@character.battler.is_a?(Game_Actor)
      self.opacity = @character.battler.opacity
      $game_temp.check_death_opacity = false
  end
  
  #--------------------------------------------------------------------------
  # ● Update Fade
  #--------------------------------------------------------------------------        
  def update_fade
      return false if @character.collapse_duration > 0      
      if can_sprite_fade?
         self.opacity -= 10
      else
         self.opacity += 5
      end
  end
 
  #--------------------------------------------------------------------------
  # ● Update Schala Fade
  #--------------------------------------------------------------------------            
  def can_sprite_fade?
      return false if @character.erased
      return true if @character.fade
      return false if @character.tool_id > 0
      return true if @character.disabled
      if @character.battler != nil and !$game_temp.battle_phase[0]
         if @character.knock_back_duration != nil or @character.battler.dead?
            self.opacity = 160
            return true
         end
         return true if @character.battler.dead?
      end   
      return true if !@character.target and @character.battler != nil and $game_temp.battle_phase[0]
      return false
  end  
      
  #--------------------------------------------------------------------------
  # ● Update Blend
  #--------------------------------------------------------------------------                     
  def update_blend
     self.blend_type = @character.blend_type
     self.bush_depth = @character.bush_depth
   end  
   
  
  #--------------------------------------------------------------------------
  # ● Update Visible
  #--------------------------------------------------------------------------                
  def update_visible
      return if @character.is_a?(Game_Event)
      self.visible = @character.transparent ? false : true
  end
 
  #--------------------------------------------------------------------------
  # ● Update Other
  #--------------------------------------------------------------------------
  alias schala_update_other update_other
  def update_other
      return if $game_temp.battle_phase[0] 
      return if @character.battler != nil
      schala_update_other
  end  
  
  #--------------------------------------------------------------------------
  # ● Update Angle
  #--------------------------------------------------------------------------          
  def update_angle
      return if @character.angle == self.angle
      self.angle = @character.angle
  end
  
  #--------------------------------------------------------------------------
  # ● Update Zoom 
  #--------------------------------------------------------------------------            
  def update_zoom
      update_breath_effect if can_breath_effect?
      self.zoom_x = @character.zoom_x
      self.zoom_y = @character.zoom_y
  end
  
  #--------------------------------------------------------------------------
  # ● Can Breath Effect?
  #--------------------------------------------------------------------------                    
  def can_breath_effect?
      return false if @character.tool_id != 0
      return false if !@character.battler.breath_effect
      return false if @character.battler.dead?
      return false if @character.stop and not @character.battler.state_sleep
      return true
  end  
  
  #--------------------------------------------------------------------------
  # ● Update Breath Effect
  #--------------------------------------------------------------------------                  
  def update_breath_effect 
      if @character.battler.fast_breath_effect
          power = 1.05
          z_y = 0.005       
      else
          power = 1.05
          z_y = 0.001
      end
      execute_breath_effect(@character.zoom_y, power , z_y)
  end    
      
  #--------------------------------------------------------------------------
  # ● Execute Breath Effect
  #--------------------------------------------------------------------------                    
  def execute_breath_effect(target_zoom, power , speed)
      if @character.battler.breath_duration == 0
         if target_zoom < power
            target_zoom += speed
            if target_zoom >= power
               @character.battler.breath_duration = 1
            end   
          end          
      else
        if target_zoom > 1.00
           target_zoom -= speed
           if target_zoom <= 1.00
              target_zoom = 1.00
              @character.battler.breath_duration = 0
            end   
        end          
      end        
      @character.zoom_y = target_zoom
  end  
  
  #--------------------------------------------------------------------------
  # ● Update Sprite Position
  #--------------------------------------------------------------------------                
  def update_sprite_position
      if @py != nil
         self.y += @py
      end
      if @character.round_knockback[0]  
         update_round_knockback 
      else
         update_angle_position   
      end  
      update_knockback_shake_effect if @character.knockbacking?
      update_float_effect
  end  
 
  #--------------------------------------------------------------------------
  # ● Update Float Effect
  #--------------------------------------------------------------------------
  def update_float_effect
      return if @character.tool_id != 0
      return if !@character.battler.float_effect[0]     
      if $game_temp.target_phase == nil or
         ($game_temp.target_phase != nil and
          $game_temp.target_phase.action_movement[4] != @character)
      @character.battler.float_effect[3] += 1
      if @character.battler.float_effect[3] > 2
          @character.battler.float_effect[3] = 0
          if @character.battler.float_effect[2] == 0
             @character.battler.float_effect[1] -= 1
             if @character.battler.float_effect[1] <= -10
                @character.battler.float_effect[1] = -10
                @character.battler.float_effect[2] = 1
             end  
          else  
             @character.battler.float_effect[1] += 1
             if @character.battler.float_effect[1] >= 0
                @character.battler.float_effect[1] = 0
                @character.battler.float_effect[2] = 0
             end        
          end  
      end
      end
      self.y += @character.battler.float_effect[1]
  end
  
 #--------------------------------------------------------------------------
 # ● Check Chacracter Above Player
 #--------------------------------------------------------------------------                  
 def check_character_above_player(target)
     return if @character.is_a?(Game_Player)
     return if @character.battler == nil
     if (@character.x == $game_player.x and
         @character.y == $game_player.y) or
         not @character.passable_temp_id?(@character.x,@character.y)
         @character.temp_id = 0
         @character.move_speed = @character.pre_move_speed 
         if target != nil and target.hookshot and
            target.force_action == "Toward Player" 
            case @character.direction
               when 2;  @character.y += 1
               when 4;  @character.x -= 1
               when 6;  @character.x += 1
               when 8;  @character.y -= 1  
            end
         else
            case @character.direction
               when 2;  @character.y -= 1
               when 4;  @character.x += 1
               when 6;  @character.x -= 1
               when 8;  @character.y += 1  
            end            
         
         end  
     end   
  end    
  
  #--------------------------------------------------------------------------
  # ● Update Round Knockback
  #--------------------------------------------------------------------------                  
  def update_round_knockback 
      @character.round_knockback[1] += 1 
      if @character.round_knockback[1] > 5
         @character.round_knockback[1] = 0
         @character.angle += 90
         @character.angle = 0 if @character.angle >= 360
      end
      case @character.angle
           when 90
             self.x += @cw / 2
             self.y -= @ch / 2
           when 180
             self.y -= @ch
           when 270
             self.x -= @cw / 2
             self.y -= @ch / 2
      end
  end
 
  #--------------------------------------------------------------------------
  # ● Update Angle Position
  #--------------------------------------------------------------------------                  
  def update_angle_position
      return if @character.angle == 0
      return if @cw == nil  
      if @character.tool_id > 0 and @character.angle == 315
         self.x -= (@cw / 3)
         self.y -= (@ch / 6)        
         return 
      end
      self.y -= (@ch / 2) if @character.angle == 180    
  end
  
end

#===============================================================================
# ■ Sprite_Character
#===============================================================================
class Sprite_Character < Sprite_Base  

  #--------------------------------------------------------------------------
  # ● Update Treasure_effect
  #--------------------------------------------------------------------------                      
  def update_treasure_effect
      return if @character.treasure == nil
      #update_treasure_fade_effect
      update_hold_target
      update_treasure_float_effect
  end  
  
  #--------------------------------------------------------------------------
  # ● update_treasure_fade_effect
  #--------------------------------------------------------------------------                        
  def update_treasure_fade_effect
      return if @character.treasure_time > 100
      return if @character.zoom_x < 0.01      
      @character.zoom_x -= 0.01
  end  
  
  #--------------------------------------------------------------------------
  # ● Update Treasure Float Effect
  #--------------------------------------------------------------------------                          
  def update_treasure_float_effect
      return if @character.temp_id != 0
      return if self.character.jumping?
      self.character.treasure_float[2] += 1
      if self.character.treasure_float[2] > 1
         self.character.treasure_float[2] = 0
         self.character.treasure_float[1] += 1
         case self.character.treasure_float[1]
            when 1..15 
              self.character.treasure_float[0] -= 1
            when 16..30
              self.character.treasure_float[0] += 1
            else
              self.character.treasure_float[0] = 0
              self.character.treasure_float[1] = 0 
          end 
      end   
      self.y +=  self.character.treasure_float[0]
  end
    
 #--------------------------------------------------------------------------
 # ● Update X Effects
 #--------------------------------------------------------------------------                 
 def update_hold_target
     return if @character.temp_id == 0
#     self.z = @character.screen_x 
     target = $game_map.events[@character.temp_id]
     if target == nil or target.erased
        @character.temp_id = 0
        @character.move_speed = @character.pre_move_speed
        @character.gain_treasure(@character) if @character.treasure != nil
      else
        case $game_player.direction
           when 2
        dx = 0
        dy = 16          
           when 4
        dx = -16
        dy = 0             
           when 6
        dx = 16
        dy = 0             
           when 8
        dx = 0
        dy = -24            
        end
        self.zoom_x = 1.2
        self.zoom_y = 1.2
        self.z = self.character.screen_z 
        self.x = target.screen_x + dx
        self.y = target.screen_y + dy
        self.character.x = target.x
        self.character.y = target.y
        self.character.move_speed = target.move_speed
        self.character.direction = target.direction unless self.character.direction_fix
        #check_character_above_player(target)
     end   
  end      
  
end

#==============================================================================
# ■ Sprite Base 
#==============================================================================
class Sprite_Base < Sprite  

  #--------------------------------------------------------------------------
  # ● Dispose Animation
  #--------------------------------------------------------------------------
  def dispose_animation
      $game_temp.animation_garbage = [] if $game_temp.animation_garbage == nil
      if @ani_bitmap1
         @@_reference_count[@ani_bitmap1] -= 1
        if @@_reference_count[@ani_bitmap1] == 0
            $game_temp.animation_garbage.push(@ani_bitmap1)
         end
      end
      if @ani_bitmap2
         @@_reference_count[@ani_bitmap2] -= 1
         if @@_reference_count[@ani_bitmap2] == 0
            $game_temp.animation_garbage.push(@ani_bitmap2)
        end
     end
     if @ani_sprites
        @ani_sprites.each {|sprite| sprite.dispose }
        @ani_sprites = nil
        @animation = nil
     end
     @ani_bitmap1 = nil
     @ani_bitmap2 = nil
  end    
  
end

#==============================================================================
# ■ Scene_Base
#==============================================================================
class Game_Map
    
  #--------------------------------------------------------------------------
  # ● Setup
  #--------------------------------------------------------------------------    
  alias animation_garbage_setup setup
  def setup(map_id)
      animation_garbage_setup(map_id)
      dispose_animation_garbage
  end
  
  #--------------------------------------------------------------------------
  # ● Dispose Animation Garbage
  #--------------------------------------------------------------------------  
  def dispose_animation_garbage
      return if $game_temp.animation_garbage == nil
      for animation in $game_temp.animation_garbage
          animation.dispose 
      end  
      $game_temp.animation_garbage = nil
  end  
  
end  

#==============================================================================
# ■ Scene_Base
#==============================================================================
class Scene_Base
  
  #--------------------------------------------------------------------------
  # ● Scene Changing?
  #--------------------------------------------------------------------------    
  alias animation_garbage_scene_changing scene_changing? 
  def scene_changing?
      $game_map.dispose_animation_garbage if SceneManager.scene != self
      animation_garbage_scene_changing
  end

end  
 

#===============================================================================
# ■ Sprite_Character
#===============================================================================
class Sprite_Character < Sprite_Base
  
  #--------------------------------------------------------------------------
  # ● Setup New Effect
  #--------------------------------------------------------------------------              
  def setup_new_effect
      if @character.animation_id > 0
         animation = $data_animations[@character.animation_id]
         start_animation(animation)
         @character.animation_id = 0
      end
      if !@balloon_sprite && @character.balloon_id > 0
         @balloon_id = @character.balloon_id
         start_balloon
      end
  end  
  
  #--------------------------------------------------------------------------
  # ● Can Damage Pop Base
  #--------------------------------------------------------------------------                  
  def can_damage_pop_base?
      return false if @character.tool_id != 0
      return false if !@character.battler.damage_pop
      return true  
  end  
    
  #--------------------------------------------------------------------------
  # ● Execute Damage Pop
  #--------------------------------------------------------------------------              
  def execute_damage_pop  
      damage(@character.battler.damage, @character.battler.damage_type)
      @character.battler.damage = nil
      @character.battler.critical = false
      @character.battler.damage_pop = false
      @character.battler.damage_type = ""
  end    
  
 #--------------------------------------------------------------------------
 # ● Update_balloon
 #--------------------------------------------------------------------------
 if XAS_BA::FIX_BALLOON_POSITION
 def update_balloon
     if @balloon_duration > 0
        @balloon_duration -= 1
        if @balloon_duration > 0
           @balloon_sprite.x = x
           @balloon_sprite.y = y - XAS_BA::BALLOON_HEIGHT
           @balloon_sprite.z = z + 200
           sx = balloon_frame_index * 32
           sy = (@balloon_id - 1) * 32
           @balloon_sprite.src_rect.set(sx, sy, 32, 32)
      else
           end_balloon
      end
    end
  end   
  end

  #--------------------------------------------------------------------------
  # ● Check Character Name nil
  #--------------------------------------------------------------------------                   
  def check_character_name_nil
      if @character_name == nil or @character.character_name == nil
         @character.character_name = ""
         @character_name = @character.character_name
      end  
  end
    
  #--------------------------------------------------------------------------
  # ● Set Character Bitmap
  #--------------------------------------------------------------------------                 
  alias mog_one_pattern_set_character_bitmap set_character_bitmap
  def set_character_bitmap
      check_character_name_nil
      @py = nil
      if @character_name[/\((\d+)\)/]
         @py = $1.to_i
      end            
      if @character_name =~ /@/
         self.bitmap = Cache.character(@character_name)
         @cw = bitmap.width
         @ch = bitmap.height
         self.ox = @cw / 2 
         self.oy = @ch   
         @one_pattern = true
         set_sprite_size(@ch,@cw) if @cw != nil and @cw != nil
         return
      end        
      mog_one_pattern_set_character_bitmap
      set_sprite_size(@ch,@cw) if @cw != nil and @cw != nil
  end
  
  #--------------------------------------------------------------------------
  # ● Update Src Rect
  #--------------------------------------------------------------------------                 
  alias mog_one_pattern_update_src_rect update_src_rect 
  def update_src_rect    
      return if @one_pattern != nil
      mog_one_pattern_update_src_rect
  end    
  
  #--------------------------------------------------------------------------
  # ● Set Sprite Size
  #--------------------------------------------------------------------------                   
  def set_sprite_size(ch,cw)    
      cw1 = (cw / 32).truncate
      ch1 = (ch / 32).truncate
      cw2 = (cw / 64).truncate
      ch2 = (ch / 64).truncate    
      cw3 = (cw / 2).truncate
      ch3 = (ch / 2).truncate
      @character.sprite_size = [cw,ch,cw1,ch1,cw2,ch2,cw3,ch3]
  end   
  
 #--------------------------------------------------------------------------
 # ● Move Animation
 #--------------------------------------------------------------------------  
  alias schala_sp1_move_animation move_animation rescue nil
  def move_animation(dx, dy)
      return if $game_temp.battle_phase[0]
      schala_sp1_move_animation(dx, dy) rescue nil
  end    
  
end

#==============================================================================
# ■ Game_Event
#==============================================================================
class Game_Event < Game_Character

  #--------------------------------------------------------------------------
  # ● Near The Screen
  #--------------------------------------------------------------------------  
  alias x_near_the_screen near_the_screen?
  def near_the_screen?(dx = 12, dy = 8)
      return true if can_update_out_screen?
      x_near_the_screen(dx, dy)
  end
  
 #--------------------------------------------------------------------------
 # ● Can Update Out Screen
 #-------------------------------------------------------------------------- 
 def can_update_out_screen?
     return true if self.force_update
     return false
 end
   
end

#==============================================================================
# ■ Spriteset Map
#==============================================================================
class Spriteset_Map
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------  
  alias mog_schala_initialize initialize
  def initialize
      create_schala_sprites
      mog_schala_initialize
  end
  
  #--------------------------------------------------------------------------
  # ● Dispose
  #--------------------------------------------------------------------------  
  alias mog_schala_dispose dispose
  def dispose
      dispose_schala_sprites
      mog_schala_dispose
  end
  
  #--------------------------------------------------------------------------
  # ● update   
  #--------------------------------------------------------------------------  
  alias mog_schala_update update 
  def update      
      mog_schala_update
      update_schala_sprites
      reset_global_parameters
  end  
  
  #--------------------------------------------------------------------------
  # ● update Schala Sprites
  #--------------------------------------------------------------------------    
  def create_schala_sprites
      return if @schala_sprites != nil
      @schala_sprites = Schala_Base_Sprites.new
  end
  
  #--------------------------------------------------------------------------
  # ● Dispose Schala Sprites
  #--------------------------------------------------------------------------    
  def dispose_schala_sprites
      return if @schala_sprites == nil
      @schala_sprites.dispose
      @schala_sprites = nil
  end
  
  #--------------------------------------------------------------------------
  # ● update Schala Sprites
  #--------------------------------------------------------------------------    
  def update_schala_sprites
      return if @schala_sprites == nil
      @schala_sprites.update
  end
  
end

#===============================================================================
# ■ Schala Base Sprites
#===============================================================================
class Schala_Base_Sprites
  include SCHALA_BASE_SPRITES
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------      
  def initialize      
      create_cursor
      create_cursor2
      create_command
      create_help_window
      create_skill_window
      create_item_window
      create_escape_meter
      create_turn
      create_info_layout
      create_hookshot
  end
  
  #--------------------------------------------------------------------------
  # ● Dispose
  #--------------------------------------------------------------------------      
  def dispose
      dispose_cursor
      dispose_cursor2
      dispose_command
      dispose_help_window
      dispose_skill_window
      dispose_item_window
      dispose_escape_meter
      dispose_turn
      dispose_info_layout
      dispose_result
      dispose_hookshot
  end
  
  #--------------------------------------------------------------------------
  # ● Update
  #--------------------------------------------------------------------------      
  def update
      update_battle_start if $game_temp.sprite_battle_start
      update_battle_end if $game_temp.sprite_battle_end
      update_result_sprites
      update_force_refresh if $game_temp.refresh_hud   
      update_hookshot
      return if on_field?   
      @actor = $game_temp.target_actors[$game_temp.in_turn] rescue nil
      update_cursor
      update_cursor2
      update_command
      update_help_window
      update_skill_window
      update_item_window      
      update_escape_meter
      update_turn     
      update_info_layout
  end
  
  #--------------------------------------------------------------------------
  # ● Update Battle Start
  #--------------------------------------------------------------------------        
  def update_battle_start
      $game_temp.sprite_battle_start = false
  end
 
  #--------------------------------------------------------------------------
  # ● Update Battle End
  #--------------------------------------------------------------------------          
  def update_battle_end  
      $game_temp.sprite_battle_end = false
  end
    
  #--------------------------------------------------------------------------
  # ● Update Force Refresh
  #--------------------------------------------------------------------------          
  def update_force_refresh
      $game_temp.refresh_hud = false
  end
  
  #--------------------------------------------------------------------------
  # ● On Field
  #--------------------------------------------------------------------------        
  def on_field?  
      return false if $game_temp.battle_phase[0]
      update_visible_out
      return true
  end     
       
end

#==============================================================================
# ■ Scene_Map
#==============================================================================
#===============================================================================
# ■ Scene_Map
#===============================================================================
class Scene_Map < Scene_Base

 #--------------------------------------------------------------------------
 # ● Update
 #--------------------------------------------------------------------------  
 alias schala_pre_cache_start start
 def start
     $game_temp.execute_pre_cache
     schala_pre_cache_start
 end
 
end

#===============================================================================
# ■ Game_Temp
#===============================================================================
class Game_Temp
  
  attr_accessor :schala_cache
  attr_accessor :schala_cache_damage
  
  #--------------------------------------------------------------------------
  # ● Execute Pre Cache
  #--------------------------------------------------------------------------    
  def execute_pre_cache
      return if @schala_cache != nil
      @schala_cache = []
      @schala_cache.push(Cache.system("Iconset"))
      @schala_cache.push(Cache.schala("Result_Layout"))
      @schala_cache.push(Cache.schala("Result_Level"))
      @schala_cache.push(Cache.schala("Turn"))
      @schala_cache.push(Cache.schala("Info_Layout"))
      @schala_cache.push(Cache.schala("Escape_Layout"))
      @schala_cache.push(Cache.schala("Escape_Meter"))
      @schala_cache.push(Cache.schala("Cursor"))
      @schala_cache.push(Cache.schala("Target_HP1"))
      @schala_cache.push(Cache.schala("Target_HP2"))
      @schala_cache.push(Cache.schala("Cursor_2"))
      @schala_cache.push(Cache.schala("Command"))
      @schala_cache.push(Cache.schala("Command_list"))
      @schala_cache.push(Cache.schala("Hookshot"))
      pre_cache_damage_sprites
  end
  
  #--------------------------------------------------------------------------
  # ● Pre Cache Damage Sprites
  #--------------------------------------------------------------------------      
  def pre_cache_damage_sprites
      @schala_cache_damage = []
      @schala_cache_damage[0] = Cache.schala("Damage_Number")
      @schala_cache_damage[1] = @schala_cache_damage[0].width / 10
      @schala_cache_damage[2] = @schala_cache_damage[0].height / 5      
  end
  
end

#===============================================================================
# ■ Schala Base Sprites
#===============================================================================
class Schala_Base_Sprites
  
  #--------------------------------------------------------------------------
  # ● Update Visible Out
  #--------------------------------------------------------------------------        
  def update_visible_out
      vis = false
      @turn_sprite.visible = vis
      @info_layout.visible = vis
      @escape_layout.visible = vis
      @escape_meter.visible = vis
      @cursor.visible = vis
      @sprite_name.visible = vis
      @target_hp1.visible = vis
      @target_hp2.visible = vis
      @cursor2.visible = vis
      @command_layout.visible = vis
      @command_list.visible = vis
  end
    
end

#===============================================================================
# ■ Schala Base Sprites
#===============================================================================
class Schala_Base_Sprites 

  #--------------------------------------------------------------------------
  # ● Dispose Result Sprite
  #--------------------------------------------------------------------------        
  def dispose_result
      return if @result_sprite == nil
      $game_temp.result_window = [false,false]
      @result_sprite.dispose
      @result_sprite = nil
  end    
  
  #--------------------------------------------------------------------------
  # ● Update Result Sprites
  #--------------------------------------------------------------------------        
  def update_result_sprites
      return if $game_temp.turn_sprite_phase != 1
      create_result_sprite if can_create_result?
      dispose_result if can_dispose_result?
      update_result
  end
  
  #--------------------------------------------------------------------------
  # ● Create Result Sprite
  #--------------------------------------------------------------------------            
  def create_result_sprite
      $game_temp.result_window = [false,false]
      @result_sprite = Sprite_Result.new
  end  
  
  #--------------------------------------------------------------------------
  # ● Update Result
  #--------------------------------------------------------------------------          
  def update_result
      return if @result_sprite == nil
      @result_sprite.update
  end
  
  #--------------------------------------------------------------------------
  # ● Can Dispose Result?
  #--------------------------------------------------------------------------          
  def can_dispose_result?
      return false if @result_sprite == nil
      return false if !$game_temp.result_window[1]
      return true
  end  
  
  #--------------------------------------------------------------------------
  # ● Can Create Result?
  #--------------------------------------------------------------------------          
  def can_create_result?
      return false if @result_sprite != nil
      return false if !$game_temp.result_window[0]
      return true
  end  
  
end

#===============================================================================
# ■ Sprite Result
#===============================================================================
class Sprite_Result
  
  include MOG_SCHALA_RESULT  
  
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------        
  def initialize
      return if @layout != nil      
      @layout = Sprite.new
      @layout.bitmap = $game_temp.schala_cache[1]
      @layout.x = RESULT_POSITION[0]
      @layout.y = RESULT_POSITION[1]
      @layout.opacity = 1   
      @layout.z = 150
      @number_exp = Sprite.new
      @number_exp.bitmap = Bitmap.new(500,32)
      @number_exp.x = @layout.x + RESULT_EXP_POSITION[0]
      @number_exp.y = @layout.y + RESULT_EXP_POSITION[1]
      @number_exp.bitmap.font.name = RESULT_FONT_NAME
      @number_exp.bitmap.font.size = RESULT_FONT_SIZE
      @number_exp.bitmap.font.bold = RESULT_FONT_BOLD
      @number_exp.opacity = 1
      @number_exp.z = 150
      @initial_time = 20
      @level_layout = Sprite.new 
      @level_layout.bitmap = $game_temp.schala_cache[2]
      @level_layout.z = 150
      @level_layout.x = RESULT_INFO_POSITION[0]
      @level_layout.y = RESULT_INFO_POSITION[1]
      @level_layout.opacity = 1
      @level_layout.visible = false
      @level_text = Sprite.new
      @level_text.bitmap = Bitmap.new(500,32)
      @level_text.bitmap.font.name = RESULT_FONT_NAME
      @level_text.bitmap.font.size = RESULT_FONT_SIZE
      @level_text.bitmap.font.bold = RESULT_FONT_BOLD 
      @level_text.z = 151
      @level_text.opacity = 1
      @level_text.x = RESULT_TEXT_POSITION[0] + RESULT_INFO_POSITION[0]
      @level_text.y = RESULT_TEXT_POSITION[1] + RESULT_INFO_POSITION[1]
      @level_text.visible = false
  end
  
  #--------------------------------------------------------------------------
  # ● Refresh Number EXP
  #--------------------------------------------------------------------------           
  def refresh_number_exp
      @number_exp.bitmap.clear  
      @number_exp.opacity = 1
      $game_temp.exp_phase[0] = false
      text = ""
      if $game_temp.exp_phase[1] == 0
         text = "Got " + $game_temp.result_exp_gold_ap[0].to_s + " " + "Exp Point(s)"
      elsif $game_temp.exp_phase[1] == 1
         text = "Got " + $game_temp.result_exp_gold_ap[1].to_s + " " + $data_system.currency_unit.to_s
      elsif $game_temp.exp_phase[1] == 2
         text = "Got " + $game_temp.result_exp_gold_ap[2].to_s + " " + "AP Point(s)"
      end   
      @number_exp.bitmap.draw_text(0,0,500,32,text.to_s,1)    
  end
      
  #--------------------------------------------------------------------------
  # ● Refresh Level Text
  #--------------------------------------------------------------------------         
  def refresh_level_text
      @level_text.bitmap.clear
      @level_text.visible = true
      @level_layout.visible = true
      @level_layout.opacity = 0
      @level_text.opacity = 0
      $game_temp.actor_level_show[0] = false
      actor = $game_temp.target_actors[$game_temp.actor_level_index - 1].battler
      if $game_temp.actor_level_show[1]
         skill = $game_temp.actor_learned_skills[$game_temp.actor_learned_skills_index]
         text = sprintf(Vocab::ObtainSkill, skill.name)
         @level_text.bitmap.font.color = LEARNED_FONT_COLOR
         Audio.se_play("Audio/SE/" + XAS_SOUND::LEARNED_SE,100,100) rescue nil
         $game_temp.actor_learned_skills_index += 1
         $game_temp.result_stage = "Exp" if $game_temp.actor_learned_skills_index >= $game_temp.actor_learned_skills.size
     else   
         $game_temp.result_stage = "Learned_Skills" if $game_temp.actor_learned_skills.size > 0          
         @level_text.bitmap.font.color = NORMAL_FONT_COLOR
         text = sprintf(Vocab::LevelUp, actor.name.to_s, Vocab::level, actor.level.to_s)      
      end
      @level_text.bitmap.draw_text(0,0,500,32,text.to_s,1)        
  end
    
  #--------------------------------------------------------------------------
  # ● Dispose
  #--------------------------------------------------------------------------       
  def dispose
      return if @layout == nil
      @layout.dispose
      @layout = nil
      @number_exp.bitmap.dispose
      @number_exp.dispose
      @level_layout.dispose
      @level_text.bitmap.dispose
      @level_text.dispose
  end
  
  #--------------------------------------------------------------------------
  # ● Update
  #--------------------------------------------------------------------------      
  def update
      return if @layout == nil
      refresh_level_text if $game_temp.actor_level_show[0]
      refresh_number_exp if $game_temp.exp_phase[0]
      if $game_temp.battle_phase[2] > 0
         @layout.opacity += 5
         @number_exp.opacity += 5
      else   
         @layout.opacity -= 20
         @number_exp.opacity -= 20         
      end   
      if $game_temp.battle_phase[2] > 0 and $game_temp.exp_phase[1] == 0
         @layout.opacity += 5
         @number_exp.opacity += 5
         if @level_layout.visible
            @level_layout.opacity += 5
            @level_text.opacity += 5
         end
      else 
         return if @layout.opacity == 1
         @level_layout.opacity -= 20
         @level_text.opacity -= 20
         if @level_layout == 0 
            @level_layout.visible = false
            @level_text.visible = false
         end  
      end       
  end
  
end

#===============================================================================
# ■ Schala Base Sprites
#===============================================================================
class Schala_Base_Sprites
  
  #--------------------------------------------------------------------------
  # ● Create Turn
  #--------------------------------------------------------------------------                          
  def create_turn
      @turn_image = $game_temp.schala_cache[3]
      @turn_cw = @turn_image.width
      @turn_ch = @turn_image.height / 4
      @turn_sprite = Sprite.new
      @turn_sprite.bitmap = Bitmap.new(@turn_cw, @turn_ch)
      @turn_sprite.z = SPRITES_Z + 1
      @turn_sprite_org = [TURN_SPRITE_POSITION[0], TURN_SPRITE_POSITION[1]]
      @turn_sprite.x = @turn_sprite_org[0]
      @turn_sprite.y = @turn_sprite_org[1]
      @turn_phase = [0,0,0]
      @turn_sprite.visible = false
      @turn_phase[0] = $game_temp.turn_sprite_phase
  end
  
  #--------------------------------------------------------------------------
  # ● Refresh Turn
  #--------------------------------------------------------------------------                            
  def refresh_turn
      @turn_phase[0] = $game_temp.turn_sprite_phase
      @turn_sprite.bitmap.clear
      turn_src = Rect.new(0,@turn_phase[0] * @turn_ch,@turn_cw,@turn_ch )
      @turn_sprite.bitmap.blt(0,0,@turn_image,turn_src )
      @turn_sprite.x = @turn_sprite_org[0] + 100
      @turn_sprite.opacity = 0
      @turn_sprite.visible = true
  end
  
  #--------------------------------------------------------------------------
  # ● Dispose Turn
  #--------------------------------------------------------------------------                          
  def dispose_turn
      return if @turn_sprite == nil
      @turn_sprite.bitmap.dispose
      @turn_sprite.dispose
      @turn_sprite = nil
  end
  
  #--------------------------------------------------------------------------
  # ● Update Turn
  #--------------------------------------------------------------------------                          
  def update_turn
      return if @turn_sprite == nil
      update_turn_slide
      refresh_turn if @turn_phase[0] != $game_temp.turn_sprite_phase
  end
 
  #--------------------------------------------------------------------------
  # ● Update Turn Slide
  #--------------------------------------------------------------------------
  def update_turn_slide
      return if !@turn_sprite.visible
      if @turn_sprite.x >= @turn_sprite_org[0]
         @turn_sprite.opacity += 9
      else
         @turn_sprite.opacity -= 8
         @turn_sprite.visible = false if @turn_sprite.opacity == 0 
      end
      if $game_temp.turn_sprite_phase == 2 
         @turn_sprite.x -= 1
      else   
         @turn_sprite.x -= 2
      end  
  end
  
end

#==============================================================================
# ■ Window_Base
#==============================================================================
class Window_Base < Window
  
  #--------------------------------------------------------------------------
  # ● Draw Item Name Schala
  #--------------------------------------------------------------------------
  def draw_item_name_schala(item, x, y, enabled = true, type = 0)
      return unless item
      draw_icon(item.icon_index, x, y, enabled)
      if type == 0
         change_color(normal_color, enabled)
      else
         change_color(tp_gauge_color2, enabled)  
      end
      draw_text(x + 24, y, 160, line_height, item.name)
  end
  
end

#==============================================================================
# ■ Schala Window Base
#==============================================================================
module Schala_Window_Base
 include Schala_Battle
 
  #--------------------------------------------------------------------------
  # ● Enable?
  #--------------------------------------------------------------------------
  def enable_skill?(item)
      @actor && @actor.battler.usable?(item) && cooperation_skill_met?(item)
  end    
   
 #--------------------------------------------------------------------------
 # ● Execute Cancel Selection
 #--------------------------------------------------------------------------            
 def execute_cancel_selection
     $game_temp.command_wait = 5
     $game_temp.command_phase = 0
     $game_temp.help_text = [true, ""]
     Sound.play_cancel
     @actor = nil  
     @old_index = -1
 end
   
 #--------------------------------------------------------------------------
 # ● All Dead Scope
 #--------------------------------------------------------------------------             
 def all_dead_scope?(skill)
     return true if skill.scope != 10
     for actor in $game_temp.target_actors
         return true if actor.battler.dead?
     end    
     return false
 end
 
 #--------------------------------------------------------------------------
 # ● Can execute Selection
 #--------------------------------------------------------------------------             
 def can_execute_selection?(skill)
     return false if skill == nil
     return false if !enable_skill?(skill)
     return false if !all_dead_scope?(skill)
     return true
 end      
 
 #--------------------------------------------------------------------------
 # ● Select Target Type
 #--------------------------------------------------------------------------           
 def select_target_type(skill) 
     if skill.scope >= 7
        $game_temp.command_phase = 2 
        @actor.execute_actor_selection
     else  
        @actor.execute_enemy_selection
     end      
 end 
 
end

#===============================================================================
# ■ Schala Base Sprites
#===============================================================================
class Schala_Base_Sprites

  #--------------------------------------------------------------------------
  # ● Create Help Window
  #--------------------------------------------------------------------------                    
  def create_help_window
      @help_window = Window_Help.new
      @help_window.z = SPRITES_Z
      @help_window.opacity = 0
      @help_window.visible = false
  end 
     
  #--------------------------------------------------------------------------
  # ● Dispose Help Window
  #--------------------------------------------------------------------------                      
  def dispose_help_window
      return if @help_window == nil
      @help_window.dispose
  end
  
  #--------------------------------------------------------------------------
  # ● Update Help Window
  #--------------------------------------------------------------------------                      
  def update_help_window
      return if @help_window == nil
      @help_window.update
      if @skill_window.visible or @item_window.visible
         @help_window.visible = true
      else   
         @help_window.visible = false
      end
      if $game_temp.help_text[0]
         $game_temp.help_text[0] = false
         @help_window.set_text($game_temp.help_text[1])
      end       
  end
    
end

#==============================================================================
# ■ Tech Window
#==============================================================================
class Tech_Window < Window_Base
  include SCHALA_BASE_SPRITES
  #--------------------------------------------------------------------------
  # ● Initialize
  #--------------------------------------------------------------------------
  def initialize
      super(0, 0, 160, 120)
      self.contents.font.size = TECH_WINDOW_FONT_SIZE
      self.contents.font.bold = TECH_WINDOW_FONT_BOLD
      self.contents.font.name = TECH_WINDOW_FONT_NAME
      self.opacity = 0
      refresh
  end

  #--------------------------------------------------------------------------
  # ● Refresh
  #--------------------------------------------------------------------------
  def refresh
      $game_temp.temp_tech_window[0] = false      
      return if $game_temp.temp_tech_window[1].size < 2 
      contents.clear
      self.contents_opacity = 0
      self.x = TECH_WINDOW_POSITION[0] - 100
      index = 0
      members_size = $game_temp.temp_tech_window[1].size
      if members_size == 2
         tech_name = MULTI_TECH_NAME[0]
      else
         tech_name = MULTI_TECH_NAME[1]
      end        
      self.contents.font.color = Color.new(50,255,150)
      self.contents.draw_text(0,0,120,32,tech_name.to_s,0) 
      self.contents.font.color = Color.new(255,255,255)
      y = 24
      for i in $game_temp.temp_tech_window[1]
         if i.avaliable_for_skill?($game_temp.temp_tech_window[2])
            self.contents.font.color = Color.new(255,255,255,255)
         else   
            self.contents.font.color = Color.new(255,255,255,160)
         end  
         self.contents.draw_text(0,24 + y * index,120,32,i.name,0)   
         index += 1
      end
  end

  def update
      refresh if $game_temp.temp_tech_window[0]
  end
  
end

#===============================================================================
# ■ Schala Base Sprites
#===============================================================================
class Schala_Base_Sprites
  
  #--------------------------------------------------------------------------
  # ● Create Skill Window
  #--------------------------------------------------------------------------                
  def create_skill_window
      @skill_window = Window_Schala_skill.new
      @skill_window.visible = false
      @skill_window.z = SPRITES_Z 
      @skill_window.opacity = 0
      @skill_window_refresh = false      
      @tech_window = Tech_Window.new
      @tech_window.visible = true
      @tech_window.contents_opacity = 0
      @tech_window_org = [TECH_WINDOW_POSITION[0],TECH_WINDOW_POSITION[1]]
      @tech_window.x = @tech_window_org[0] - 50
      @tech_window.y = @tech_window_org[1]
      @tech_window.z = SPRITES_Z 
  end
   
  #--------------------------------------------------------------------------
  # ● Dispose Skill Window
  #--------------------------------------------------------------------------                  
  def dispose_skill_window
      return if @skill_window == nil
      @skill_window.dispose
      @tech_window.dispose
  end
  
  #--------------------------------------------------------------------------
  # ● Skill Window Visible?
  #--------------------------------------------------------------------------                    
  def skill_window_visible?
      return false if !$game_temp.battle_phase[0]
      return false if $game_temp.battle_phase[1]
      return false if $game_temp.command_phase != 3 
      return false if $game_temp.turn_sprite_phase != 0
      return false if @actor != nil and @actor.fade
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● Update Skill Window
  #--------------------------------------------------------------------------                  
  def update_skill_window
      return if @skill_window == nil
      if skill_window_visible?
         @skill_window.visible = true
      else   
         @skill_window.visible = false
         @skill_window_refresh = false
         @tech_window.x = @tech_window_org[0] - 100
         @tech_window.contents_opacity = 0
      end        
      @tech_window.visible = @skill_window.visible
      return if @actor == nil or !@skill_window.visible
      update_force_update_skill_window
      if !@skill_window_refresh and @skill_window.visible
          @skill_window_refresh = true
          @skill_window.refresh(@actor)
          @tech_window.refresh
          @tech_window.x = @tech_window_org[0] - 100
          @tech_window.contents_opacity = 0          
      end      
      if @skill_window.visible
         @skill_window.update
         @tech_window.update
         update_tech_window
      end   
  end
  
  #--------------------------------------------------------------------------
  # ● Update Tech Window
  #--------------------------------------------------------------------------                    
  def update_tech_window
      return if $game_temp.command_wait > 0
      slide_speed = 8
      opacity_speed = 7
      if $game_temp.temp_tech_window[3]    
         @tech_window.contents_opacity += opacity_speed
         if @tech_window.x < @tech_window_org[0]
            @tech_window.x += slide_speed
            @tech_window.contents_opacity += opacity_speed
            if @tech_window.x >= @tech_window_org[0]
               @tech_window.x = @tech_window_org[0]
            end  
         end   
      else
          @tech_window.contents_opacity -= opacity_speed
          if @tech_window.x > @tech_window_org[0] - 100
            @tech_window.x -= slide_speed
            @tech_window.contents_opacity -= opacity_speed
            if @tech_window.x <= @tech_window_org[0] - 100
               @tech_window.x = @tech_window_org[0] - 100
            end  
         end            
       end  
  end
     
  #--------------------------------------------------------------------------
  # ● Update force update Skill Window
  #--------------------------------------------------------------------------
  def update_force_update_skill_window
      return if $game_temp.force_refresh_skill_window == 0
      $game_temp.force_refresh_skill_window -= 1
      if $game_temp.force_refresh_skill_window == 0
         @skill_window.refresh(@actor)
         @tech_window.refresh
      end   
  end  
  
end  

#===============================================================================
# ■ Game Battler
#===============================================================================
class Game_Battler < Game_BattlerBase
  
  #--------------------------------------------------------------------------
  # ● Item Effect Gain TP
  #--------------------------------------------------------------------------                      
  alias schala_item_effect_gain_tp item_effect_gain_tp
  def item_effect_gain_tp(user, item, effect)
      schala_item_effect_gain_tp(user, item, effect)
      force_refresh_skill_window
  end
  
  #--------------------------------------------------------------------------
  # ● Charge Tp By Damage
  #--------------------------------------------------------------------------
  alias schala_charge_tp_by_damage charge_tp_by_damage
  def charge_tp_by_damage(damage_rate)
      schala_charge_tp_by_damage(damage_rate)
      force_refresh_skill_window
  end  
  
  #--------------------------------------------------------------------------
  # ● Force Refresh Skill Window
  #--------------------------------------------------------------------------                    
  def force_refresh_skill_window
      return if $game_temp.command_phase != 3
      $game_temp.force_refresh_skill_window = 30      
  end
  
end

#==============================================================================
# ■ Window_Schala_skill
#==============================================================================
class Window_Schala_skill < Window_Selectable
 include Schala_Window_Base 
  
 #--------------------------------------------------------------------------
 # ● Initialize
 #--------------------------------------------------------------------------  
  def initialize
      size_x = Graphics.width
      size_y = 96
      center_x = 0
      center_y = Graphics.height - size_y
      super(center_x , center_y, size_x, size_y)
      select(0)      
      activate
      @old_index = -1
  end
 
 #------------------------------------------------------------------------------
 # ● Col Max
 #------------------------------------------------------------------------------       
  def col_max
      return 2
  end
    
 #------------------------------------------------------------------------------
 # ● Item Max
 #------------------------------------------------------------------------------         
  def item_max
      return @item_max == nil ? 0 : @item_max 
  end   
  
 #--------------------------------------------------------------------------
 # ● Skill
 #--------------------------------------------------------------------------  
  def skill
      return @data[self.index]
  end
  
 #--------------------------------------------------------------------------
 # ● Refresh
 #--------------------------------------------------------------------------  
  def refresh(actor)      
      @actor = actor      
      self.contents.clear
      self.index = 0 unless @actor_old == @actor
      @actor_old = @actor
      @data = []
      for skill in actor.battler.skills
        if skill.battle_ok?
           @data.push(skill) unless !cooperation_skill_party_met?(skill)
        end   
      end
      @item_max = @data.size
      create_contents
      for i in 0...@item_max
        draw_item(i)
      end
  end
    
 #--------------------------------------------------------------------------
 # ● Draw Item
 #--------------------------------------------------------------------------  
  def draw_item(index)
      rect = item_rect(index)
      self.contents.clear_rect(rect)
      skill = @data[index]
      if skill != nil
         rect = item_rect(index)
         rect.width -= 4
         type = cooperation_skill?(skill) ? 1 : 0 
         draw_item_name_schala(skill, rect.x, rect.y, enable_skill?(skill),type)
         draw_skill_cost(rect, skill)
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Draw Skill Cost
  #--------------------------------------------------------------------------
  def draw_skill_cost(rect, skill)
      if @actor.battler.skill_tp_cost(skill) > 0
         change_color(tp_cost_color, enable_skill?(skill))
         draw_text(rect, @actor.battler.skill_tp_cost(skill), 2)
      elsif @actor.battler.skill_mp_cost(skill) > 0
         change_color(mp_cost_color, enable_skill?(skill))
         draw_text(rect, @actor.battler.skill_mp_cost(skill), 2)
      end
  end
  
  #--------------------------------------------------------------------------
  # ● Enable?
  #--------------------------------------------------------------------------
  def enable?(item)
      @actor && @actor.battler.usable?(item)
  end  
  
  #--------------------------------------------------------------------------
  # ● Current Item Enable?
  #--------------------------------------------------------------------------  
  def current_item_enabled?
      enable?(@data[index])
  end  
  
 #--------------------------------------------------------------------------
 # ● Cursor Page Down
 #--------------------------------------------------------------------------    
  def cursor_pagedown
  end
  
 #--------------------------------------------------------------------------
 # ● Cursor Page Up
 #--------------------------------------------------------------------------      
  def cursor_pageup
  end

 #--------------------------------------------------------------------------
 # ● Update
 #--------------------------------------------------------------------------        
  def update
      super
      update_skill_select
  end
  
 #--------------------------------------------------------------------------
 # ● Can Update Skill Command
 #--------------------------------------------------------------------------          
  def can_update_skill_command?
      return false if $game_temp.battle_phase[1]
      return false if $game_temp.command_phase != 3 
      return false if $game_temp.command_wait > 0
      return false if @data == nil or @actor == nil    
      return true
  end
  
 #--------------------------------------------------------------------------
 # ● Update Skill Select
 #--------------------------------------------------------------------------        
  def update_skill_select
      return unless can_update_skill_command?
      update_help_text
      if Input.trigger?(:C)
         execute_skill_selection
      elsif Input.trigger?(:B)  
         execute_cancel_selection
     end    
  end
 
 #--------------------------------------------------------------------------
 # ● Execute Skill Selection
 #--------------------------------------------------------------------------          
  def execute_skill_selection      
      skill_id = @data[self.index].id rescue nil
      skill = $data_skills[skill_id] rescue nil
      if !can_execute_selection?(skill)
         Sound.play_buzzer
         return
      end
      @actor.action_movement[2] = skill_id rescue nil
      $game_temp.command_wait = 5
      select_target_type(skill) 
      @actor = nil
      @data = nil
      @old_index = -1 
 end      
  
 #--------------------------------------------------------------------------
 # ● Update Skill Select
 #--------------------------------------------------------------------------          
 def update_help_text
     return if skill == nil
     return if @old_index == self.index
     @old_index = self.index
     text = skill.description
     $game_temp.help_text = [true,text]     
     skill_c = SCHALA_COOPERATION_SKILL::COOPERATION_SKILL_ID[skill.id] rescue nil
     $game_temp.temp_tech_window = [true,[], nil,false]
     return if skill_c == nil or skill_c.size < 2 
     $game_temp.temp_tech_window[2] = skill
     $game_temp.temp_tech_window[3] = true
     actor_id = 1
     for i in $game_party.members
          for coop_member_id in skill_c
             if i.actor_id == coop_member_id
                $game_temp.temp_tech_window[1].push(i)
             end
          end
     end       
     $game_temp.temp_tech_window[1] = [] if $game_temp.temp_tech_window[1].size != skill_c.size 
  end
 
end

#===============================================================================
# ■ Schala Base Sprites
#===============================================================================
class Schala_Base_Sprites
  
  #--------------------------------------------------------------------------
  # ● Create Item Window
  #--------------------------------------------------------------------------                
  def create_item_window
      @item_window = Window_Schala_Item.new
      @item_window.z = SPRITES_Z
      @item_window.visible = false
      @item_window.opacity = 0
      @item_window_refresh = false
  end
   
  #--------------------------------------------------------------------------
  # ● Dispose Item Window
  #--------------------------------------------------------------------------                  
  def dispose_item_window
      return if @item_window == nil
      @item_window.dispose
  end
  
  #--------------------------------------------------------------------------
  # ● Item Window Visible?
  #--------------------------------------------------------------------------                    
  def item_window_visible?
      return false if !$game_temp.battle_phase[0]
      return false if $game_temp.battle_phase[1]
      return false if $game_temp.command_phase != 4 
      return false if $game_temp.turn_sprite_phase != 0
      return false if @actor != nil and @actor.fade
      return true    
    
  end
  
  #--------------------------------------------------------------------------
  # ● Update Item Window
  #--------------------------------------------------------------------------                  
  def update_item_window
      return if @item_window == nil
      if item_window_visible?
         @item_window.visible = true
      else   
         @item_window.visible = false
         @item_window_refresh = false
      end        
      return if @actor == nil or !@item_window.visible
      if !@item_window_refresh and @item_window.visible
          @item_window_refresh = true
          @item_window.refresh(@actor)
      end
      @item_window.update if @item_window.visible
  end
  
end  

#==============================================================================
# ■ Window_Schala_Item
#==============================================================================
class Window_Schala_Item < Window_Selectable
 include Schala_Window_Base 
 
 #--------------------------------------------------------------------------
 # ● Initialize
 #--------------------------------------------------------------------------  
  def initialize
      size_x = Graphics.width
      size_y = 96
      center_x = 0
      center_y = Graphics.height - size_y
      super(center_x , center_y, size_x, size_y)
      select(0)      
      activate
      @old_index = -1
  end
 
 #------------------------------------------------------------------------------
 # ● Col Max
 #------------------------------------------------------------------------------       
  def col_max
      return 2
  end
    
 #------------------------------------------------------------------------------
 # ● Item Max
 #------------------------------------------------------------------------------         
  def item_max
      return @item_max == nil ? 0 : @item_max 
  end   
  
 #--------------------------------------------------------------------------
 # ● item
 #--------------------------------------------------------------------------  
 def item
     @data && index >= 0 ? @data[index] : nil
 end
  
 #--------------------------------------------------------------------------
 # ● Refresh
 #--------------------------------------------------------------------------  
  def refresh(actor)      
      @actor = actor      
      self.contents.clear
      self.index = 0 unless @actor_old == @actor
      @actor_old = @actor
      @data = []
      for item in $game_party.items
        if item.note =~ /<Action ID = (\d+)>/ and item.battle_ok?
           @data.push(item)
        end   
      end
      @item_max = @data.size
      create_contents
      for i in 0...@item_max
        draw_item(i)
      end
  end
    
 #--------------------------------------------------------------------------
 # ● Draw Item
 #--------------------------------------------------------------------------  
  def draw_item(index)
      item = @data[index]
      if item
        rect = item_rect(index)
        rect.width -= 4
        draw_item_name(item, rect.x, rect.y, enable?(item))
        draw_item_number(rect, item)
      end
  end

  #--------------------------------------------------------------------------
  # ● アイテムの個数を描画
  #--------------------------------------------------------------------------
  def draw_item_number(rect, item)
      draw_text(rect, sprintf(":%2d", $game_party.item_number(item)), 2)
  end  
  
  #--------------------------------------------------------------------------
  # ● Enable?
  #--------------------------------------------------------------------------
  def enable?(item)
      @actor && @actor.battler.usable?(item)
  end  
  
  #--------------------------------------------------------------------------
  # ● Current Item Enable?
  #--------------------------------------------------------------------------  
  def current_item_enabled?
      enable?(@data[index])
  end  

 #--------------------------------------------------------------------------
 # ● Cursor Page Down
 #--------------------------------------------------------------------------    
  def cursor_pagedown
  end
  
 #--------------------------------------------------------------------------
 # ● Cursor Page Up
 #--------------------------------------------------------------------------      
  def cursor_pageup
  end

 #--------------------------------------------------------------------------
 # ● Update
 #--------------------------------------------------------------------------        
  def update
      super
      update_item_select
  end
  
 #--------------------------------------------------------------------------
 # ● Can Update Item Command
 #--------------------------------------------------------------------------          
  def can_update_item_command?
      return false if $game_temp.battle_phase[1]
      return false if $game_temp.command_phase != 4 
      return false if $game_temp.command_wait > 0
      return false if @data == nil or @actor == nil    
      return true
  end  
  
 #--------------------------------------------------------------------------
 # ● Update Item Select
 #--------------------------------------------------------------------------        
  def update_item_select
      return unless can_update_item_command?
      update_help_text
      if Input.trigger?(:C)
         execute_item_selection
      elsif Input.trigger?(:B)  
         execute_cancel_selection
     end    
  end
  
 #--------------------------------------------------------------------------
 # ● Execute Item Selection
 #--------------------------------------------------------------------------          
  def execute_item_selection        
      action = @data[self.index].id rescue nil
      item = $data_items[action] rescue nil
      if item != nil
         skill_id = $1.to_i if item.note =~ /<Action ID = (\d+)>/ 
      end
      skill = $data_skills[skill_id] rescue nil
      if !can_execute_selection?(skill) or !enable?(item)
          Sound.play_buzzer
          return
      end
      $game_temp.command_wait = 5
      @actor.action_movement[2] = skill_id rescue nil
      select_target_type(skill) 
      @actor = nil
      @data = nil
      @old_index = -1
 end 
         
 #--------------------------------------------------------------------------
 # ● Update Skill Select
 #--------------------------------------------------------------------------          
 def update_help_text
     return if item == nil
     return if @old_index == self.index
     @old_index = self.index
     text = item.description
     $game_temp.help_text = [true,text]
 end
 
end

#===============================================================================
# ■ Schala Base Sprites
#===============================================================================
class Schala_Base_Sprites  

  #--------------------------------------------------------------------------
  # ● Create Info Layout
  #--------------------------------------------------------------------------                                
  def create_info_layout
      @info_layout = Sprite.new
      @info_layout.bitmap = $game_temp.schala_cache[4]
      @info_layout.z = SPRITES_Z - 1
      @info_layout.visible = false
      @info_layout.opacity = 0
  end
  
  #--------------------------------------------------------------------------
  # ● Dispose Info Layout
  #--------------------------------------------------------------------------                                  
  def dispose_info_layout
      return if @info_layout == nil
      @info_layout.dispose
  end
  
  #--------------------------------------------------------------------------
  # ● Update Info Layout
  #--------------------------------------------------------------------------                                  
  def update_info_layout
      return if @info_layout == nil 
      if @item_window.visible or @skill_window.visible
         @info_layout.visible = true
         @info_layout.opacity += 25
      else   
         @info_layout.visible = false
         @info_layout.opacity = 0
      end
  end
  
end

#===============================================================================
# ■ Schala Base Sprites
#===============================================================================
class Schala_Base_Sprites
  
  #--------------------------------------------------------------------------
  # ● Create Escape Meter
  #--------------------------------------------------------------------------                   
  def create_escape_meter
      @escape_layout = Sprite.new
      @escape_layout.bitmap = $game_temp.schala_cache[5]
      @escape_layout.z = SPRITES_Z
      @escape_layout.x = ESCAPE_POSITION[0]
      @escape_layout.y = ESCAPE_POSITION[1]     
      @escape_meter_image = $game_temp.schala_cache[6]
      @escape_meter_cw = @escape_meter_image.width
      @escape_meter_ch = @escape_meter_image.height
      @escape_meter = Sprite.new
      @escape_meter.bitmap = Bitmap.new(@escape_meter_cw,@escape_meter_ch)
      @escape_meter.z = SPRITES_Z + 1
      @escape_meter.x = ESCAPE_POSITION[0] + ESCAPE_METER_POSITION[0]
      @escape_meter.y = ESCAPE_POSITION[1] + ESCAPE_METER_POSITION[1]   
      @escape_meter.opacity = 0
      @escape_layout.opacity = 0      
      @escape_meter.visible = false
      @escape_layout.visible = false
  end
  
  #--------------------------------------------------------------------------
  # ● Dispose Escape Meter
  #--------------------------------------------------------------------------                    
  def dispose_escape_meter
      return if @escape_layout == nil
      @escape_layout.dispose  
      @escape_layout = nil
      @escape_meter.bitmap.dispose
      @escape_meter.dispose  
      @escape_meter = nil      
  end
  
  #--------------------------------------------------------------------------
  # ● Dispose Escape Meter
  #--------------------------------------------------------------------------                    
  def update_escape_meter
      return if @escape_layout == nil
      update_visible
      update_escape_meter_range
  end
  
  #--------------------------------------------------------------------------
  # ● Update Visible
  #--------------------------------------------------------------------------                      
  def update_visible
      if $game_system.escape_phase[1] > 0 and $game_system.escape_phase[1] < $game_system.escape_phase[2] and
         $game_temp.turn_sprite_phase == 0
         @escape_meter.opacity += 25
         @escape_layout.opacity += 25
         @escape_meter.visible = true
         @escape_layout.visible = true
      else
         @escape_meter.opacity -= 15
         @escape_layout.opacity -= 15  
         if @escape_layout.opacity == 0
            @escape_layout.visible = false
            @escape_layout.visible = false
         end
      end  
  end
  
  #--------------------------------------------------------------------------
  # ● Create Escape Meter Range
  #--------------------------------------------------------------------------                     
  def update_escape_meter_range
      return if !@escape_meter.visible
      @escape_meter.bitmap.clear
      range = @escape_meter_cw * $game_system.escape_phase[1] /  $game_system.escape_phase[2]
      escape_scr = Rect.new(0,0,range,@escape_meter_ch )
      @escape_meter.bitmap.blt(0,0, @escape_meter_image, escape_scr)
  end    
  
end

#===============================================================================
# ■ Schala Base Sprites
#===============================================================================
class Schala_Base_Sprites

  #--------------------------------------------------------------------------
  # ● update Cursor
  #--------------------------------------------------------------------------    
  def create_cursor
      @cursor_float = [0,0]
      @cursor = Sprite.new
      @cursor.bitmap = $game_temp.schala_cache[7]
      @cursor_pos = [TARGET_CURSOR_POSITION[0] ,TARGET_CURSOR_POSITION[1]]
      @cursor.z = SPRITES_Z - 1
      @cursor_old_name = ""
      create_name_sprite
      create_target_hp
  end
  
  #--------------------------------------------------------------------------
  # ● Create Target HP
  #--------------------------------------------------------------------------      
  def create_target_hp
      @target_hp1 = Sprite.new
      @target_hp1.bitmap = $game_temp.schala_cache[8]
      @target_hp1.z = @cursor.z
      @target_hp_org = [-@cursor.bitmap.width + (@target_hp1.bitmap.width / 2) + TARGET_HP_POSITION[0],@cursor.bitmap.height + TARGET_HP_POSITION[1]]
      @target_hp_image = $game_temp.schala_cache[9]
      @target_hp_cw = @target_hp_image.width
      @target_hp_ch = @target_hp_image.height
      @target_hp2 = Sprite.new
      @target_hp2.bitmap = Bitmap.new(@target_hp_cw,@target_hp_ch)
      @target_hp2_org = [TARGET_METER_POSITION[0],TARGET_METER_POSITION[1]]      
      @target_hp2.z = @cursor.z 
      @old_hp = 0
  end
  
  #--------------------------------------------------------------------------
  # ● Create Name Sprite
  #--------------------------------------------------------------------------      
  def create_name_sprite
      @sprite_name = Sprite.new
      @sprite_name.bitmap = Bitmap.new(120,32)
      @sprite_name.bitmap.font.bold = true
      @sprite_name.bitmap.font.size = 18
      @sprite_name.z = @cursor.z
      @sprite_name_pos = [-@cursor.bitmap.width + TARGET_NAME_POSITION[0],@cursor.bitmap.height + TARGET_NAME_POSITION[1]]
  end
  
  #--------------------------------------------------------------------------
  # ● Dispose Cursor
  #--------------------------------------------------------------------------    
  def dispose_cursor
      return if @cursor == nil
      @cursor.dispose
      @cursor = nil
      @sprite_name.bitmap.dispose
      @sprite_name.dispose
      dispose_target_hp
  end
  
  #--------------------------------------------------------------------------
  # ● Dispose Target HP
  #--------------------------------------------------------------------------        
  def dispose_target_hp
      return if @target_hp1 ==nil
      @target_hp1.dispose
      @target_hp1 = nil
      @target_hp2.bitmap.dispose
      @target_hp2.dispose
  end  
 
  #--------------------------------------------------------------------------
  # ● Target Cursor Visible
  #--------------------------------------------------------------------------      
  def target_cursor_visible?
      return false if $game_temp.turn_sprite_phase != 0
      return false if !$game_temp.command_selection
      return false if $game_temp.battle_phase[1]
      return false if !$game_temp.command_phase.between?(1,2)
      return false if @actor != nil and @actor.fade
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● update Cursor
  #--------------------------------------------------------------------------    
  def update_cursor
      return if @cursor == nil
      if target_cursor_visible?
         @cursor.visible = true
      else
        @cursor.visible = false
        @cursor.opacity = 0
        if @actor != nil
           @cursor.x = @actor.screen_x
           @cursor.y = @actor.screen_y
        else  
           @cursor.x = 0
           @cursor.y = 0
        end
      end
      @sprite_name.x = @cursor.x + @sprite_name_pos[0]
      @sprite_name.y = @cursor.y + @sprite_name_pos[1]
      @sprite_name.visible = @cursor.visible
      @sprite_name.opacity = @cursor.opacity
      @target_hp1.x = @cursor.x + @target_hp_org[0]
      @target_hp1.y = @cursor.y + @target_hp_org[1]
      @target_hp1.opacity = @cursor.opacity      
      @target_hp2.x = @target_hp1.x + @target_hp2_org[0]
      @target_hp2.y = @target_hp1.y + @target_hp2_org[1]
      @target_hp2.opacity = @cursor.opacity
      @target_hp1.visible = @cursor.visible
      @target_hp2.visible = @cursor.visible
      return if @actor == nil or !@cursor.visible
      return if @actor.action_movement[4] == nil or !@cursor.visible
      @cursor.opacity += 145
      update_cursor_float_effect
      execute_move(0,@cursor.x,@actor.action_movement[4].screen_x + @cursor_pos[0])
      execute_move(1,@cursor.y,@actor.action_movement[4].screen_y + @cursor_float[1] + @cursor_pos[1]) #- @actor.action_movement[4].sprite_size[7])      
      refresh_target_hp if @old_hp != @actor.action_movement[4].battler.hp
      refresh_target_name if $game_temp.refresh_target_name
  end
  
  #--------------------------------------------------------------------------
  # ● Refresh Target HP
  #--------------------------------------------------------------------------                  
  def refresh_target_hp
      @old_hp = @actor.battler.hp
      @target_hp2.bitmap.clear
      refresh_target_hp_visible
      return if !@target_hp1.visible
      hpw = @target_hp_cw * @actor.action_movement[4].battler.hp / @actor.action_movement[4].battler.mhp
      hp_scr = Rect.new(0,0,hpw, @target_hp_ch)
      @target_hp2.bitmap.blt(0,0,@target_hp_image, hp_scr)
  end
  
  #--------------------------------------------------------------------------
  # ● Refresh Target HP Visible
  #--------------------------------------------------------------------------                  
  def refresh_target_hp_visible
      if !TARGET_HP_METER_ACTIVE 
         (@actor.action_movement[4].battler.is_a?(Game_Enemy) and
          @actor.action_movement[4].battler.hide_hp)
        @target_hp1.visible = false
        @target_hp2.visible = false            
      else
        @target_hp1.visible = @cursor.visible
        @target_hp2.visible = @cursor.visible
      end
  end
    
  #--------------------------------------------------------------------------
  # ● Refresh Target Name
  #--------------------------------------------------------------------------                
  def refresh_target_name
      $game_temp.refresh_target_name = false
      target_name = @actor.action_movement[4].battler.name
      return if @cursor_old_name == target_name
      @cursor_old_name = target_name
      @sprite_name.bitmap.clear
      @sprite_name.bitmap.draw_text(0,0,110,32,target_name ,1)
  end
  
  #--------------------------------------------------------------------------
  # ● Update Cursor Float Effect
  #--------------------------------------------------------------------------              
  def update_cursor_float_effect
      @cursor_float[0] += 1
      case @cursor_float[0]
        when 0..20
          @cursor_float[1] += 1
        when 21..40
          @cursor_float[1]  -= 1
        else
          @cursor_float[0] = 0
          @cursor_float[1] = 0
      end        
  end
  
  #--------------------------------------------------------------------------
  # ● Execute Move
  #--------------------------------------------------------------------------      
  def execute_move(type,cp,np)
      sp = 5 + ((cp - np).abs / 5)
      if cp > np 
         cp -= sp
         cp = np if cp < np
      elsif cp < np 
         cp += sp
         cp = np if cp > np
      end     
      @cursor.x = cp if type == 0
      @cursor.y = cp if type == 1
  end   
  
end

#===============================================================================
# ■ Schala Base Sprites
#===============================================================================
class Schala_Base_Sprites

  #--------------------------------------------------------------------------
  # ● update Cursor
  #--------------------------------------------------------------------------    
  def create_cursor2
      @cursor2_float = [0,0]
      @cursor2 = Sprite.new
      @cursor2.bitmap = $game_temp.schala_cache[10]
      @cursor2.z = SPRITES_Z - 3
      @cursor2_pos = [-12,0]
  end
  
  #--------------------------------------------------------------------------
  # ● Dispose Cursor
  #--------------------------------------------------------------------------    
  def dispose_cursor2
      return if @cursor2 == nil
      @cursor2.dispose
      @cursor2 = nil
  end
  
  #--------------------------------------------------------------------------
  # ● user Cursorv Visible?
  #--------------------------------------------------------------------------     
  def user_cursor_visible?
      return false if $game_temp.turn_sprite_phase != 0
      return false if !$game_temp.command_selection
      return false if $game_temp.battle_phase[1]
      return false if @actor != nil and @actor.fade
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● update Cursor
  #--------------------------------------------------------------------------    
  def update_cursor2
      return if @cursor2 == nil      
      if user_cursor_visible?
         @cursor2.visible = true
      else   
         @cursor2.visible = false
      end  
      @cursor2.opacity = 0 if !@cursor2.visible
      return if @actor == nil or !@cursor2.visible
      @cursor2.opacity += 25
      update_cursor2_float_effect
      execute_move2(0,@cursor2.x,@actor.screen_x + @cursor2_pos[0])
      execute_move2(1,@cursor2.y,@actor.screen_y + @cursor2_float[1] + @cursor2_pos[1])      
  end
  
  #--------------------------------------------------------------------------
  # ● Update Cursor 2 Float Effect
  #--------------------------------------------------------------------------              
  def update_cursor2_float_effect
      @cursor2_float[0] += 1
      case @cursor2_float[0]
        when 0..20
          @cursor2_float[1] += 1
        when 21..40
          @cursor2_float[1]  -= 1
        else
          @cursor2_float[0] = 0
          @cursor2_float[1] = 0
      end        
  end  
  
  #--------------------------------------------------------------------------
  # ● Execute Move
  #--------------------------------------------------------------------------      
  def execute_move2(type,cp,np)
      sp = 5 + ((cp - np).abs / 5)
      if cp > np 
         cp -= sp
         cp = np if cp < np
      elsif cp < np 
         cp += sp
         cp = np if cp > np
      end     
      @cursor2.x = cp if type == 0
      @cursor2.y = cp if type == 1
  end   
  
end

#==============================================================================
# ■ Spriteset Map
#==============================================================================
class Schala_Base_Sprites

  #--------------------------------------------------------------------------
  # ● Create Command
  #--------------------------------------------------------------------------    
  def create_command
      return if @command_layout != nil
      @command_layout = Sprite.new
      @command_layout.bitmap = $game_temp.schala_cache[11]
      @command_layout.z = SPRITES_Z - 2 
      @com_pos = [-(@command_layout.bitmap.width / 2) + 10 + COMMAND_POSITION[0],-40 - @command_layout.height + COMMAND_POSITION[1]]
      create_command_list
  end
  
  #--------------------------------------------------------------------------
  # ● Create Command List
  #--------------------------------------------------------------------------      
  def create_command_list
      @command_list_image = $game_temp.schala_cache[12]
      @command_list_cw = @command_list_image.width
      @command_list_ch = @command_list_image.height / 4
      @command_list = Sprite.new
      @command_list.bitmap = Bitmap.new(120,@command_list_ch)
      @command_list.z = SPRITES_Z - 1
      @com_pos2 = [COMMAND_ICON_POSITION[0],COMMAND_ICON_POSITION[1]]  
      @com_index = $game_temp.command_index
      refresh_command_text
  end
  
  #--------------------------------------------------------------------------
  # ● Refresh Command Text
  #--------------------------------------------------------------------------        
  def refresh_command_text
      @com_slide_x = $game_temp.com_slide_type[0] == 1 ? 20 : -20
      $game_temp.com_slide_type[1] = false
      @command_list.bitmap.clear
      @com_index = $game_temp.command_index
      xch = @command_list_ch * $game_temp.command_index 
      l_rect = Rect.new(0,xch,@command_list_cw,@command_list_ch)
      @command_list.bitmap.blt(0,0, @command_list_image, l_rect )
  end
  
  #--------------------------------------------------------------------------
  # ● Dispose Command
  #--------------------------------------------------------------------------    
  def dispose_command
      return if @command_layout == nil
      @command_layout.dispose
      @command_layout = nil
      @command_list.bitmap.dispose
      @command_list.dispose
      @command_list = nil
  end    
  
  #--------------------------------------------------------------------------
  # ● Update Command
  #--------------------------------------------------------------------------  
  def command_visible?
      return false if @cursor.visible
      return false if !$game_temp.command_selection
      return false if $game_system.escape_phase[1] != 0
      return false if $game_temp.command_phase.between?(3,4)
      return true
  end
  
  #--------------------------------------------------------------------------
  # ● Update Command
  #--------------------------------------------------------------------------  
  def update_command
      return if @command_layout == nil
      if command_visible?
         vis = true
      else
         vis = false
         @command_layout.opacity = 0
         @command_list.opacity = 0         
      end
      if $game_temp.com_slide_type[0] == 1
         @com_slide_x -= 2 if @com_slide_x > 0
      else   
         @com_slide_x += 2 if @com_slide_x < 0
      end  
      vis = false if @actor != nil and @actor.fade
      @command_layout.visible = vis
      @command_list.visible = vis
      return if @actor == nil or !@command_layout.visible
      @command_layout.opacity += 20
      @command_list.opacity += 20 
      if @com_index != $game_temp.command_index or $game_temp.com_slide_type[1]
         refresh_command_text 
      end
      @command_layout.x = @actor.screen_x + @com_pos[0]
      @command_layout.y = @actor.screen_y + @com_pos[1]    
      @command_list.x = @command_layout.x + @com_pos2[0] + @com_slide_x
      @command_list.y = @command_layout.y + @com_pos2[1]      
      @command_list.y = @com_pos2[1] if  @command_list.y <  @com_pos2[1]
      @command_layout.y = 0 if @command_layout.y < 0
  end
  
end




#===============================================================================
# ■  Game_Map
#===============================================================================
class Game_Map  
  #--------------------------------------------------------------------------
  # ● clear_tokens 
  #--------------------------------------------------------------------------
  alias hookshot_clear_tokens clear_tokens
  def clear_tokens
      $game_temp.hookshot = false
      hookshot_clear_tokens 
  end
  
  #--------------------------------------------------------------------------
  # ● Execute Toll Effects Hash
  #--------------------------------------------------------------------------        
  alias mog_hookshot_execute_tool_effects_hash execute_tool_effects_hash
  def execute_tool_effects_hash(i)
      mog_hookshot_execute_tool_effects_hash(i)
      if i.hookshot
         $game_temp.hookshot_tool_id = i.id
      end   
  end    
  
end  
  
#===============================================================================
# ■ Game_Action_XAS
#===============================================================================
class Game_Action_XAS 
  
  #--------------------------------------------------------------------------
  # ● attachment 
  #--------------------------------------------------------------------------
  alias hookshot_attachment attachment
  def attachment(action_id)
      hookshot_attachment(action_id)
      check_hookshot_effect(action_id)
  end
  
  #--------------------------------------------------------------------------
  # ● Check Hookshot Effect
  #--------------------------------------------------------------------------  
  def check_hookshot_effect(action_id)
      return unless @skill.note =~ /<Hookshot = (\d+)>/
      @short_range = false
      @hookshot = true
      @blow_power = 1
      @attack_range_type = 3
      @attack_range_plan = 0
      @first_impact_time = 0
      @sunflag = 1000
      @duration = 1000
      @piercing = true
      @multi_hit = false
      @all_damage = false
      @ally_damage = false
      @ignore_guard = false
      @ignore_knockback_invincible = true
  end  
end

#===============================================================================
# ■ Token_Bullet  
#===============================================================================
class Token_Bullet < Token_Event
  
  #--------------------------------------------------------------------------
  # ● Check Tool Effects
  #--------------------------------------------------------------------------    
  alias x_hookshot_check_tool_effects check_tool_effects
  def check_tool_effects(user,skill,pre_direction)
      x_hookshot_check_tool_effects(user,skill,pre_direction)
      hookshot_setup(user,skill,pre_direction)
  end
    
  #--------------------------------------------------------------------------
  # ● Hookshot Setup
  #--------------------------------------------------------------------------     
  def hookshot_setup(user,skill,pre_direction)
      return if user.is_a?(Game_Event)    
      return unless skill.note =~ /<Hookshot = (\d+)>/
      self.hookshot = true
      self.diagonal = false
      self.direction_fix = true
      self.force_action = "Forward"
      self.force_action_times = $1.to_i
      self.move_frequency = 6
      self.force_update = true
  end
  
end

#===============================================================================
# ■ Game Party
#===============================================================================
class Game_Party < Game_Unit

  #--------------------------------------------------------------------------
  # ● Change Leader
  #--------------------------------------------------------------------------                  
  alias x_hookshot_change_leader_effect change_leader
  def change_leader
      $game_temp.hookshot_tool_id = 0
      $game_temp.hookshot = false      
      x_hookshot_change_leader_effect
  end

end  

#==============================================================================
# ■ XRXS_Hookshoot_Sprite
#==============================================================================
class Hookshot_Sprite
  
 #--------------------------------------------------------------------------
 # ● Initialize
 #--------------------------------------------------------------------------       
  def initialize
      create_chain
      update_sprite
      update_angle
      update_position    
  end
  
 #--------------------------------------------------------------------------
 # ● Create Chain
 #--------------------------------------------------------------------------         
  def create_chain
      @old_direction = 0 
      @chain_image = $game_temp.schala_cache[13]
      @chain_cw = @chain_image.width
      @chain_ch = @chain_image.height 
      @chain_sprite = Sprite.new
      @chain_sprite.bitmap = Bitmap.new(544,@chain_ch)
  end
  
 #--------------------------------------------------------------------------
 # ● Dispose
 #--------------------------------------------------------------------------         
  def dispose
      @chain_sprite.bitmap.dispose
      @chain_sprite.dispose
  end
  
 #--------------------------------------------------------------------------
 # ● Update
 #--------------------------------------------------------------------------         
  def update
      update_visible
      return unless @chain_sprite.visible
      update_sprite
      update_angle
      update_position
  end  
  
 #--------------------------------------------------------------------------
 # ● Update Position
 #--------------------------------------------------------------------------             
  def update_visible
      if $game_temp.hookshot_tool_id == 0 or $game_temp.battle_phase[0]
         @chain_sprite.visible = false 
      else
         @chain_sprite.visible = true
      end  
  end  
  
 #--------------------------------------------------------------------------
 # ● Update Position
 #--------------------------------------------------------------------------           
  def update_position
      return if $game_player.screen_z == nil  
      ex = MOG_XAS_HOOKSHOT::HOOKSHOT_SPRITE_POSITION[0]
      ey = MOG_XAS_HOOKSHOT::HOOKSHOT_SPRITE_POSITION[1]
      case $game_player.direction
          when 2
             fx = 16 + ex
             fy = -6 + ey
          when 4
             fx = -16 + ex
             fy = 0 + ey          
          when 6
             fx = 16 + ex
             fy = -32 + ey            
          when 8  
             fx = -16 + ex
             fy = -MOG_XAS_HOOKSHOT::CHARACTER_HEIGHT + ey      
      end
      @chain_sprite.z = $game_player.screen_z
      @chain_sprite.x = $game_player.screen_x + fx
      @chain_sprite.y = $game_player.screen_y + fy
  end  

 #--------------------------------------------------------------------------
 # ● Update Angle
 #--------------------------------------------------------------------------             
  def update_angle
      return if @old_direction == $game_player.direction
      @old_direction = $game_player.direction
      case $game_player.direction
         when 2; @chain_sprite.angle = 270
         when 4; @chain_sprite.angle = 180
         when 6; @chain_sprite.angle = 0
         when 8; @chain_sprite.angle = 90
      end            
  end
    
 #--------------------------------------------------------------------------
 # ● Update Sprite
 #--------------------------------------------------------------------------           
  def update_sprite
      target = $game_map.events[$game_temp.hookshot_tool_id]
      if target == nil or target.erased
         $game_temp.hookshot_tool_id = 0
         return
      end  
      @chain_sprite.bitmap.clear
      if $game_player.direction == 2 or $game_player.direction == 8
         dist = (target.screen_y - $game_player.screen_y).abs / 6
      else
         dist = (target.screen_x - $game_player.screen_x).abs / 6
      end  
      for i in 0..6
         src_rect = Rect.new(0, 0,@chain_cw , @chain_ch)
         @chain_sprite.bitmap.blt(-@chain_cw + (dist * i),0, @chain_image, src_rect)         
      end
  end
  
end

#==============================================================================
# ■ Schala Base Sprites
#==============================================================================
class Schala_Base_Sprites
  
  #--------------------------------------------------------------------------
  # ● Create Hookshot
  #--------------------------------------------------------------------------
  def create_hookshot
      @hookshot = Hookshot_Sprite.new
  end
  
  #--------------------------------------------------------------------------
  # ● dispose
  #--------------------------------------------------------------------------
  def dispose_hookshot
      @hookshot.dispose
  end
  
  #--------------------------------------------------------------------------
  # ● update   
  #--------------------------------------------------------------------------
  def update_hookshot
      @hookshot.update
  end
  
end

#===============================================================================
# ■ Sprite_Character
#===============================================================================
class Sprite_Character < Sprite_Base
  
  #--------------------------------------------------------------------------
  # ● Update Position
  #--------------------------------------------------------------------------                
  alias hookshot_update_position update_position
  def update_position
      hookshot_update_position
      if self.character.hookshot
         case $game_player.direction 
             when 2;   self.x = $game_player.screen_x 
             when 4;   self.y = $game_player.screen_y 
             when 6;   self.y = $game_player.screen_y 
             when 8;   self.x = $game_player.screen_x      
         end
      end        
  end 
       
end

$schala_battle_system = true
